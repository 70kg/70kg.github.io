<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Fresco浅析 · 70kg</title><meta name="description" content="Fresco浅析 - 70kg"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="70kg"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/应聘Android开发工程师_王鹏.pdf" target="_self" class="nav-list-link">RESUME</a></li><li class="nav-list-item"><a href="/book/" target="_self" class="nav-list-link">BOOKS</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Fresco浅析</h1><div class="post-info">Nov 30, 2017</div><div class="post-content"><h3 id="SimpleDraweeView层级初始化"><a href="#SimpleDraweeView层级初始化" class="headerlink" title="SimpleDraweeView层级初始化"></a><code>SimpleDraweeView</code>层级初始化</h3><p><code>GenericDraweeHierarchyInflater</code> 从xml中解析<code>SimpleDraweeView</code>属性值，(收集属性),然后赋值给<code>GenericDraweeHierarchyBuilder</code>去创建，在G<code>enericDraweeView</code>的构造函数中去build,创建<code>GenericDraweeHierarchy</code>，也就是初始化XML中的属性。这个和代码创建一个效果。类似placeholderImage这些是按照层级放到Drawable[]中，根据这个创建<code>mTopLevelDrawable</code>，<code>mTopLevelDrawable</code>中可以做渐变，进度等操作。就是改变Drawable[]中不同的drawable实现的。然后setController时候会设置<code>mTopLevelDrawable</code>先显示。<a id="more"></a></p>
<p>判断<code>OldController</code>能不能复用是根据<code>DraweeHolder：：isControllerValid</code>判断，实际上是<code>mController.getHierarchy() == mHierarchy</code></p>
<p><code>PipelineDraweeController</code>是唯一实现的</p>
<h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><p>内存缓存包括已经解码（<code>BitmapMemoryCache</code>）的和未解码的（<code>EncodedMemoryCache</code>）。在源码中表示为<code>MemoryCache</code>，有两个实现类，<code>InstrumentedMemoryCache</code>可以做一些自定义的东西，<code>CountingMemoryCache</code>主要缓存类。缓存的节点是<code>Entry</code>，里面有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> K key;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> CloseableReference&lt;V&gt; valueRef;</div></pre></td></tr></table></figure>
<p>使用<code>CountingLruMap</code>来存放数据，其中起作用的是<code>LinkedHashMap&lt;K, V&gt; mMap</code>。很显然是LRU。</p>
<h3 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h3><p>会有<code>CONTENT_FILE_EXTENSION = &quot;.cnt&quot;;</code>的缓存文件和<code>TEMP_FILE_EXTENSION = &quot;.tmp&quot;;</code>临时缓存文件。文件储存主要是<code>DefaultDiskStorage</code>起作用。<code>DiskStorageCache</code>是实现文件缓存的主要类，在<code>maybeEvictFilesInCacheDir</code>也实现了LRU控制缓存。上面还有一层是<code>BufferedDiskCache</code>中的<code>StagingArea mStagingArea</code>，查找的现在这里面查找，找不到通过<code>getAsync</code>从<code>DiskStorageCache</code>中查找。写入的时候会先创建临时文件，然后在<code>endInsert</code>中使用<code>commit</code>完成缓存文件替换，写入。</p>
<h3 id="Pipeline流水线"><a href="#Pipeline流水线" class="headerlink" title="Pipeline流水线"></a>Pipeline流水线</h3><p>触发加载图片请求是在进入到<code>AbstractDraweeController</code>的<code>onAttach</code>，然后 <code>submitRequest();</code>请求图片操作。先去<code>getCachedImage()</code>获取缓存解码图片，根据<code>mCacheKey</code>从<code>mMemoryCache中</code>获取，<code>mCacheKey</code>中包含url和对图片的一些设置，例如<code>resize</code>,<code>rotation</code>等，都是从<code>imagerequest</code>中获取的。<code>mMemoryCache</code>是通过<code>mImagePipeline.getBitmapMemoryCache()</code>获得，是通过<code>BitmapCountingMemoryCacheFactory创建的CountingMemoryCache</code>，</p>
<p>获取到<code>CloseableReference&lt;CloseableImage&gt;</code>，然后包装成<code>drawable</code>，通过<code>GenericDraweeHierarchy</code>设置给<code>mActualImageWrapper</code>，这个也存在之前的drawable数组中，也就是<code>ACTUAL_IMAGE</code>。</p>
<p>层层<code>Producer</code>处理，责任链,每一层存在本层能否直接给<code>Consumer</code>提供数据，不能则将<code>Consumer</code>在本层包装一下交给下一层去获取数据。本层的<code>Consumer</code>做一些缓存数据等操作。</p>
<p>例如<code>BitmapMemoryCacheProducer</code>和<code>DecodeProducer</code>就是上下层的关系。首先先在<code>BitmapMemoryCacheProducer</code>的</p>
<pre><code>produceResults(
      final Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; consumer,
      final ProducerContext producerContext)
</code></pre><p>方法中寻找解码的图片，如果有，返回给消费解码数据的<code>consumer</code>，如果没有则用本层的<code>wrapConsumer</code>包装一下消费解码图片的消费者传递给下面一层的<code>DecodeProducer</code>，调用<code>DecodeProducer</code>的<code>produceResults</code>方法。同理，<code>DecodeProduce</code>r本身不产生数据，他只处理图片的解码，所有把上层传来的<code>consumer</code>再包装一次，传给下面的生产者。例如在磁盘上找到了符合条件的图片，则会走消费这一条路，调用层层的<code>consumer</code>，例如到了<code>DecodeProducer</code>的<code>consumer</code>，会异步去解码，解码成功后再去调用上层的<code>Consumer</code>的<code>onNewResult</code>，内部会调用对应层的<code>onNewResultImpl</code>方法，例如<code>BitmapMemoryCacheProducer</code>中的<code>wrapConsumer</code>的<code>DelegatingConsumer</code>的<code>onNewResultImpl</code>，这里会在内存中缓存解码的图片了。然后再调用上层的<code>consumer</code>。最上层的<code>Consumer</code>是在<code>AbstractProducerToDataSourceAdapter</code>中<code>createConsumer</code>创建的。然后通过它的<code>setResult</code>方法通知所有的<code>dataSubscriber</code>，然后在主线程回调<code>dataSubscriber.onNewResult</code>，然后就是使用 <code>mSettableDraweeHierarchy.setImage</code>去给<code>mActualImageWrapper.setDrawable(drawable);</code>这就完成了图片的显示。<br>整个的producer的顺序是在<code>ProducerSequenceFactory::getDecodedImageProducerSequence</code>的方法里面确立的。</p>
<h3 id="Bitmap在内存的分配"><a href="#Bitmap在内存的分配" class="headerlink" title="Bitmap在内存的分配"></a>Bitmap在内存的分配</h3><p><a href="http://blog.csdn.net/chiefhsing/article/details/53899242" target="_blank" rel="external">谈谈fresco的bitmap内存分配</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/09/08/ReactNative是怎么在Android上跑起来的/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = '70kg-info';
var disqus_identifier = '2017/11/30/Fresco浅析/';
var disqus_title = 'Fresco浅析';
var disqus_url = 'http://yoursite.com/2017/11/30/Fresco浅析/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//70kg-info.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">70kg</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-81769413-1",'auto');ga('send','pageview');</script></body></html>