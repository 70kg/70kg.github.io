<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ReactNative是怎么在Android上跑起来的 · 70kg</title><meta name="description" content="ReactNative是怎么在Android上跑起来的 - 70kg"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="70kg"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/应聘Android开发工程师_王鹏.pdf" target="_self" class="nav-list-link">RESUME</a></li><li class="nav-list-item"><a href="/book/" target="_self" class="nav-list-link">BOOKS</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ReactNative是怎么在Android上跑起来的</h1><div class="post-info">Sep 8, 2017</div><div class="post-content"><p>(源码版本：0.34，新版本(0.48)基本流程是不变的，建议跟着源码看看，哪个版本的倒影响不大)<br>这篇简单刨析一下<code>React Native</code>是怎么在<code>Android</code>上跑起来的，会从下面几个方面说说。<a id="more"></a></p>
<ul>
<li>启动流程</li>
<li>通信机制</li>
<li>事件驱动  </li>
<li>渲染原理 </li>
<li>脚本执行 </li>
</ul>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p><code>React Native</code>在<code>Android</code>上启动是从<code>ReactRootView.startReactApplication</code>触发的，而<code>ReactRootView</code>是继承<code>FrameLayout</code>的，所以<code>React Native</code>在<code>Android</code>的操作都是在这个<code>View</code>中进行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startReactApplication(ReactInstanceManager reactInstanceManager, String moduleName, <span class="meta">@Nullable</span> Bundle launchOptions)</div></pre></td></tr></table></figure>
<p>这个方法参数第一个<code>ReactInstanceManager</code>，实现是<code>XReactInstanceManagerImpl</code>，可以理解在应用层对<code>RN</code>的配置都是对这个类操作实现的。<code>moduleName</code>是要启动的<code>RN</code>的<code>Component</code>的<code>name</code>,是在<code>js</code>的<code>AppRegistry.registerComponent(&#39;xxx&#39;, () =&gt; App);</code>定义的。最后的<code>launchOptions</code>是传过去的参数，可以在<code>js</code>的<code>Component</code>的<code>props</code>中获取。</p>
<p>下一步到了<code>mReactInstanceManager.createReactContextInBackground();</code>是在后台线程中创建<code>RN</code>的<code>ReactContext</code>上下文对象，然后到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JavaScriptExecutor 默认就是jsc,如果的debug在chrome上时候，就是v8。</span></div><div class="line"><span class="comment">//JSBundleLoader 有AssetLoader FileLoader CachedBundleFromNetworkLoader RemoteDebuggerBundleLoader 从不同的地方加载bundle</span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recreateReactContextInBackground</span><span class="params">(</span></span></div><div class="line">      JavaScriptExecutor.Factory jsExecutorFactory,</div><div class="line">      JSBundleLoader jsBundleLoader) &#123;</div><div class="line">    UiThreadUtil.assertOnUiThread();</div><div class="line"></div><div class="line">    ReactContextInitParams initParams =</div><div class="line">        <span class="keyword">new</span> ReactContextInitParams(jsExecutorFactory, jsBundleLoader);</div><div class="line">    <span class="keyword">if</span> (mReactContextInitAsyncTask == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// No background task to create react context is currently running, create and execute one.</span></div><div class="line">      mReactContextInitAsyncTask = <span class="keyword">new</span> ReactContextInitAsyncTask();</div><div class="line">      mReactContextInitAsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, initParams);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// Background task is currently running, queue up most recent init params to recreate context</span></div><div class="line">      <span class="comment">// once task completes.</span></div><div class="line">      mPendingReactContextInitParams = initParams;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>主要的创建工作就转移到了<code>ReactContextInitAsyncTask</code>这个<code>AsyncTask</code>里面，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> Result&lt;ReactApplicationContext&gt; <span class="title">doInBackground</span><span class="params">(ReactContextInitParams... params)</span> </span>&#123;</div><div class="line">     ....</div><div class="line">      <span class="keyword">return</span> Result.of(createReactContext(jsExecutor, params[<span class="number">0</span>].getJsBundleLoader()));</div><div class="line">     ....</div><div class="line">   &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> ReactApplicationContext <span class="title">createReactContext</span><span class="params">(</span></span></div><div class="line">     JavaScriptExecutor jsExecutor,</div><div class="line">     JSBundleLoader jsBundleLoader) &#123;</div><div class="line">   ...</div><div class="line">    NativeModuleRegistry.Builder nativeRegistryBuilder = <span class="keyword">new</span> NativeModuleRegistry.Builder();<span class="comment">//NativeModule的注册表</span></div><div class="line">   JavaScriptModuleRegistry.Builder jsModulesBuilder = <span class="keyword">new</span> JavaScriptModuleRegistry.Builder();<span class="comment">//jsModules的注册表</span></div><div class="line">   ...打包定义的各种modules到上面的注册表...</div><div class="line">   </div><div class="line">       <span class="comment">//创建关键的CatalystInstanceImpl</span></div><div class="line">       CatalystInstanceImpl.Builder catalystInstanceBuilder = <span class="keyword">new</span> CatalystInstanceImpl.Builder()</div><div class="line">       ...</div><div class="line">       catalystInstance = catalystInstanceBuilder.build();</div><div class="line">   ....</div><div class="line">   <span class="comment">//扔到js线程中加载js脚本</span></div><div class="line">   catalystInstance.getReactQueueConfiguration().getJSQueueThread().callOnQueue(</div><div class="line">       <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">           <span class="comment">//让reactContext持有catalystInstance</span></div><div class="line">           reactContext.initializeWithInstance(catalystInstance);</div><div class="line">           ...</div><div class="line">           catalystInstance.runJSBundle();</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">         &#125;</div><div class="line">       &#125;).get();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在<code>CatalystInstanceImpl</code>的构造函数中有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">//native C++方法，用来初始化JNI相关状态然后返回mHybridData。具体在 OnLoad.cpp 的 JSCJavaScriptExecutorHolder 类中</span></div><div class="line">mHybridData = initHybrid();</div><div class="line">...</div><div class="line"><span class="comment">//初始化线程环境，包括和主线程绑定，JS线程，Native线程创建。</span></div><div class="line">mReactQueueConfiguration = ReactQueueConfigurationImpl.create(</div><div class="line">        ReactQueueConfigurationSpec,</div><div class="line">        <span class="keyword">new</span> NativeExceptionHandler());</div><div class="line">...</div><div class="line">initializeBridge(</div><div class="line">      <span class="keyword">new</span> BridgeCallback(<span class="keyword">this</span>),<span class="comment">//CatalystInstanceImpl内部类，用于native对java的一些回调</span></div><div class="line">      jsExecutor,<span class="comment">//jsc</span></div><div class="line">      mReactQueueConfiguration.getJSQueueThread(),<span class="comment">//js线程队列</span></div><div class="line">      mReactQueueConfiguration.getNativeModulesQueueThread(),<span class="comment">//native线程队列</span></div><div class="line">      mJavaRegistry.getModuleRegistryHolder(<span class="keyword">this</span>));<span class="comment">//nativemodules注册表</span></div><div class="line">    mMainExecutorToken = getMainExecutorToken();<span class="comment">//貌似是用于切换jsExecutor的标记，后面版本删掉了。</span></div></pre></td></tr></table></figure>
<p>然后就进入到了<code>cpp</code>层的<code>CatalystInstanceImpl.cpp</code>的<code>initializeBridge</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> CatalystInstanceImpl::initializeBridge(</div><div class="line">    jni::alias_ref&lt;ReactCallback::javaobject&gt; callback,</div><div class="line">    <span class="comment">// This executor is actually a factory holder.</span></div><div class="line">    JavaScriptExecutorHolder* jseh,</div><div class="line">    jni::alias_ref&lt;JavaMessageQueueThread::javaobject&gt; jsQueue,</div><div class="line">    jni::alias_ref&lt;JavaMessageQueueThread::javaobject&gt; moduleQueue,</div><div class="line">    ModuleRegistryHolder* mrh) &#123;</div><div class="line">    </div><div class="line">  instance_-&gt;initializeBridge(folly::make_unique&lt;JInstanceCallback&gt;(callback),</div><div class="line">                              jseh-&gt;getExecutorFactory(),</div><div class="line">                              folly::make_unique&lt;JMessageQueueThread&gt;(jsQueue),</div><div class="line">                              folly::make_unique&lt;JMessageQueueThread&gt;(moduleQueue),</div><div class="line">                              mrh-&gt;getModuleRegistry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后有委托给了<code>Instance.cpp</code>的<code>initializeBridge</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Instance::initializeBridge(</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;InstanceCallback&gt; callback,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;JSExecutorFactory&gt; jsef,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MessageQueueThread&gt; jsQueue,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MessageQueueThread&gt; nativeQueue,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ModuleRegistry&gt; moduleRegistry) &#123;</div><div class="line">  callback_ = <span class="built_in">std</span>::move(callback);</div><div class="line"></div><div class="line">  <span class="comment">//在js线程中包装nativeQueue和创建nativeToJsBridge_，后者在双向bridge起作用，不要仅仅看名字，内部还有一个JsToNativeBridge</span></div><div class="line">  jsQueue-&gt;runOnQueueSync(</div><div class="line">    [<span class="keyword">this</span>, &amp;jsef, moduleRegistry, jsQueue,</div><div class="line">     nativeQueue=folly::makeMoveWrapper(<span class="built_in">std</span>::move(nativeQueue))] () <span class="keyword">mutable</span> &#123;</div><div class="line">      nativeToJsBridge_ = folly::make_unique&lt;NativeToJsBridge&gt;(</div><div class="line">          jsef.get(), moduleRegistry, jsQueue, nativeQueue.move(), callback_);</div><div class="line">    &#125;);</div><div class="line">  CHECK(nativeToJsBridge_);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这就看没了，再回到上面的<code>catalystInstance.runJSBundle();</code>以<code>FileLoader</code>为例，最终走到<code>native void loadScriptFromFile(String fileName, String sourceURL);</code>进入<code>CatalystInstanceImpl.cpp</code>进而委托给<code>Instance.cpp</code>。预警。。下面是一大片的<code>cpp</code>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">void Instance::loadScriptFromFile(const std::string&amp; filename,</div><div class="line">                                  const std::string&amp; sourceURL) &#123;</div><div class="line">  ...检测文件合法性等...</div><div class="line">  loadScriptFromString(std::move(buf), sourceURL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Instance::loadScriptFromString(std::unique_ptr&lt;const JSBigString&gt; string,</div><div class="line">                                    std::string sourceURL) &#123;</div><div class="line">  callback_-&gt;incrementPendingJSCalls();//这个callback就是java层的CatalystInstanceImpl的BridgeCallback这个内部类。</div><div class="line">  ...</div><div class="line">  nativeToJsBridge_-&gt;loadApplicationScript(std::move(string), std::move(sourceURL));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void NativeToJsBridge::loadApplicationScript(std::unique_ptr&lt;const JSBigString&gt; script,</div><div class="line">                                             std::string sourceURL) &#123;</div><div class="line">  m_mainExecutor-&gt;loadApplicationScript(std::move(script), std::move(sourceURL));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void JSCExecutor::loadApplicationScript(std::unique_ptr&lt;const JSBigString&gt; script, std::string sourceURL) throw(JSException) &#123;</div><div class="line">    ...</div><div class="line">     //使用webkit JSC去真正解释执行Javascript了！</div><div class="line">     evaluateScript(m_context, jsScript, jsSourceURL);</div><div class="line">     //绑定桥，核心是通过getGlobalObject将JS与C++通过webkit JSC bind</div><div class="line">     bindBridge(); </div><div class="line">     flush();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">void JSCExecutor::bindBridge() throw(JSException) &#123;</div><div class="line">  ...下面都是通过jsc 获取js的一下属性，方法等...</div><div class="line">  auto global = Object::getGlobalObject(m_context);</div><div class="line">  auto batchedBridgeValue = global.getProperty(&quot;__fbBatchedBridge&quot;);</div><div class="line">...</div><div class="line">  auto batchedBridge = batchedBridgeValue.asObject();</div><div class="line">  m_callFunctionReturnFlushedQueueJS = batchedBridge.getProperty(&quot;callFunctionReturnFlushedQueue&quot;).asObject();</div><div class="line">  m_invokeCallbackAndReturnFlushedQueueJS = batchedBridge.getProperty(&quot;invokeCallbackAndReturnFlushedQueue&quot;).asObject();</div><div class="line">  //这个比较重要 获取MessageQueue.js的flushedQueue 下面就用到</div><div class="line">  m_flushedQueueJS = batchedBridge.getProperty(&quot;flushedQueue&quot;).asObject();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//这个下面js-&gt;native的时候还会提到</div><div class="line">void JSCExecutor::flush() &#123;</div><div class="line">  ...真的烦，绕来绕去  m_flushedQueueJS看上面</div><div class="line">  callNativeModules(m_flushedQueueJS-&gt;callAsFunction(&#123;&#125;));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void JSCExecutor::callNativeModules(Value&amp;&amp; value) &#123;</div><div class="line">    ...</div><div class="line">  try &#123;</div><div class="line">    auto calls = value.toJSONString();</div><div class="line">    //class JsToNativeBridge : public react::ExecutorDelegate</div><div class="line">    m_delegate-&gt;callNativeModules(*this, std::move(calls), true);</div><div class="line">  &#125; catch (...) &#123;</div><div class="line">   ...</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">  void callNativeModules(</div><div class="line">      JSExecutor&amp; executor, std::string callJSON, bool isEndOfBatch) override &#123;</div><div class="line">    ExecutorToken token = m_nativeToJs-&gt;getTokenForExecutor(executor);</div><div class="line">    m_nativeQueue-&gt;runOnQueue([this, token, callJSON=std::move(callJSON), isEndOfBatch] &#123;</div><div class="line">      for (auto&amp; call : react::parseMethodCalls(callJSON)) &#123;</div><div class="line">        //快完了  这个是ModuleRegistry.cpp 是在initializeBridge间接创建包装nativemodule的</div><div class="line">        m_registry-&gt;callNativeMethod(</div><div class="line">          token, call.moduleId, call.methodId, std::move(call.arguments), call.callId);</div><div class="line">      &#125;</div><div class="line">      if (isEndOfBatch) &#123;</div><div class="line">        //又见到了这个callback</div><div class="line">        m_callback-&gt;onBatchComplete();</div><div class="line">        m_callback-&gt;decrementPendingJSCalls();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">void ModuleRegistry::callNativeMethod(ExecutorToken token, unsigned int moduleId, unsigned int methodId,</div><div class="line">                                      folly::dynamic&amp;&amp; params, int callId) &#123;</div><div class="line"> ...</div><div class="line"></div><div class="line">  modules_[moduleId]-&gt;invoke(token, methodId, std::move(params));</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到最后一句就是要去调用<code>nativeModule</code>里面的方法了，具体在<code>ModuleRegistryHolder.cpp</code>的<code>JavaNativeModule</code>类和<code>NewJavaNativeModule</code>类，对应<code>Java</code>的<code>JavaModuleWrapper.java</code>，就是<code>jni</code>调用。</p>
<p>说到这里，现在只完成了<code>bridge</code>环境的初步搭建，把<code>jsbundle</code>扔到<code>jsc</code>里面，还没真正拉起<code>React Native</code>应用。还是回到上面那个<code>AsyncTask</code>的<code>onPostExecute</code>方法。看看执行完这么一大堆准备代码之后，是怎么拉起来整个应用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Result&lt;ReactApplicationContext&gt; result)</span> </span>&#123;</div><div class="line">      ....</div><div class="line">       setupReactContext(result.get());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupReactContext</span><span class="params">(ReactApplicationContext reactContext)</span> </span>&#123;</div><div class="line">    ...各种listener回调，通知birdge就绪，reactContext创建完成</div><div class="line">    <span class="keyword">for</span> (ReactRootView rootView : mAttachedRootViews) &#123;</div><div class="line">      attachMeasuredRootViewToInstance(rootView, catalystInstance);</div><div class="line">    &#125;</div><div class="line">    ...各种listener回调，通知birdge就绪，reactContext创建完成</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attachMeasuredRootViewToInstance</span><span class="params">(ReactRootView rootView,CatalystInstance catalystInstance)</span> </span>&#123;</div><div class="line">   ....</div><div class="line">    UIManagerModule uiManagerModule = catalystInstance.getNativeModule(UIManagerModule.class);</div><div class="line">    <span class="keyword">int</span> rootTag = uiManagerModule.addMeasuredRootView(rootView);</div><div class="line">    rootView.setRootViewTag(rootTag);</div><div class="line">    <span class="meta">@Nullable</span> Bundle launchOptions = rootView.getLaunchOptions();</div><div class="line">    WritableMap initialProps = Arguments.makeNativeMap(launchOptions);</div><div class="line">    String jsAppModuleName = rootView.getJSModuleName();</div><div class="line"></div><div class="line">    WritableNativeMap appParams = <span class="keyword">new</span> WritableNativeMap();</div><div class="line">    appParams.putDouble(<span class="string">"rootTag"</span>, rootTag);</div><div class="line">    appParams.putMap(<span class="string">"initialProps"</span>, initialProps);</div><div class="line">    <span class="comment">//真正拉起react native 的地方</span></div><div class="line">    catalystInstance.getJSModule(AppRegistry.class).runApplication(jsAppModuleName, appParams);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>再来详细说一下最后一句，（大量代码预警）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> &lt;T extends JavaScriptModule&gt; <span class="function">T <span class="title">getJSModule</span><span class="params">(ExecutorToken executorToken, Class&lt;T&gt; jsInterface)</span> </span>&#123;</div><div class="line">    <span class="comment">//进入JSModuleRegistry中</span></div><div class="line">    <span class="keyword">return</span> Assertions.assertNotNull(mJSModuleRegistry)</div><div class="line">        .getJavaScriptModule(<span class="keyword">this</span>, executorToken, jsInterface);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//JavaScriptModuleRegistry.java</span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T extends JavaScriptModule&gt; <span class="function">T <span class="title">getJavaScriptModule</span><span class="params">(</span></span></div><div class="line">    CatalystInstance instance,</div><div class="line">    ExecutorToken executorToken,</div><div class="line">    Class&lt;T&gt; moduleInterface) &#123;</div><div class="line">    HashMap&lt;Class&lt;? extends JavaScriptModule&gt;, JavaScriptModule&gt; instancesForContext =</div><div class="line">        mModuleInstances.get(executorToken);</div><div class="line">    <span class="keyword">if</span> (instancesForContext == <span class="keyword">null</span>) &#123;</div><div class="line">      instancesForContext = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">      <span class="comment">//缓存一下 方便后面再使用</span></div><div class="line">      mModuleInstances.put(executorToken, instancesForContext);</div><div class="line">    &#125;</div><div class="line">    JavaScriptModule <span class="keyword">module</span> = instancesForContext.get(moduleInterface);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">//命中缓存  直接返回</span></div><div class="line">      <span class="keyword">return</span> (T) <span class="keyword">module</span>;</div><div class="line">    &#125;</div><div class="line">    JavaScriptModuleRegistration registration =</div><div class="line">      ...</div><div class="line">      <span class="comment">//很明显 动态代理 重点关注JavaScriptModuleInvocationHandler的invoke方法</span></div><div class="line">    JavaScriptModule interfaceProxy = (JavaScriptModule) Proxy.newProxyInstance(</div><div class="line">        moduleInterface.getClassLoader(),</div><div class="line">        <span class="keyword">new</span> Class[]&#123;moduleInterface&#125;,</div><div class="line">        <span class="keyword">new</span> JavaScriptModuleInvocationHandler(executorToken, instance, registration));</div><div class="line">    instancesForContext.put(moduleInterface, interfaceProxy);</div><div class="line">    <span class="keyword">return</span> (T) interfaceProxy;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">      ....</div><div class="line">      <span class="comment">//又跑到了CatalystInstanceImpl.java中。。。然后又桥接到了CatalystInstanceImpl.cpp中，同样会调用instance的对应方法，直接看吧</span></div><div class="line">      mCatalystInstance.callFunction(</div><div class="line">        executorToken,</div><div class="line">        mModuleRegistration.getName(),</div><div class="line">        method.getName(),</div><div class="line">        jsArgs</div><div class="line">      );</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line"><span class="keyword">void</span> Instance::callJSFunction(ExecutorToken token, std::string&amp;&amp; <span class="keyword">module</span>, std::string&amp;&amp; method,</div><div class="line">                              folly::dynamic&amp;&amp; params) &#123;</div><div class="line">  callback_-&gt;incrementPendingJSCalls();<span class="comment">//这个回调不多说</span></div><div class="line">  <span class="comment">//....接着跟吧</span></div><div class="line">  nativeToJsBridge_-&gt;callFunction(token, std::move(<span class="keyword">module</span>), std::move(method), std::move(params));</div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">//又会进入executor-&gt;callFunction(module, method, arguments);</span></div><div class="line"><span class="keyword">void</span> JSCExecutor::callFunction(<span class="keyword">const</span> std::string&amp; moduleId, <span class="keyword">const</span> std::string&amp; methodId, <span class="keyword">const</span> folly::dynamic&amp; arguments) &#123;</div><div class="line">    ....</div><div class="line">  auto result = [&amp;] &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//被桥接到MessageQueue.js的callFunctionReturnFlushedQueue方法</span></div><div class="line">      <span class="keyword">return</span> m_callFunctionReturnFlushedQueueJS-&gt;callAsFunction(&#123;</div><div class="line">        Value(m_context, String::createExpectingAscii(moduleId)),</div><div class="line">        Value(m_context, String::createExpectingAscii(methodId)),</div><div class="line">        Value::fromDynamic(m_context, std::move(arguments))</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</div><div class="line">      std::throw_with_nested(</div><div class="line">        std::runtime_error(<span class="string">"Error calling function: "</span> + moduleId + <span class="string">":"</span> + methodId));</div><div class="line">    &#125;</div><div class="line">  &#125;();</div><div class="line">  <span class="comment">//顺便还会调用一下native的 这个会在后面再说一下</span></div><div class="line">  callNativeModules(std::move(result));</div><div class="line">&#125;</div><div class="line"></div><div class="line"> callFunctionReturnFlushedQueue(<span class="keyword">module</span>, method, args) &#123;</div><div class="line">        guard(() =&gt; &#123;</div><div class="line">            <span class="comment">//执行js的function</span></div><div class="line">            <span class="keyword">this</span>.__callFunction(<span class="keyword">module</span>, method, args);</div><div class="line">            <span class="keyword">this</span>.__callImmediates();</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//取出积攒在queue中的action返回给上面的，最终在java中执行</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.flushedQueue();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">__callFunction(<span class="keyword">module</span>: string, method: string, args: any) &#123;</div><div class="line">       ...</div><div class="line">       <span class="comment">//根据module名，方法名和参数执行js方法</span></div><div class="line">        <span class="keyword">const</span> result = moduleMethods[method].apply(moduleMethods, args);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//那什么时候把js的module注册到moduleMethods中呢</span></div><div class="line"><span class="comment">//AppRegistry.js</span></div><div class="line">BatchedBridge.registerCallableModule(</div><div class="line">  <span class="string">'AppRegistry'</span>,</div><div class="line">  AppRegistry</div><div class="line">);</div><div class="line"><span class="comment">//BatchedBridge是啥？</span></div><div class="line"><span class="keyword">const</span> BatchedBridge = <span class="keyword">new</span> MessageQueue(</div><div class="line">  () =&gt; global.__fbBatchedBridgeConfig,</div><div class="line">  serializeNativeParams</div><div class="line">);</div><div class="line">registerCallableModule(name, methods) &#123;</div><div class="line">        <span class="keyword">this</span>._callableModules[name] = methods;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里就执行了<code>AppRegistry.js</code>的的<code>runApplication</code>方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> runApplication: <span class="function"><span class="keyword">function</span>(<span class="params">appKey: string, appParameters: any</span>): <span class="title">void</span> </span>&#123;</div><div class="line">  ...</div><div class="line">   runnables[appKey].run(appParameters);</div><div class="line"> &#125;,</div><div class="line"> <span class="comment">//而runnables是在什么时候被添加的？？下面</span></div><div class="line"> </div><div class="line"> registerComponent: <span class="function"><span class="keyword">function</span>(<span class="params">appKey: string, getComponentFunc: ComponentProvider</span>): <span class="title">string</span> </span>&#123;</div><div class="line">   runnables[appKey] = &#123;</div><div class="line">     <span class="attr">run</span>: <span class="function">(<span class="params">appParameters</span>) =&gt;</span></div><div class="line">       renderApplication(getComponentFunc(), appParameters.initialProps, appParameters.rootTag)</div><div class="line">   &#125;;</div><div class="line">   <span class="keyword">return</span> appKey;</div><div class="line"> &#125;,</div><div class="line"><span class="comment">//而registerComponent什么时候被调用的就不用说了吧</span></div></pre></td></tr></table></figure></p>
<p>到此真正执行到了<code>js</code>脚本，开始执行<code>Component</code>的逻辑渲染，最终映射到<code>Native</code>的<code>View</code>上。后面会再详细说渲染的原理。同时会发现在 <code>JSCExecutor</code> 中每次 <code>Java</code> 调用 <code>JS</code> 之后会进行 <code>Java</code> 端的一个回调（从 <code>JS</code> 层的 <code>MessageQueue.js</code> 中获得累积的 <code>JS Call</code>）。</p>
<h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h3><p>上面关于<code>java</code>-&gt;<code>js</code>已经体现的差不多了，实质就是 <code>Java</code> 与 <code>JS</code> 端都准备好一个 <code>Module</code> 映射表，然后当 <code>Java</code> 端调用 <code>JS</code> 代码时 <code>Java</code> 端通过查表动态代理创建一个与 JS 对应的 <code>Module</code> 对象，当调用这个 <code>Module</code> 的方法时 Java 端通过动态代理的 <code>invoke</code> 方法触发 <code>C++</code> 层，层层调用后通过 <code>JSCExecutor</code> 执行 <code>JS</code> 端队列中的映射查表找到 <code>JS</code> 端方法进行调用；<code>js</code>-&gt;<code>java</code>的调用会在渲染原理里面提到。</p>
<p>简单画了个图</p>
<p><img src="http://static.zybuluo.com/70kg/6qeg0re0ogqfdlnz4aue4g0n/init.png" alt="init.png-257.4kB"></p>
<h3 id="渲染原理"><a href="#渲染原理" class="headerlink" title="渲染原理"></a>渲染原理</h3><p>现在以一个<code>Image</code>如何渲染到<code>Native</code>为例，说一下简单的流程。<br>当执行<code>js</code>的脚本时候，是不知道<code>nativeModule</code>的注册表的，因为<code>nativeModule</code>的注册表只保存在<code>java</code>和<code>cpp</code>端，并没有直接传递到<code>js</code>端。所有当执行到</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    Image,</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div></pre></td></tr></table></figure>
<p>这时候<code>js</code>并不知道<code>Image</code>是什么，然后看一下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">const ReactNative = &#123;</div><div class="line">    ...</div><div class="line">    get Image() &#123; return require(&apos;Image&apos;); &#125;,</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">...</div><div class="line">module.exports = ReactNative;</div><div class="line"></div><div class="line">//Image.android.js</div><div class="line"></div><div class="line">var NativeModules = require(&apos;NativeModules&apos;);</div><div class="line"></div><div class="line">//NativeModules.js</div><div class="line"></div><div class="line">const NativeModules = &#123;&#125;;</div><div class="line">Object.keys(RemoteModules).forEach((moduleName) =&gt; &#123;</div><div class="line">  Object.defineProperty(NativeModules, moduleName, &#123;</div><div class="line">    configurable: true,</div><div class="line">    enumerable: true,</div><div class="line">    get: () =&gt; &#123;</div><div class="line">      let module = RemoteModules[moduleName];</div><div class="line">      if (module &amp;&amp; typeof module.moduleID === &apos;number&apos; &amp;&amp; global.nativeRequireModuleConfig) &#123;</div><div class="line">      //nativeRequireModuleConfig映射到JSCExecutor.cpp</div><div class="line">        const config = global.nativeRequireModuleConfig(moduleName);</div><div class="line">        module = config &amp;&amp; BatchedBridge.processModuleConfig(config, module.moduleID);</div><div class="line">        RemoteModules[moduleName] = module;</div><div class="line">      &#125;</div><div class="line">      Object.defineProperty(NativeModules, moduleName, &#123;</div><div class="line">        configurable: true,</div><div class="line">        enumerable: true,</div><div class="line">        value: module,</div><div class="line">      &#125;);</div><div class="line">      return module;</div><div class="line">    &#125;,</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = NativeModules;</div><div class="line"></div><div class="line">//cpp</div><div class="line">JSCExecutor::nativeRequireModuleConfig-&gt;JsToNativeBridge::getModuleConfig-&gt;ModuleRegistry::getConfig</div><div class="line"></div><div class="line">folly::dynamic ModuleRegistry::getConfig(const std::string&amp; name) &#123;</div><div class="line"></div><div class="line">...</div><div class="line">  NativeModule* module = modules_[it-&gt;second].get();</div><div class="line">...</div><div class="line">  //最终反射调用JavaModuleWrapper.java的getConstants</div><div class="line">  folly::dynamic constants = module-&gt;getConstants();</div><div class="line">...</div><div class="line">  //最终反射调用JavaModuleWrapper.java的getMethods</div><div class="line">  //返回对应module中所有@ReactMethod注解的方法</div><div class="line">  std::vector&lt;MethodDescriptor&gt; methods = module-&gt;getMethods();</div><div class="line">  </div><div class="line">//modules_在哪赋值？</div><div class="line">//ModuleRegistryHolder.cpp构造函数,这个类上面有提到，回去看看</div><div class="line">//registry_ = std::make_shared&lt;ModuleRegistry&gt;(std::move(modules));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后返回到<code>NativeModules.js</code>中，<code>BatchedBridge.processModuleConfig</code><br>-&gt;<code>_genModule</code>-&gt;<code>_genMethod</code>。进一步处理一下。所以到现在，<code>js</code>获取到了<code>Image</code>这个<code>module</code>中所有方法和属性。</p>
<p>然后当调用<code>Image</code>中相关方法时候，其实就是调用上面<code>_genMethod</code>中的方法，在这个方法中，分<code>promise</code>，<code>sync</code>，<code>其他</code>调用类型，最终都是调用了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">__nativeCall(module, method, params, onFail, onSucc) &#123;</div><div class="line">...</div><div class="line">        this._queue[MODULE_IDS].push(module);</div><div class="line">        this._queue[METHOD_IDS].push(method);</div><div class="line">        this._queue[PARAMS].push(preparedParams);</div><div class="line">...</div><div class="line">//如果5ms内有多个方法调用就先待在队列里防止过高频率，否则调用C++的nativeFlushQueueImmediate方法</div><div class="line"> if (global.nativeFlushQueueImmediate &amp;&amp;</div><div class="line">        now - this._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS) &#123;</div><div class="line">      global.nativeFlushQueueImmediate(this._queue);</div><div class="line">      this._queue = [[], [], [], this._callID];</div><div class="line">      this._lastFlush = now;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面把<code>MODULE_IDS</code>，<code>METHOD_IDS</code>，<code>PARAMS</code>放到<code>queue</code>中，等待<code>java</code>的调用，至于什么时候会触发<code>java</code>的调用和为什么要这么设计，会在下面的事件驱动解释。调用<code>JSCExecutor::flush()</code>。还有就是直接调用<code>cpp</code>的<code>nativeFlushQueueImmediate</code>，最终这两种方式都是调用了<code>callNativeModules</code>，这个上面也说了，不再赘述啦。</p>
<p>下面再说一下<code>Native</code>的<code>view</code>创建过程，这个过程中<code>View</code>的<code>tag</code>起标记<code>View</code>的作用，从<code>java</code>拉起<code>React Native</code>的<code>attachMeasuredRootViewToInstance</code>方法中可以看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">appParams.putDouble(<span class="string">"rootTag"</span>, rootTag);</div><div class="line">appParams.putMap(<span class="string">"initialProps"</span>, initialProps);</div></pre></td></tr></table></figure>
<p>把<code>rootTag</code>通过<code>bridge</code>带到了<code>js</code>端，<code>js</code>执行<code>React</code>逻辑后，要创建一个<code>Native</code>的<code>View</code>,同时也把这个<code>rootTag</code>带到<code>java</code>层，让<code>java</code>层知道，创建完一个<code>View</code>要添加到哪个根布局上。</p>
<p>这个<code>rootTag</code>的生成是有规则的，在<code>UIManagerModule.addMeasuredRootView</code>的时候会生成<code>RootViewTag</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> tag = mNextRootViewTag;<span class="comment">//默认是1</span></div><div class="line">mNextRootViewTag += ROOT_VIEW_TAG_INCREMENT;<span class="comment">//10</span></div></pre></td></tr></table></figure>
<p>也就是默认的<code>rootTag</code>是1，后面每多创建一个+10,也就是类似<code>1，11，21</code>这样都是根布局的<code>tag</code>。</p>
<p>再通过这个<code>rootTag</code>在<code>js</code>的传递简单说一下<code>React.js</code>的创建组件逻辑。从前面可以知道，拉起<code>js</code>后执行<code>AppRegistry.js ::runApplication</code>，进而执行到了<code>renderApplication(getComponentFunc(), appParameters.initialProps, appParameters.rootTag)</code>这个方法。这里可以看到从<code>java</code>传过来的两个参数，其中一个就是<code>rootTag</code>，这里默认就一个根布局，这里的<code>rootTag==1</code>，进而到了<code>renderApplication.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ReactNative.render(</div><div class="line">   &lt;AppContainer&gt;</div><div class="line">     &lt;RootComponent</div><div class="line">       &#123;...initialProps&#125;</div><div class="line">       rootTag=&#123;rootTag&#125;</div><div class="line">     /&gt;</div><div class="line">   &lt;/AppContainer&gt;,</div><div class="line">   rootTag</div><div class="line"> );</div></pre></td></tr></table></figure>
<p>这里的<code>AppContainer</code>也是一个组件，是包裹在根布局的外面，用于<code>debug</code>的红盒等工具布局。再到了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ReactNative.js</span></div><div class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params">element, mountInto, callback</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> ReactNativeMount.renderComponent(element, mountInto, callback);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里面的逻辑快到<code>React</code>的一些处理，这里不多赘述，其实还有很多关于<code>React Native</code>的处理，暂时忽略，分支太多太繁琐。简单说一下<code>React Native</code>组件可以分为两种</p>
<blockquote>
<p>元组件：框架内置的，可以直接使用的组件。例如：View、Image等。它在React Native中用ReactNativeBaseComponent来描述。<br>复合组件：用户封装的组件，一般可以通过React.createClass()来构建，提供render()方法来返回渲染目标。它在React Native中用ReactCompositeComponent来描述。</p>
</blockquote>
<p>具体组合的逻辑基本都在上面连个类里面。下面来到<code>ReactNativeBaseComponent.js</code>的<code>mountComponent</code>，根据上面的提示是可以跟到这里的。只挑简单的看，看这个方法里面的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var tag = ReactNativeTagHandles.allocateTag();<span class="comment">//给每个view生成一个唯一的tag</span></div><div class="line">...</div><div class="line">UIManager.createView(tag, <span class="keyword">this</span>.viewConfig.uiViewClassName, nativeTopRootTag, updatePayload);</div><div class="line"></div><div class="line"><span class="comment">//ReactNativeTagHandles.js</span></div><div class="line">allocateTag: function () &#123;</div><div class="line">    <span class="comment">//排除已经给分配给rootTag的  类似1，11，21</span></div><div class="line">    <span class="comment">//下面的就是简单的自增，初始化是1</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.reactTagIsNativeTopRootID(ReactNativeTagHandles.tagCount)) &#123;</div><div class="line">      ReactNativeTagHandles.tagCount++;</div><div class="line">    &#125;</div><div class="line">    var tag = ReactNativeTagHandles.tagCount;</div><div class="line">    ReactNativeTagHandles.tagCount++;</div><div class="line">    <span class="keyword">return</span> tag;</div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
<p>看名字也知道这里就到了创建<code>View</code>的地方，还有另外两个方法和这个差不多的，用来操作<code>View</code>,分别的<code>updateView</code>，<code>manageChildren</code>，<code>UIManager</code>通过<code>bridge</code>可以映射到<code>java</code>的<code>UIManagerModule.java</code>，可以在duiyiing这个类里面找到对应的用<code>@ReactMethod</code>注解的方法，这个注解是干啥的，看上面有提到。这里只看<code>createView</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ReactMethod</span></div><div class="line"> <span class="comment">//创建view的tag,对应native的组件类名，要加入的根布局tag,创建view需要的参数</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createView</span><span class="params">(<span class="keyword">int</span> tag, String className, <span class="keyword">int</span> rootViewTag, ReadableMap props)</span> </span>&#123;</div><div class="line">   mUIImplementation.createView(tag, className, rootViewTag, props);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在<code>UIImplementation.java</code>中把要创建的<code>view</code>包装成<code>CSSNode</code>，用于后面的在<code>CssLayout</code>中布局。然后会包装成一个<code>CreateViewOperation</code>加入到<code>UIViewOperationQueue.java</code>的<code>ArrayDeque&lt;UIOperation&gt; mNonBatchedOperations</code>这个队列中。最后还是通过<code>GuardedChoreographerFrameCallback</code>这个垂直同步的回调中出队，执行。关于事件驱动还是看下面。还有 <code>updateview</code> <code>setchilderen</code>就不说了，很复杂。</p>
<h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>在说<code>React Native</code>的事件驱动之前，先看一下这几篇<br><a href="http://www.jianshu.com/p/424918260fa9" target="_blank" rel="external">Android图形显示系统（一）</a><br><a href="http://www.jianshu.com/p/154c4fb85641" target="_blank" rel="external">React Native 分析（二）事件驱动</a><br><a href="http://www.jianshu.com/p/c046fcd125d2" target="_blank" rel="external">Android中的SurfaceFlinger和Choreographer</a><br>了解一下垂直同步和在<code>Android</code>上的<code>Choreographer</code>，正因为<code>React Native</code>使用了<code>Choreographer</code>这个类，而这个类是在4.1加入的，所以<code>RN-Android</code>的最低兼容是4.1，而<code>weex</code>是最低兼容到4.0，是在4.0使用了<code>handler</code>延时来模拟垂直同步的效果。当然这也是老版本<code>Android</code>的做法。这也是为啥总是吐槽<code>Android</code>显得很卡，当然在5.0又引入了<code>renderThread</code>就更上了一个台阶，还有<code>Android</code>的属性动画也是靠这个驱动的。</p>
<p>下面简单贴一下<code>Choreographer</code>的注释，看看为啥跨平台的框架都会用到这个类</p>
<blockquote>
<p>However, there are a few cases where you might want to use the functions of thechoreographer directly in your application.  Here are some examples.<br> <li>If your application does its rendering in a different thread, possibly using GL,or does not use the animation framework or view hierarchy at all and you want to ensure that it is appropriately synchronized with the display, then use<br> {@link Choreographer#postFrameCallback}.</li><br> <li>… and that’s about it.</li><br> Each {@link Looper} thread has its own choreographer.  Other threads can post callbacks to run on the choreographer but they will run on the {@link Looper}to which the choreographer belongs.</p>
</blockquote>
<p>再看一下<code>postFrameCallback</code>注释</p>
<blockquote>
<p>Posts a frame callback to run on the next frame.The callback runs once then is automatically removed.</p>
</blockquote>
<p>在<code>React Native</code>的使用主要在<code>EventDispatcher</code>的内部类<code>private class ScheduleDispatchFrameCallback implements Choreographer.FrameCallback</code>和<code>ReactChoreographer</code>与它的内部类<code>private class ReactChoreographerDispatcher implements Choreographer.FrameCallback</code>，还有用于<code>view</code>或者动画的就不说了。</p>
<p>现在举个例子，点击一下<code>view</code>，这个事件是怎么传递的，点击事件肯定发生在<code>java</code>端。在<code>ReactRootView</code>的<code>dispatchJSTouchEvent</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">  EventDispatcher eventDispatcher = reactContext.getNativeModule(UIManagerModule.class)</div><div class="line">      .getEventDispatcher();</div><div class="line">    mJSTouchDispatcher.handleTouchEvent(event, eventDispatcher);</div><div class="line">    </div><div class="line">//JSTouchDispatcher.java</div><div class="line">  public void handleTouchEvent(MotionEvent ev, EventDispatcher eventDispatcher) &#123;</div><div class="line">    //这里面分为down,up move 等事件类别</div><div class="line">    </div><div class="line">     mTargetTag = TouchTargetHelper.findTargetTagAndCoordinatesForTouch(</div><div class="line">        ev.getX(),</div><div class="line">        ev.getY(),</div><div class="line">        mRootViewGroup,</div><div class="line">        mTargetCoordinates,</div><div class="line">        null);</div><div class="line">      eventDispatcher.dispatchEvent(</div><div class="line">        TouchEvent.obtain(</div><div class="line">          mTargetTag,</div><div class="line">          TouchEventType.START,</div><div class="line">          ev,</div><div class="line">          mGestureStartTime,</div><div class="line">          mTargetCoordinates[0],</div><div class="line">          mTargetCoordinates[1],</div><div class="line">          mTouchEventCoalescingKeyHelper));</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终包装成一个<code>TouchEvent</code>调用<code>eventDispatcher.dispatchEvent</code>,这里面主要是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mEventStaging.add(event);<span class="comment">//ArrayList&lt;Event&gt;</span></div></pre></td></tr></table></figure>
<p>把事件添加到一个待发送的列表里面。那什么是去处发送？是在<code>ScheduleDispatchFrameCallback.doFrame</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">  ....</div><div class="line">    moveStagedEventsToDispatchQueue();</div><div class="line">  ...</div><div class="line">     mReactContext.runOnJSQueueThread(mDispatchEventsRunnable);</div><div class="line">  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用<code>moveStagedEventsToDispatchQueue</code>在这个方法里面会对<code>event</code>再做一些处理，例如压缩，合并事件等，然后又把处理完的事件放到<code>Event[] mEventsToDispatch = new Event[16];</code>中。而在<code>DispatchEventsRunnable</code>的<code>run</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> eventIdx = <span class="number">0</span>; eventIdx &lt; mEventsToDispatchSize; eventIdx++) &#123;</div><div class="line">            Event event = mEventsToDispatch[eventIdx];</div><div class="line">            ....</div><div class="line">            event.dispatch(mRCTEventEmitter);</div><div class="line">            event.dispose();</div><div class="line">            ...</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">-&gt;TouchEvent.dispatch-&gt;TouchesHelper.sendTouchEvent-&gt;rctEventEmitter.receiveTouches(</div><div class="line">        type.getJSEventName(),</div><div class="line">        pointers,</div><div class="line">        changedIndices);</div></pre></td></tr></table></figure>
<p>而<code>RCTEventEmitter extends JavaScriptModule</code>这个就是走上面的<code>java-&gt;js</code>的路子，动态代理-&gt;<code>cpp</code>-&gt;<code>flush()</code>-&gt;….</p>
<p>简单点就是<code>getJSModule</code>后对js的方法调用都会触发上面<code>MessageQueue.js</code>的出队</p>
<p><img src="http://static.zybuluo.com/70kg/hlcsema382uuczmwj9eefc12/eventloop.png" alt="eventloop.png-102.7kB"></p>
<h2 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h2><p>这里简单说说<code>React Native</code>的<code>js引擎</code>选择，都是<code>webkit</code>的<code>JSC</code>,在<code>iOS</code>上是内置的，在<code>Android</code>上则是引入了一个完整的<code>JSC</code>，这也是为什么<code>Android</code>的<code>RN</code>会大这么多的很重要的原因，至于为什么要引入一个完整的<code>JSC</code>而不是使用内置的<code>js</code>引擎，<code>Android 4.4</code>之前的<code>android</code>系统浏览器内核是<code>WebKit</code>，<code>Android4.4</code>系统浏览器切换到了<code>Chromium</code>(内核是<code>Webkit</code>的分支<code>Blink</code>)。在<code>Android</code>平台已经启用V8作为JS引擎，<code>Android 4.0</code>以后只用到了<code>JavaScriptCore</code>中的WTF（Web Template Library）部分代码。</p>
<p>至于为啥不都使用<code>V8</code>,这个都是<code>iOS</code>的锅，看看<code>chrome</code>在<code>iOS</code>上就是个<code>WebView</code>套个壳。。。</p>
<p>还有其他的跨平台框架，例如<code>weex</code>,在<code>Android</code>上使用的是<code>V8</code>。现在网上也有对<code>RN</code>在<code>Android</code>上移植的<code>V8</code>版本。<br><a href="http://static.zybuluo.com/70kg/lhmhcf6qb5grtdt1wzi1imcp/React%20Native%E5%90%AF%E5%8A%A8%20%281%29.png" target="_blank" rel="external">onesubone/react-native-android-v8</a><br><a href="http://tsinstudio.github.io/media/React-Native-Meets-V8/" target="_blank" rel="external">React Native Android V8接入</a><br>这个是基于0.46的版本，还是可以跑起来的，但是<code>RN</code>的速度瓶颈貌似并不在<code>js引擎</code>。。</p>
<p>最后再贴一下简单画的思维导图吧</p>
<p><a href="https://www.processon.com/view/link/599c14b8e4b0f2c6342a4f04" target="_blank" rel="external">思维导图</a></p>
<p>参考：</p>
<p><a href="https://github.com/facebook/react-native" target="_blank" rel="external">facebook/react-native</a><br><a href="http://blog.csdn.net/yanbober/article/details/53157456" target="_blank" rel="external"> React Native Android 源码框架浅析（主流程及 Java 与 JS 双边通信）</a><br><a href="https://github.com/guoxiaoxing/react-native" target="_blank" rel="external">ReactNative源码篇</a><br><a href="http://www.jianshu.com/u/640de10b6744" target="_blank" rel="external">吟游雪人</a></p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps:"></a>ps:</h2><p>因为本人能力实在有限，上面很多都是连蒙带猜，算是个笔记性质的流水账，有用就看看，没用就算了,欢迎指出错误。</p>
<h3 id="pps"><a href="#pps" class="headerlink" title="pps"></a>pps</h3><p>这篇本该在两星期之前完成的工作，一直拖到了现在。(<del>一是因为懒</del>)，二是因为不知道该怎么更好的表述出来，因为一直贴代码体验实在是不好。（<del>虽然现在还是这样的，但是源码分析的不贴代码怎么写</del>）。但是感觉再不写点出来，过段时间又忘了，索性写出来算了，也不管效果了。。。凑合看吧。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/09/08/Fragment启动生命周期/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = '70kg-info';
var disqus_identifier = '2017/09/08/ReactNative是怎么在Android上跑起来的/';
var disqus_title = 'ReactNative是怎么在Android上跑起来的';
var disqus_url = 'http://yoursite.com/2017/09/08/ReactNative是怎么在Android上跑起来的/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//70kg-info.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">70kg</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-81769413-1",'auto');ga('send','pageview');</script></body></html>