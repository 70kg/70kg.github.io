<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android Binder 浅析 · 70kg</title><meta name="description" content="Android Binder 浅析 - 70kg"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="70kg"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/2790907881/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/70kg" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android Binder 浅析</h1><div class="post-info">Jul 9, 2016</div><div class="post-content"><p>##开头废话<br>先说一下为什么要写这篇博客吧，起源于我对主席的书进行二周目的时候，看到了第二章IPC，然后去试着手写了一遍AIDL,再然后就有点困惑这里面是啥玩意，再然后就发现这里面的坑有点大了。。从<code>AIDL</code>到<code>Binder</code>，然后看到了Android系统里面那么多的binder使用，又去翻了一点<code>activity</code>的启动，从中又看到了<code>Binder</code>在进程间通讯的影子，从<code>AMS</code>到<code>activityThread</code>的通信等等。我觉得是很有必要写一些我的认识，可能还是有些云里雾里的，就当了解吧。<a id="more"></a></p>
<p>###从AIDL开始<br>先说一下平时写AIDL都是怎么写的，用主席的那个例子</p>
<ol>
<li>定义一个可序列化的实体类<br>这个就不多说了，这里选择实现<code>Parcelable</code>接口来进行序列化，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">package com.demos.aidl;</div><div class="line">public class Book implements Parcelable &#123;</div><div class="line">    public int bookId;</div><div class="line">    public String bookName;</div><div class="line">    ....</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个类有两个字段，明白意思就好了。</p>
<p>2.定义<code>Book</code>的aidl文件<br>虽然是在同一个包里面，但是还是要去声明一个这样的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">package com.demos.aidl;</div><div class="line">parcelable Book;</div></pre></td></tr></table></figure>
<p> 3.定义AIDL接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">package com.demos.aidl;</div><div class="line">import com.demos.aidl.Book;</div><div class="line">interface IBookManager &#123;</div><div class="line">     List&lt;Book&gt; getBookList();</div><div class="line">     void addBook(in Book book);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里注意<code>import</code>Book进来，虽然是一个包里面的。</p>
<p> 4.build一下，然后在<code>build/generated/source/aidl/debug/com.demos.aidl</code>x里面就有了个<code>IBookManager</code>这么一个JAVA文件了。这就是系统帮助我们生成的。<br> 5.使用</p>
<p> 在<code>client</code>端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private ServiceConnection mConnection = new ServiceConnection() &#123;</div><div class="line">      public void onServiceConnected(ComponentName className, IBinder service) &#123;</div><div class="line">          IBookManager bookManager = IBookManager.Stub.asInterface(service);</div><div class="line">           List&lt;Book&gt; list = bookManager.getBookList();</div><div class="line">           .....</div><div class="line">          &#125;</div><div class="line">Intent intent = new Intent(this, BookManagerService.class);</div><div class="line">      bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div></pre></td></tr></table></figure></p>
<p>然后在<code>Server</code>端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private Binder mBinder = new IBookManager.Stub() &#123;</div><div class="line">        @Override</div><div class="line">        public List&lt;Book&gt; getBookList() throws RemoteException &#123;</div><div class="line">            return mBookList;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void addBook(Book book) throws RemoteException &#123;</div><div class="line">            mBookList.add(book);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这样就基本是一个很简单的进程间通信了。前面是系统给我们自动生成的一个<code>IBookManager</code>接口，这个接口里面都是些什么东西呢。进去看看的话，刚开始看不出什么东西，(因为它的排版很烂啊)，下面来排个版简单的分析一下这东西。</p>
<p>###分析aidl生成接口<br>首先它是一个接口<code>public interface IBookManager extends android.os.IInterface</code>，要去进行进程间通信，都要去遵循<code>IInterface</code>这个接口，然后里面还有一个很重要的类<code>public static abstract class Stub extends android.os.Binder implements com.demos.aidl.IBookManager</code>这个内部类继承自<code>Binder</code>还实现了我们定义的aidl接口。回过头看在客户端是怎么获得<code>IBookManager</code>的？<code>IBookManager.Stub.asInterface(service);</code>下面就是实现的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static com.demos.aidl.IBookManager asInterface(android.os.IBinder obj)</div><div class="line">&#123;</div><div class="line">    if ((obj==null)) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">    if (((iin!=null)&amp;&amp;(iin instanceof com.demos.aidl.IBookManager))) &#123;</div><div class="line">        //如果客户端和服务端在同一个进程，就直接返回服务端的IBookManager，不用跨进程调用了</div><div class="line">        return ((com.demos.aidl.IBookManager)iin);</div><div class="line">    &#125;   //否则返回的是一个代理类</div><div class="line">    return new com.demos.aidl.IBookManager.Stub.Proxy(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面去看看这个代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//这个是运行在客户端进程</div><div class="line">private static class Proxy implements com.demos.aidl.IBookManager</div><div class="line">&#123;   //远程的IBinder对象</div><div class="line">    private android.os.IBinder mRemote;</div><div class="line">    Proxy(android.os.IBinder remote)&#123;</div><div class="line">        mRemote = remote;</div><div class="line">    &#125;</div><div class="line">   .....</div><div class="line">@Override public java.util.List&lt;com.demos.aidl.Book&gt; getBookList() throws android.os.RemoteException</div><div class="line">&#123;</div><div class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">    java.util.List&lt;com.demos.aidl.Book&gt; _result;</div><div class="line">    try &#123;</div><div class="line">        _data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">        //这个是把参数等信息传递给远程的IBinder</div><div class="line">        mRemote.transact(Stub.TRANSACTION_getBookList,_data, _reply, 0);</div><div class="line">        _reply.readException();</div><div class="line">        _result = _reply.createTypedArrayList(com.demos.aidl.Book.CREATOR);</div><div class="line">    &#125;</div><div class="line">    finally &#123;</div><div class="line">    _reply.recycle();</div><div class="line">    _data.recycle();</div><div class="line">    &#125;</div><div class="line">return _result;</div><div class="line">&#125;</div><div class="line">.....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这个东西什么正事没干，就是把参数什么的传递给远程真正干活的，真正干活的在哪？还是在前面的那个<code>Stub</code>类里面，有一个<code>onTransact</code>方法，参数和上面的<code>mRemote.transact</code>方法的参数相对应，看一下吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//这个是运行在服务端进程</div><div class="line">@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException</div><div class="line">&#123;   //根据code来进行判断执行哪个方法</div><div class="line">    switch (code)&#123;</div><div class="line">        case INTERFACE_TRANSACTION:&#123;</div><div class="line">            reply.writeString(DESCRIPTOR);</div><div class="line">            return true;</div><div class="line">    &#125;</div><div class="line">        case TRANSACTION_getBookList:&#123;</div><div class="line">            data.enforceInterface(DESCRIPTOR);</div><div class="line">            //调用了getBookList方法，这个方法是要自己在service里面去实现的</div><div class="line">            java.util.List&lt;com.demos.aidl.Book&gt; _result =               this.getBookList();</div><div class="line">            reply.writeNoException();</div><div class="line">            reply.writeTypedList(_result);</div><div class="line">            return true;</div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">    return super.onTransact(code, data, reply, flags);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样基本上就大概理清楚了，手写<code>AIDL</code>就不写了，写出来基本上是一样的。</p>
<p>##概述多进程<br>在Android中，打开一个APP可以认为是开启了一个进程，当然四大组件也可以再开新的进程，不同的进程之间是不同的虚拟机，所以可以认识他们互相不知道对方的存在，也就没法去直接的交流。那么如果想要跨进程通信，其实有很多的办法，比如管道，System V，Socket等，那么Android为什么还要去自己搞一个binder呢，既然自己费那么大劲搞了一个，肯定有无可比拟的优势，这里我只知道由于性能和安全的考虑，它就选择了binder😂。</p>
<p>###binder基本模型<br>既然两个进程之间无法直接通信，那么怎么办。在Linux中，内核是可以获取两个进程的全部信息的，那么就好办了，把进程a想说的话告诉内核，内核再告诉b就好了。。。其实实现起来还是很复杂的。好吧，正经点说，首先系统有一个<code>ServiceManager</code>的进程，简称SM,这个是负责管理<code>Service</code>的，当一个<code>Server</code>建立的时候，会去和SM通信，在SM里面进行注册，比如我是张三，我的地址是0x12138。当<code>Client</code>想要和<code>Server</code>进行通信的时候，先去询问SM,我怎么联系张三，SM告诉它这个号码，然后就去联系了。其实还是有点不恰当，，大概就这么理解吧。这里注意到，SM其实也是一个进程，一个<code>Server</code>想要和它进行通信就涉及到了跨进程通信的问题，这就成了鸡-蛋的问题，其实这两者之间也是使用了<code>Binder</code>,不过系统给我们预先造了一个”鸡”,和普通的跨进程通信还不太一样，这里理解就好。</p>
<p>###Binder跨进程原理<br>这里还是简单的说，因为我也不是特别的理解。就拿上面举的那个book的例子开始说，可以看到<code>Stub</code>是继承自<code>Binder</code>并且实现了<code>IBookManager</code>接口，而<code>Binder</code>是实现了<code>IBinder</code>接口，其实在<code>Binder</code>里面有一个内部类<code>BinderProxy</code>，它也是实现了<code>IBinder</code>接口。这样在来看在<code>Client</code>里面的使用，<code>public void onServiceConnected(ComponentName className, IBinder service)</code>这里的<code>service</code>是<code>sub</code>呢还是<code>BinderProxy</code>呢，在前面说了，如果是在同一个进程，就返回<code>Server</code>里面的<code>Binder</code>本体，否在就返回一个<code>BinderProxy</code>对象，在<code>asInterface(android.os.IBinder obj)</code>这个<code>obj</code>如果是跨进程的，肯定是一个<code>BinderProxy</code>对象了，然后就去调用这个对象的<code>transact</code>方法，把需要调用方法的code，数据，返回值，还有一个是不是双向RPC的flag位传进去，我们看一下在<code>BinderProxy</code>里面，这个方法是怎么实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</div><div class="line">       Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</div><div class="line">       return transactNative(code, data, reply, flags);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看到是调用了<code>Native</code>的方法，后面就是一些cpp的东西，我也看不太懂，也就是进去了<code>Binder</code>驱动里面去折腾东西，然后<code>Binder</code>驱动把那些参数什么的给<code>Server</code>的<code>onTransact</code>方法，然后在根据code去调用<code>Server</code>中重写的<code>IBookManager</code>中的方法。然后在<code>onTransact</code>方法中最后再把写好的返回参数在返回给<code>Binder</code>驱动，可以在最后看到<code>return super.onTransact(code, data, reply, flags);</code>，再然后就是<code>Binder</code>驱动把结果告诉等待的<code>Client</code>端。这样就基本完成了一次跨进程通信。</p>
<p>这里稍微总结一下，可以看到，无论是<code>sub</code>还是<code>BinderProxy</code>都是实现了<code>IBinder</code>接口，以至于客户端根本无法分辨出是不是在进行跨进程通信，也就是说<code>Client</code>看起来就和同进程的<code>Server</code>进行通信一样，只需要轻轻松松的调用<code>getBookList</code>就能获得想要的结果，也不用去在乎<code>Server</code>是在什么地方，底层了一切<code>Binder</code>驱动都给我们封装好了。还有就是在跨进程通信的时候，并没有把方法传过去，仅仅是传递了一个方法的code,然后在<code>Server</code>中根据这个code来调用对应的方法.</p>
<p>###在Android中的提现<br>在Android的源码中，使用<code>Binder</code>来进行进程间通讯也是很常见的，来看一个关于启动<code>activity</code>的东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class ActivityManagerProxy implements IActivityManager&#123;&#125;</div><div class="line"></div><div class="line">public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123;&#125;</div><div class="line"></div><div class="line">public final class ActivityManagerService extends ActivityManagerNative&#123;&#125;</div></pre></td></tr></table></figure>
<p>这个三个类的继承实现关系是不是有点眼熟，对，就和前面写的那个book例子一样的，<code>ActivityManagerProxy</code>就相当于那个内部类<code>Proxy</code>，<code>ActivityManagerNative</code>就相当于里面的<code>Stub</code>，而实现类<code>ActivityManagerService</code>简称AMS就是<code>Server</code>了。在细说一下，在执行<code>startActivity</code>的时候，会到<code>mInstrumentation.execStartActivity()</code>，就是凯子哥说的那个老板娘😂，然后就是<code>ActivityManagerNative.getDefault().startActivity</code>，这里<code>getDefault</code>返回一个<code>IActivityManager</code>对象，就是使用<code>asInterface(IBinder obj)</code>获得的，是不是更熟悉了，就是前面判断是不是同一个进程的地方，这里肯定是跨进程了，返回的是一个<code>ActivityManagerProxy</code>对象，然后在<code>ActivityManagerProxy</code>里面有<code>startActivity</code>方法，里面有这么一句<code>mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);</code>又熟悉了吧。好吧，就说到这里了。</p>
<p>##结尾<br>以上只是我自己了解的浅见，肯定有不合理的地方，也只是我自己的理解，以后还会继续学习这方面的东西，毕竟现在也只是一知半解的。</p>
<p>参考：</p>
<p><a href="http://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="external">《Binder学习指南》</a></p>
<p><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287" target="_blank" rel="external">【凯子哥带你学Framework】Activity启动过程全解析</a></p>
<p><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Bander设计与实现 - 设计篇</a>  没看太明白😂</p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external"> Android进程间通信（IPC）机制Binder简要介绍和学习计划</a>  老罗的也是经典</p>
<p><a href="https://github.com/70kg/Demos/tree/master/app/src/main/java/com/demos/aidl" target="_blank" rel="external">还有我的手写AIDL😂</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/07/09/View的绘制过程/" class="prev">PREV</a><a href="/2016/07/09/Volley源码解析/" class="next">NEXT</a></div><div data-thread-key="2016/07/09/Android Binder 浅析/" data-title="Android Binder 浅析" data-url="http://yoursite.com/2016/07/09/Android Binder 浅析/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"70kg"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">70kg</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>