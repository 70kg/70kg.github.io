<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> View触摸事件 · 70kg</title><meta name="description" content="View触摸事件 - 70kg"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="70kg"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">View触摸事件</h1><div class="post-info">Jul 9, 2016</div><div class="post-content"><p>##扯<br>这是一篇很早之前就应该写完的东西，这是一篇很早之前就应该写完的东西，这是一篇很早之前就应该写完的东西。其实触摸事件说简单也不复杂，说复杂也不简单。如果只是简单的从爹传给儿子，儿子不处理再传给爹，这样确实没什么意思。还是去代码里面看看是怎么回事。<a id="more"></a></p>
<p>##View的触摸事件</p>
<p>###dispatchTouchEvent<br>首先都知道触摸事件是从<code>dispatchTouchEvent</code>方法开始的，那就先去<code>View</code>的这个方法看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">....</div><div class="line"> if (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">            //noinspection SimplifiableIfStatement</div><div class="line">            ListenerInfo li = mListenerInfo;</div><div class="line">            if (li != null &amp;&amp; li.mOnTouchListener != null</div><div class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</div><div class="line">                result = true;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">                result = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</div><div class="line">            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);</div><div class="line">        &#125;</div><div class="line">        .....</div></pre></td></tr></table></figure>
<p>先是判断没有被遮挡，然后就有了<code>ListenerInfo</code>，这个类是用来存放各种<code>Listener</code>,重点看这句话的判断，首先<code>li</code>一般不是空，后面的是通过view的<code>setOnTouchListener</code>设置进来的，后面的是View是不是<code>ENABLED</code>，默认都是true,再后面就是去看前面设置的<code>ENABLED</code>的<code>onTouch</code>方法返回值。也就是说如果View设置了<code>setOnTouchListener</code>并且View的状态是<code>ENABLED</code>并且返回true,那么就直接返回true,否则还得去下面的<code>if (!result &amp;&amp; onTouchEvent(event))</code>里面判断，如果view的<code>onTouchEvent</code>返回true,那么就整体返回true,否则就是false.<br>总结一下就是：如果设置了<code>setOnTouchListener</code>，那么要去先执行<code>setOnTouchListener</code>的<code>onTouch</code>方法，根据这个方法的返回值判断是不是要去执行下面的判断，如果返回true,意味着在<code>onTouch</code>方法中view已经消耗完了事件，就不会再去调用view的<code>onTouchEvent</code>方法。如果没有设置<code>setOnTouchListener</code>，或者<code>onTouch</code>返回false,意味着还没消耗完事件，再需要去<code>onTouchEvent</code>方法里面转一圈，然后再去决定返回值。下面再来说说view的<code>onTouchEvent</code>方法。</p>
<p>###onTouchEvent<br>首先是这个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">            if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</div><div class="line">                setPressed(false);</div><div class="line">            &#125;</div><div class="line">            // A disabled view that is clickable still consumes the touch</div><div class="line">            // events, it just doesn&apos;t respond to them.</div><div class="line">            return (((viewFlags &amp; CLICKABLE) == CLICKABLE</div><div class="line">                    || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</div><div class="line">                    || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</div><div class="line">        &#125;</div><div class="line">        ...</div></pre></td></tr></table></figure>
<p>如果是<code>DISABLED</code>并且是<code>CLICKABLE</code>，那直接返回true,如果不是<code>CLICKABLE</code>那就直接返回false,这两个都是可以在XML或者代码里面设置的。那么如果不是是<code>DISABLED</code>并且是<code>CLICKABLE</code>，就进入下面的switch语句，在down和move里面主要就是设置和重置之类的，主要在up的时候，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">case MotionEvent.ACTION_UP:</div><div class="line">//是不是按过了</div><div class="line">                   boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;</div><div class="line">                   if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;</div><div class="line">                       boolean focusTaken = false;</div><div class="line">                       if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class="line">                       //尝试获取焦点</div><div class="line">                           focusTaken = requestFocus();</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       if (prepressed) &#123;</div><div class="line">                          </div><div class="line">                           setPressed(true, x, y);</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                       if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</div><div class="line">                       //不是长按的</div><div class="line">                           removeLongPressCallback();</div><div class="line"></div><div class="line">                        </div><div class="line">                           if (!focusTaken) &#123;</div><div class="line">                              </div><div class="line">                               if (mPerformClick == null) &#123;</div><div class="line">                                   mPerformClick = new PerformClick();</div><div class="line">                               &#125;</div><div class="line">                               if (!post(mPerformClick)) &#123;</div><div class="line">                               //这里执行点击事件</div><div class="line">                                   performClick();</div><div class="line">                               &#125;</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                      。。。</div><div class="line">                   break;</div></pre></td></tr></table></figure>
<p>这里可以看到，我们设置的<code>onClickListener</code>是在up的时候触发的。关于<code>dispatchTouchEvent</code>的返回值以及后面的事情，下面会说到。</p>
<p>##ViewGroup的dispatchTouchEvent<br>这是一个非常长的一个方法，就不贴那么多代码了，找些重要的说一下，首先</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">                cancelAndClearTouchTargets(ev);</div><div class="line">                //重置 重要的是把mFirstTouchTarget置为空</div><div class="line">                resetTouchState();</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>然后就是去判断是否拦截</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">final boolean intercepted;</div><div class="line">            if (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                    || mFirstTouchTarget != null) &#123;</div><div class="line">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</div><div class="line">                if (!disallowIntercept) &#123;</div><div class="line">                    intercepted = onInterceptTouchEvent(ev);</div><div class="line">                    ev.setAction(action); // restore action in case it was changed</div><div class="line">                &#125; else &#123;</div><div class="line">                    intercepted = false;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                // There are no touch targets and this action is not an initial down</div><div class="line">                // so this view group continues to intercept touches.</div><div class="line">                intercepted = true;</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>这样说一下，当是down或者<code>mFirstTouchTarget != null</code>的时候才有机会执行<code>onInterceptTouchEvent(ev)</code>方法，而前面的<code>disallowIntercept</code>参数是根据我们在外面调用<code>disallowIntercept</code>方法决定的。意思就是如果是down或者<code>mFirstTouchTarget != null</code>(找到处理事件的view了),并且外部没有请求不去拦截事件，那么就去调用<code>onInterceptTouchEvent</code>，如果外部请求拦截了，那<code>intercepted = false;</code>否则就是true（不是down并且没有找到处理事件的view）。下面就是<code>if (!canceled &amp;&amp; !intercepted)</code>，不是取消事件并且没拦截，就进入下面的判断<code>if (actionMasked == MotionEvent.ACTION_DOWN
                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {</code>这里可以理解为down的判断，然后就是倒序遍历整个的childView,倒序是为了显示在最上面的view最先被调用。下面就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">newTouchTarget = getTouchTarget(child);</div><div class="line">                           if (newTouchTarget != null) &#123;</div><div class="line">                               // Child is already receiving touch within its bounds.</div><div class="line">                               // Give it the new pointer in addition to the ones it is handling.</div><div class="line">                               newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                               break;</div><div class="line">                           &#125;</div></pre></td></tr></table></figure>
<p>如果找到了接收Touch事件的子View，就直接break,刚开始应该是没有的，那就进入下面的<code>if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign))</code>这是一个很重要的判断，如果返回true,意味着子view消耗掉了事件，接下来就是给newTouchTarget赋值，给alreadyDispatchedToNewTouchTarget赋值为true，执行break，因为该for循环遍历子View判断哪个子View接受Touch事件，既然已经找到了就跳出该外层for循环。如果返回false,就不会执行上面的，也就没法给<code>mFirstTouchTarget</code>赋值，所以如果子view不去处理down事件，那么其余的事件是不会传给它的。回到前面这个重要的判断，进去是递归调用了<code>dispatchTouchEvent()</code>方法，如果child==null.也就是viewgroup，就去执行<code>super.dispatchTouchEvent(event);</code>也就是view的<code>dispatchTouchEvent</code>方法，当做一个正常的view进行分发。如果child不是Null，那就执行<code>child.dispatchTouchEvent(event);</code>,进入下一级的分发。down结束了，下面就是move事件，在down结束的时候，<code>mFirstTouchTarget</code>可能是Null，没找到处理的view，不为空，找到了处理的view，把剩下的事件分发给这个view就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (mFirstTouchTarget == null) &#123;</div><div class="line">            //没有处理的view  move的时候再来执行一次</div><div class="line">               handled = dispatchTransformedTouchEvent(ev, canceled, null,</div><div class="line">                       TouchTarget.ALL_POINTER_IDS);</div><div class="line">           &#125; else &#123;</div><div class="line">           ....分发给对应的view</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<p>剩下的结论就不写了，再去想想那些大神的总结，是不是更加有道理了。其实最重要的判断就是view的<code>onTouchEvent</code>是不是返回true,也就是有没有去消耗事件，决定了整个事件的走向。</p>
<p>这篇其实写的挺差劲的，写的可以更加有条理更加清晰一些，但是自己的表达能力，理解能力确实有限，以后再来读一读今天写的，或许再重构一遍也不一定啦。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/07/09/Volley源码解析/" class="prev">PREV</a><a href="/2016/03/04/《Android开发艺术探索》笔记-1/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">70kg</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>