<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> View的绘制过程 · 70kg</title><meta name="description" content="View的绘制过程 - 70kg"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="70kg"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/2790907881/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/70kg" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">View的绘制过程</h1><div class="post-info">Jul 9, 2016</div><div class="post-content"><p>&emsp;&emsp;这次来说一说view的绘制过程，同样也算是个笔记的东西，梳理一下大致的过程，忽略了内部很多的条件判断等。上次说了<code>setcontentview</code>和<code>infalter</code>的一些简单过程，这个是用来把view从XML文件的格式解析和加载，但是具体view的怎么绘制到界面上的并没有提及，还有上次留下的问题，有时间学习了<code>activity</code>的启动流程再来说一下，现在开始吧。<a id="more"></a></p>
<p>&emsp;&emsp;网上有很多的文章说view的绘制，无非就是三个方法<code>onMeasure</code>,<code>onLayout</code>,<code>onDraw</code>，但是这仅仅是冰山一角，这三个方法的调用时机和内部的大致运行逻辑并没有说清楚，现在先从view开始的地方说起。</p>
<p>&emsp;&emsp;view从什么地方开始绘制呢，先说结论吧，因为没有一些铺垫即使从开始的地方说起也是云里雾里，说完整个的大致过程，再去看开始的地方也就顺其自然了。view的绘制是从<code>ViewRootImpl</code> 的<code>performTraversals</code>方法开始的，翻译就是递归调用，我们已经知道，view是嵌套存在的，所以要去绘制整个的view肯定要去嵌套调用一些方法，(ps:这个源码是在API22下看的，在23的时候又有一些改变，但是整个的逻辑是没有变化的)。我们找到这个方法，这是个非常长的方法，一共有782行，所以会去忽略很多的判断条件，只所我们关注的三个重点方法，首先找到这里：</p>
<p>###Measure<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</div><div class="line">int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div><div class="line">// Ask host how big it wants to be</div><div class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure></p>
<p>这里就是进行view测绘的地方，先去<code>getRootMeasureSpec</code>方法里面看看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123;</div><div class="line">        int measureSpec;</div><div class="line">        switch (rootDimension) &#123;</div><div class="line"></div><div class="line">        case ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">            // Window can&apos;t resize. Force root view to be windowSize.</div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line">            break;</div><div class="line">        case ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line">            // Window can resize. Set max size for root view.</div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            // Window wants to be an exact size. Force root view to be that size.</div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        return measureSpec;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这是个组装参数的地方，像我们平常说的<code>MATCH_PARENT</code>对应<code>EXACTLY</code>，<code>WRAP_CONTENT</code>对应<code>AT_MOST</code>这里就看的很清楚了，而且这个根视图，之前提到过的，肯定是走<code>MATCH_PARENT</code>，这就是我们根视图总是全屏的原因。</p>
<p>&emsp;&emsp;回到前面还有个<code>performMeasure</code>方法，看注释也知道是干啥的，进去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);</div><div class="line">        try &#123;</div><div class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">        &#125; finally &#123;</div><div class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看，来到了view的<code>measure</code>方法，也就是说<code>measure</code>方法的两个参数其实都是父view的，下面还可以看到，真正决定一个view的大小是这父view的两个参数和子view共同决定的。下面就进到了view里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * &lt;p&gt;</div><div class="line">    * This is called to find out how big a view should be. The parent</div><div class="line">    * supplies constraint information in the width and height parameters.</div><div class="line">    * &lt;/p&gt;</div><div class="line">    *</div><div class="line">    * &lt;p&gt;</div><div class="line">    * The actual measurement work of a view is performed in</div><div class="line">    * &#123;@link #onMeasure(int, int)&#125;, called by this method. Therefore, only</div><div class="line">    * &#123;@link #onMeasure(int, int)&#125; can and must be overridden by subclasses.</div><div class="line">    * &lt;/p&gt;</div><div class="line">    *</div><div class="line">    *</div><div class="line">    * @param widthMeasureSpec Horizontal space requirements as imposed by the</div><div class="line">    *        parent</div><div class="line">    * @param heightMeasureSpec Vertical space requirements as imposed by the</div><div class="line">    *        parent</div><div class="line">    *</div><div class="line">    * @see #onMeasure(int, int)</div><div class="line">    */</div><div class="line">   public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">   ...各种不明白的东西。。😂</div><div class="line">   </div><div class="line">      onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">      </div><div class="line">    ...继续各种不明白的东西。。😂</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这里主要还是看注释，四级水平理解一下，这个方法调用用来测量view应该有多大，父布局在宽高里面提供限制信息，也就是前面说的view的大小由爹和儿子一起决定，还有就是实际的测量工作是在子类的<code>onMeasure</code>方法里面搞，因为<code>measure</code>是final的。这就是平时自定义view的时候要去从写这个方法的原因，别急，还没完，进去看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Measure the view and its content to determine the measured width and the</div><div class="line">     * measured height. This method is invoked by &#123;@link #measure(int, int)&#125; and</div><div class="line">     * should be overridden by subclasses to provide accurate and efficient</div><div class="line">     * measurement of their contents.</div><div class="line">     * &lt;/p&gt;</div><div class="line">     *</div><div class="line">     * &lt;p&gt;</div><div class="line">     * &lt;strong&gt;CONTRACT:&lt;/strong&gt; When overriding this method, you</div><div class="line">     * &lt;em&gt;must&lt;/em&gt; call &#123;@link #setMeasuredDimension(int, int)&#125; to store the</div><div class="line">     * measured width and height of this view. Failure to do so will trigger an</div><div class="line">     * &lt;code&gt;IllegalStateException&lt;/code&gt;, thrown by</div><div class="line">     * &#123;@link #measure(int, int)&#125;. Calling the superclass&apos;</div><div class="line">     * &#123;@link #onMeasure(int, int)&#125; is a valid use.</div><div class="line">     * &lt;/p&gt;</div><div class="line">     *</div><div class="line">     * &lt;p&gt;</div><div class="line">     * The base class implementation of measure defaults to the background size,</div><div class="line">     * unless a larger size is allowed by the MeasureSpec. Subclasses should</div><div class="line">     * override &#123;@link #onMeasure(int, int)&#125; to provide better measurements of</div><div class="line">     * their content.</div><div class="line">     * &lt;/p&gt;</div><div class="line">     *</div><div class="line">     * &lt;p&gt;</div><div class="line">     * If this method is overridden, it is the subclass&apos;s responsibility to make</div><div class="line">     * sure the measured height and width are at least the view&apos;s minimum height</div><div class="line">     * and width (&#123;@link #getSuggestedMinimumHeight()&#125; and</div><div class="line">     * &#123;@link #getSuggestedMinimumWidth()&#125;).</div><div class="line">     * &lt;/p&gt;</div><div class="line">     *</div><div class="line">     * @param widthMeasureSpec horizontal space requirements as imposed by the parent.</div><div class="line">     *                         The requirements are encoded with</div><div class="line">     *                         &#123;@link android.view.View.MeasureSpec&#125;.</div><div class="line">     * @param heightMeasureSpec vertical space requirements as imposed by the parent.</div><div class="line">     *                         The requirements are encoded with</div><div class="line">     *                         &#123;@link android.view.View.MeasureSpec&#125;.</div><div class="line">     *</div><div class="line">     * @see #getMeasuredWidth()</div><div class="line">     * @see #getMeasuredHeight()</div><div class="line">     * @see #setMeasuredDimension(int, int)</div><div class="line">     * @see #getSuggestedMinimumHeight()</div><div class="line">     * @see #getSuggestedMinimumWidth()</div><div class="line">     * @see android.view.View.MeasureSpec#getMode(int)</div><div class="line">     * @see android.view.View.MeasureSpec#getSize(int)</div><div class="line">     */</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以去读一读注释，简单说一下，这个方法是用来测量view和它的内容，而且一定要调用<code>setMeasuredDimension</code>把测量的结果穿进去，基类默认实现的背景的大小(这个在下面看到)。如果重写了这个方法，你得搞清楚这个view的大小至少比最小的大（后面会说）。好吧，蹩脚的英文。也就是说当我们测量完view之后，再<code>setMeasuredDimension</code>，我们的工作就结束了。那么这个方法是什么东西，去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</div><div class="line">        int result = size;</div><div class="line">        int specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        int specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        switch (specMode) &#123;</div><div class="line">        case MeasureSpec.UNSPECIFIED:</div><div class="line">            result = size;</div><div class="line">            break;</div><div class="line">        case MeasureSpec.AT_MOST:</div><div class="line">        case MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，默认的时候，当设置<code>wrap_content</code>和<code>march_parent</code>都是默认的父布局的大小，这里的size是进一步<code>getSuggestedMinimumWidth</code>传进来的,而这个的大小是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected int getSuggestedMinimumWidth() &#123;</div><div class="line">       return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>看有没有背景，这个默认是0，也可以在XML中设置,这样也说完了前面的两个问题。</p>
<p>&emsp;&emsp;到这里，似乎view的测量就完了，但是不要忘记，view是嵌套的，要去测量完整个的view，还得去<code>viewgroup</code>里面看看，<code>viewgroup</code>里面有三个方法：<code>measureChildren</code>, <code>measureChild</code>, <code>measureChildWithMargins</code>，一个个看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Ask all of the children of this view to measure themselves, taking into</div><div class="line">     * account both the MeasureSpec requirements for this view and its padding.</div><div class="line">     * We skip children that are in the GONE state The heavy lifting is done in</div><div class="line">     * getChildMeasureSpec.</div><div class="line">     *</div><div class="line">     * @param widthMeasureSpec The width requirements for this view</div><div class="line">     * @param heightMeasureSpec The height requirements for this view</div><div class="line">     */</div><div class="line">    protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        final int size = mChildrenCount;</div><div class="line">        final View[] children = mChildren;</div><div class="line">        for (int i = 0; i &lt; size; ++i) &#123;</div><div class="line">            final View child = children[i];</div><div class="line">            if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>遍历所以的子view，去测量，如果是gone的，就跳过。然后进入<code>measureChild</code>，提醒一下，这里传进去的<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>都是父view的，用来在子view测量的时候共同决定大小用的。这里的<code>measureChild</code>只包含<code>Padding</code>，<code>measureChildWithMargins</code>还包含<code>Margin</code>，调复杂的看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">protected void measureChildWithMargins(View child,</div><div class="line">            int parentWidthMeasureSpec, int widthUsed,</div><div class="line">            int parentHeightMeasureSpec, int heightUsed) &#123;</div><div class="line">            //获取子的LayoutParams</div><div class="line">        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">//看，子view的大小是由谁决定的，没错吧，这里竟然还直接获取到了lp.width，这个看下面解释吧。提示一下：这个参数是：How big the child wants to be in the current dimension</div><div class="line">        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                        + widthUsed, lp.width);</div><div class="line">        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                        + heightUsed, lp.height);</div><div class="line">       //调用view的measure进而调用onmeasure</div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看注释，然后看重要的<code>getChildMeasureSpec</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</div><div class="line">        int specMode = MeasureSpec.getMode(spec);</div><div class="line">        int specSize = MeasureSpec.getSize(spec);</div><div class="line"></div><div class="line">        int size = Math.max(0, specSize - padding);</div><div class="line"></div><div class="line">        int resultSize = 0;</div><div class="line">        int resultMode = 0;</div><div class="line">        //父view的模式</div><div class="line">        switch (specMode) &#123;</div><div class="line">        // Parent has imposed an exact size on us</div><div class="line">        //父view是具体数值或者march_parent</div><div class="line">        case MeasureSpec.EXACTLY:</div><div class="line">            if (childDimension &gt;= 0) &#123;//子view为具体数值</div><div class="line">               //直接赋值具体数值</div><div class="line">                resultSize = childDimension;</div><div class="line">                //返回子view的模式设置为EXACTLY</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;//子view是MATCH_PARENT，数值为-1</div><div class="line">                // Child wants to be our size. So be it.</div><div class="line">                //直接赋值父view的大小</div><div class="line">                resultSize = size;</div><div class="line">                 //返回子view的模式设置为EXACTLY</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;//子view是WRAP_CONTENT，数值为-2</div><div class="line">                // Child wants to determine its own size. It can&apos;t be</div><div class="line">                // bigger than us.</div><div class="line">                //设置子view的最大值不能超过父view</div><div class="line">                //这个一般还会在子view的onmeasure里面去重写，是吧</div><div class="line">                resultSize = size;</div><div class="line">                //返回子view的模式设置为AT_MOST</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line"></div><div class="line">     //。。。。</div><div class="line">     //过程差不多的两个模式AT_MOST和UNSPECIFIED</div><div class="line">       </div><div class="line">        &#125;</div><div class="line">        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注释已经很详细了，这就是我们见到的父view和子view的在某些关系下面的布局样式。这次明白了吧。整个逻辑大概说一下，rootview获得宽高和模式，通过<code>MeasureSpec</code>传给下一级，一般是<code>viewgroup</code>，然后<code>viewgroup</code>主要调用<code>getChildMeasureSpec</code>根据上面的<code>MeasureSpec</code>子view的<code>childDimension</code>来确定自己<code>viewgroup</code>的大小，如果还有子view，把计算出来的自己的<code>MeasureSpec</code>再传下去.在viewgroup中我们并没有看到调用<code>setMeasuredDimension</code>方法去把测量的值传递进去，这个是因为viewgroup是个抽象类，具体的测量方式需要我们自己去实现，比如可以去看看<code>LinearLayout</code>的实现，就在测量完成后调用了<code>setMeasuredDimension</code>方法。所以在一般自定义viewgroup的时候，可以先去调用<code>measureChildren</code>去测量完全部的子view，这样就可以去获取子view的宽高，然后再干什么就随你了，最后不要忘记去调用<code>setMeasuredDimension</code>方法。</p>
<p>###layout<br>&emsp;&emsp;现在整个view的测绘就差不多结束了，下一步就是开始layout的步骤。先去看viewgroup里面的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public final void layout(int l, int t, int r, int b) &#123;</div><div class="line">       if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123;</div><div class="line">           if (mTransition != null) &#123;</div><div class="line">               mTransition.layoutChange(this);</div><div class="line">           &#125;</div><div class="line">           super.layout(l, t, r, b);</div><div class="line">       &#125; else &#123;</div><div class="line">           // record the fact that we noop&apos;d it; request layout when transition finishes</div><div class="line">           mLayoutCalledWhileSuppressed = true;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>其实还是调用了view里面的<code>layout</code>方法，进去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;</div><div class="line">        ......</div><div class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            //回调onLayout</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>和<code>measure</code>的过程差不多，还是去调用<code>onLayout</code>方法，看一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>空的，那viewgroup的呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected abstract void onLayout(boolean changed,</div><div class="line">            int l, int t, int r, int b);</div></pre></td></tr></table></figure>
<p>也是空的，还变成抽象的了，那总结一下：view的layuout方法并没有像<code>measure</code>方法一下是final的，但是也是不推荐去重写的，如果有需要还是去重写<code>onLayout</code>方法，而在viewgroup中，<code>layout</code>变成了final,<code>onLayout</code>方法变成抽象的了，这就要求子类必须去实现这个过程，也就是要去子类自己去决定里面的view怎么去排布，所以去找个子类看看，还是拿<code>LinearLayout</code>看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        if (mOrientation == VERTICAL) &#123;</div><div class="line">            layoutVertical(l, t, r, b);</div><div class="line">        &#125; else &#123;</div><div class="line">            layoutHorizontal(l, t, r, b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看名字就知道了，不解释，选个<code>layoutVertical</code>看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">void layoutVertical(int left, int top, int right, int bottom) &#123;</div><div class="line">        final int paddingLeft = mPaddingLeft;</div><div class="line"></div><div class="line">        int childTop;</div><div class="line">        int childLeft;</div><div class="line">        //理解为父view提供给子view的宽度</div><div class="line">        // Where right end of child should go</div><div class="line">        final int width = right - left;</div><div class="line">        //子view在父view中的右边位置</div><div class="line">        int childRight = width - mPaddingRight;</div><div class="line">        </div><div class="line">        //子view的可用大小</div><div class="line">        // Space available for child</div><div class="line">        int childSpace = width - paddingLeft - mPaddingRight;</div><div class="line">        //子view的数量</div><div class="line">        final int count = getVirtualChildCount();</div><div class="line">        //主要的Gravity方式</div><div class="line">        final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</div><div class="line">        final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</div><div class="line"></div><div class="line">        switch (majorGravity) &#123;</div><div class="line">           case Gravity.BOTTOM://居底</div><div class="line">               // mTotalLength contains the padding already</div><div class="line">               childTop = mPaddingTop + bottom - top - mTotalLength;</div><div class="line">               break;</div><div class="line"></div><div class="line">               // mTotalLength contains the padding already</div><div class="line">           case Gravity.CENTER_VERTICAL:</div><div class="line">               childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;</div><div class="line">               break;</div><div class="line"></div><div class="line">           case Gravity.TOP:</div><div class="line">           default:</div><div class="line">               childTop = mPaddingTop;</div><div class="line">               break;</div><div class="line">        &#125;</div><div class="line">//开始遍历了</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            final View child = getVirtualChildAt(i);</div><div class="line">            if (child == null) &#123;</div><div class="line">                childTop += measureNullChild(i);</div><div class="line">                //忽略gone的</div><div class="line">            &#125; else if (child.getVisibility() != GONE) &#123;</div><div class="line">                final int childWidth = child.getMeasuredWidth();</div><div class="line">                final int childHeight = child.getMeasuredHeight();</div><div class="line">                </div><div class="line">                final LinearLayout.LayoutParams lp =</div><div class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">                </div><div class="line">                int gravity = lp.gravity;</div><div class="line">                if (gravity &lt; 0) &#123;</div><div class="line">                    gravity = minorGravity;</div><div class="line">                &#125;</div><div class="line">                final int layoutDirection = getLayoutDirection();</div><div class="line">                final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</div><div class="line">                switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</div><div class="line">                    case Gravity.CENTER_HORIZONTAL:</div><div class="line">                        childLeft = paddingLeft + ((childSpace - childWidth) / 2)</div><div class="line">                                + lp.leftMargin - lp.rightMargin;</div><div class="line">                        break;</div><div class="line"></div><div class="line">                    case Gravity.RIGHT:</div><div class="line">                        childLeft = childRight - childWidth - lp.rightMargin;</div><div class="line">                        break;</div><div class="line"></div><div class="line">                    case Gravity.LEFT:</div><div class="line">                    default:</div><div class="line">                        childLeft = paddingLeft + lp.leftMargin;</div><div class="line">                        break;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">                    childTop += mDividerHeight;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                childTop += lp.topMargin;</div><div class="line">                //其实还是调用view.layout</div><div class="line">                setChildFrame(child, childLeft, childTop + getLocationOffset(child),</div><div class="line">                        childWidth, childHeight);</div><div class="line">                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</div><div class="line"></div><div class="line">                i += getChildrenSkipCount(child, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>整个的layout过程比measure好理解，还要提一下，平时使用的时候会遇到<code>getMeasuredWidth</code>和<code>getWidth</code>，这里就差不多可以理解了，第一个是在measure之后可以获取到，而第二个需要在layout之后才可以获取到，一般都是一样的。总结一下：<br>measure操作完成后得到的是对每个View经测量过的measuredWidth和<code>measuredHeight</code>，layout操作完成之后得到的是对每个View进行位置分配后的mLeft、mTop、mRight、mBottom，这些值都是相对于父View来说的。凡是<code>layout_XXX</code>的布局属性基本都针对的是包含子View的ViewGroup的，当对一个没有父容器的View设置相关<code>layout_XXX</code>属性是没有任何意义的，看前面的那篇。到这里，layout的过程也差不多了，该到了绘制的时候了。</p>
<p>###draw<br>view的绘制过程是比较复杂的，贴一张图，来自<a href="http://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="external">工匠若水</a><br><img src="http://img.blog.csdn.net/20150530154328068" alt=""><br>因为viewgroup没有去重写draw方法，直接去看view里面的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void draw(Canvas canvas) &#123;</div><div class="line">       ...</div><div class="line"></div><div class="line">       /*</div><div class="line">        * Draw traversal performs several drawing steps which must be executed</div><div class="line">        * in the appropriate order:</div><div class="line">        *</div><div class="line">        *      1. Draw the background</div><div class="line">        *      2. If necessary, save the canvas&apos; layers to prepare for fading</div><div class="line">        *      3. Draw view&apos;s content</div><div class="line">        *      4. Draw children</div><div class="line">        *      5. If necessary, draw the fading edges and restore layers</div><div class="line">        *      6. Draw decorations (scrollbars for instance)</div><div class="line">        */</div><div class="line">      ...</div></pre></td></tr></table></figure>
<p>注释写的很清楚了，一共分为6步，其中2，5可以省略，一步步来吧</p>
<p>####第一步，对View的背景进行绘制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private void drawBackground(Canvas canvas) &#123;</div><div class="line">//平时设置的setbackground,实质都转变为一个Drawable</div><div class="line">        final Drawable background = mBackground;</div><div class="line">        ...</div><div class="line">        //设置绘制范围</div><div class="line">        setBackgroundBounds();</div><div class="line">        ...</div><div class="line">        final int scrollX = mScrollX;</div><div class="line">        final int scrollY = mScrollY;</div><div class="line">        if ((scrollX | scrollY) == 0) &#123;//没有滚动</div><div class="line">            background.draw(canvas);</div><div class="line">        &#125; else &#123;</div><div class="line">            canvas.translate(scrollX, scrollY);</div><div class="line">            //最终使用了Drawable的draw</div><div class="line">            background.draw(canvas);</div><div class="line">            canvas.translate(-scrollX, -scrollY);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>####第二步，保存图层，执行渐变操作<br>主要调用<code>canvas.saveLayer</code>方法，不多说</p>
<p>####第三步，绘制内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Step 3, draw the content</div><div class="line">       if (!dirtyOpaque) </div><div class="line">       onDraw(canvas);</div></pre></td></tr></table></figure>
<p>而<code>onDraw</code>又是个空方法，因为具体绘制什么东西还得具体的view说了算</p>
<p>####第四步，绘制所有的子view</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> // Step 4, draw the children</div><div class="line">        dispatchDraw(canvas);</div><div class="line">        </div><div class="line">/**</div><div class="line">     * Called by draw to draw the child views. This may be overridden</div><div class="line">     * by derived classes to gain control just before its children are drawn</div><div class="line">     * (but after its own view has been drawn).</div><div class="line">     * @param canvas the canvas on which to draw the view</div><div class="line">     */</div><div class="line">    protected void dispatchDraw(Canvas canvas) &#123;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里看到<code>dispatchDraw</code>是个空方法，注释里面说，如果包含子view就需要去重写这个方法，去viewgroup里面看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   protected void dispatchDraw(Canvas canvas) &#123;</div><div class="line">       ......</div><div class="line">       final int childrenCount = mChildrenCount;</div><div class="line">       final View[] children = mChildren;</div><div class="line">       ......</div><div class="line">       for (int i = 0; i &lt; childrenCount; i++) &#123;</div><div class="line">           ......</div><div class="line">           if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123;</div><div class="line">               more |= drawChild(canvas, child, drawingTime);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       ......</div><div class="line">       // Draw any disappearing views that have animations</div><div class="line">       if (mDisappearingChildren != null) &#123;</div><div class="line">           ......</div><div class="line">           for (int i = disappearingCount; i &gt;= 0; i--) &#123;</div><div class="line">               ......</div><div class="line">               more |= drawChild(canvas, child, drawingTime);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       ......</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>还是去遍历所有的子view,然后去调用view.draw方法</p>
<p>####第五步，绘制渐变效果并且恢复图层<br>这个和第二部相对应，不说了</p>
<p>###第六步，绘制view的滚动条<br>也不分析了，所以其实所有的 view都是有滚动条的</p>
<p>到这里，整个view就差不多绘制完成了。</p>
<p>###View的invalidate<br>如果去查一查view的源码，你会发现这个方法出现的特别多，我们这个方法是用来在主线程中调用去重绘view的，但是为什么会出现这么多次，而且它是怎么去实现重绘的呢，而且开头的时候还有一个问题没有解决，简单的看一下。<br>view有多个重载的<code>invalidate</code>，但是最终都走到了<code>invalidateInternal</code>方法，看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,</div><div class="line">            boolean fullInvalidate) &#123;</div><div class="line">        ......</div><div class="line">            final AttachInfo ai = mAttachInfo;</div><div class="line">            final ViewParent p = mParent;</div><div class="line">            if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</div><div class="line">                final Rect damage = ai.mTmpInvalRect;</div><div class="line">                //设置刷新区域</div><div class="line">                damage.set(l, t, r, b);</div><div class="line">                //传递调运ViewParent， 一般是ViewGroup的invalidateChild方法</div><div class="line">                p.invalidateChild(this, damage);</div><div class="line">            &#125;</div><div class="line">            ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里主要是<code>p.invalidateChild(this, damage);</code>这个方法，</p>
<blockquote>
<p>View的invalidate（invalidateInternal）方法实质是将要刷新区域直接传递给了父ViewGroup的invalidateChild方法，在invalidate中，调用父View的invalidateChild，这是一个从当前向上级父View回溯的过程，每一层的父View都将自己的显示区域与传入的刷新Rect做交集 。</p>
</blockquote>
<p>而<code>ViewParent</code>是个接口，viewgroup和<code>ViewRootImpl</code>都实现了这个接口，所以先去viewgroup看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public final void invalidateChild(View child, final Rect dirty) &#123;</div><div class="line">       ViewParent parent = this;</div><div class="line">       final AttachInfo attachInfo = mAttachInfo;</div><div class="line">       ......</div><div class="line">       do &#123;</div><div class="line">           ......</div><div class="line">           //循环层层上级调运，直到ViewRootImpl会返回null</div><div class="line">           parent = parent.invalidateChildInParent(location, dirty);</div><div class="line">           ......</div><div class="line">       &#125; while (parent != null);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这里进行了了循环，最终还是去了<code>ViewRootImpl</code>，看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123;</div><div class="line">    ......</div><div class="line">    //View调运invalidate最终层层上传到ViewRootImpl后最终触发了该方法</div><div class="line">    scheduleTraversals();</div><div class="line">    ......</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里直接返回Null，退出上面的循环，而<code>scheduleTraversals</code>这个方法，最终会调用最初我们看到的<code>performTraversals</code>方法进行重新绘制。但是肯定是不会走最初的流程，经过一些判断之后只会去重绘需要重绘的地方。还是贴张图(来自<a href="">工匠若水</a>)<br><img src="http://img.blog.csdn.net/20150531111928069" alt="">,</p>
<blockquote>
<p>常见的引起invalidate方法操作的原因主要有：<br>直接调用invalidate方法.请求重新draw，但只会绘制调用者本身。<br>触发setSelection方法。请求重新draw，但只会绘制调用者本身。<br>触发setVisibility方法。 当View可视状态在INVISIBLE转换VISIBLE时会间接调用invalidate方法，继而绘制该View。当View的可视状态在INVISIBLE\VISIBLE 转换为GONE状态时会间接调用requestLayout和invalidate方法，同时由于View树大小发生了变化，所以会请求measure过程以及draw过程，同样只绘制需要“重新绘制”的视图。<br>触发setEnabled方法。请求重新draw，但不会重新绘制任何View包括该调用者本身。<br>触发requestFocus方法。请求View树的draw过程，只绘制“需要重绘”的View。</p>
</blockquote>
<p>最后再来去解释一下最初的那个view绘制入口的问题，还是接上一篇，在<code>setContentView</code>方法里面有这个<code>mContentParent.addView(view, params);</code>而在<code>addView</code>方法里面有这么一句话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void addView(View child, int index, LayoutParams params) &#123;</div><div class="line">        ......</div><div class="line">        invalidate(true);</div><div class="line">        ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这下明白了吧。</p>
<p>参考：</p>
<p><a href="http://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="external"> Android应用层View绘制流程与源码分析</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/07/09/聊聊从setContentView到界面的显示/" class="prev">PREV</a><a href="/2016/07/09/Android Binder 浅析/" class="next">NEXT</a></div><div data-thread-key="2016/07/09/View的绘制过程/" data-title="View的绘制过程" data-url="http://yoursite.com/2016/07/09/View的绘制过程/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"70kg"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">70kg</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-81769413-1",'auto');ga('send','pageview');</script></body></html>