<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 聊聊从setContentView到界面的显示 · 70kg</title><meta name="description" content="聊聊从setContentView到界面的显示 - 70kg"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="70kg"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/2790907881/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/70kg" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">聊聊从setContentView到界面的显示</h1><div class="post-info">Jul 9, 2016</div><div class="post-content"><p>###背景<br>&emsp;&emsp;为什么要写这篇呢，其实想写一篇比较深入的文章很久了，只是一直比较懒和各种接口没去花精力去实施，正好有个元旦假期，花了点时间看了一些博客再加上自己的分析，然后想记录下来，不敢说多么的精彩和深入，就当个笔记。也算是<code>frameWork</code>层的初步探索吧。开始吧。<a id="more"></a></p>
<p>###setContentView<br>&emsp;&emsp;在Android里面，去设置布局最常见的就是在<code>onCreate</code>方法里面使用<code>setContentView(int layoutResID)</code>这个函数把定义的XML文件设置进去，跟进去看看，发现其实有三个重载的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">        getWindow().setContentView(layoutResID);</div><div class="line">        initWindowDecorActionBar();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setContentView(View view) &#123;</div><div class="line">        getWindow().setContentView(view);</div><div class="line">        initWindowDecorActionBar();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setContentView(View view, ViewGroup.LayoutParams params) &#123;</div><div class="line">        getWindow().setContentView(view, params);</div><div class="line">        initWindowDecorActionBar();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>但是最终都是调用了<code>getWindow().setContentView</code>，这个<code>getWindow()</code>又是啥？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Window getWindow() &#123;</div><div class="line">        return mWindow;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>返回的是一个<code>Window</code>对象，这个<code>Window</code>是个抽象类(不那么啰嗦了),真正作用的是唯一的一个实现类<code>PhoneWindow</code>，在<code>attach</code>里面可以看到<code>mWindow = new PhoneWindow(this);</code>再回到前面还有个方法<code>initWindowDecorActionBar();</code>看名字是初始化Window装饰ActionBar，进去看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Creates a new ActionBar, locates the inflated ActionBarView,</div><div class="line">     * initializes the ActionBar with the view, and sets mActionBar.</div><div class="line">     */</div><div class="line">    private void initWindowDecorActionBar() &#123;</div><div class="line">        Window window = getWindow();</div><div class="line"></div><div class="line">        // Initializing the window decor can change window feature flags.</div><div class="line">        // Make sure that we have the correct set before performing the test below.</div><div class="line">        window.getDecorView();</div><div class="line"></div><div class="line">        if (isChild() || !window.hasFeature(Window.FEATURE_ACTION_BAR) || mActionBar != null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mActionBar = new WindowDecorActionBar(this);</div><div class="line">        mActionBar.setDefaultDisplayHomeAsUpEnabled(mEnableDefaultActionBarUp);</div><div class="line"></div><div class="line">        mWindow.setDefaultIcon(mActivityInfo.getIconResource());</div><div class="line">        mWindow.setDefaultLogo(mActivityInfo.getLogoResource());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里看到又调用了<code>getWindow</code>而且下面还有个<code>window.getDecorView();</code>上面的注释看到，这个函数执行之后就初始化了<code>window</code>的各种<code>feature flags</code>所以这就是为什么我们常见的设置<code>feature</code>一定要在<code>setContentView</code>之前了，因为在执行<code>setContentView</code>之后，就把Window的相关特征标志给初始化了，再去设置也没什么卵用。这个<code>window.getDecorView()</code>在<code>PhoneWindow</code>是这个样子的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public final View getDecorView() &#123;</div><div class="line">    if (mDecor == null) &#123;</div><div class="line">         installDecor();</div><div class="line">     &#125;</div><div class="line">      return mDecor;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这个<code>installDecor</code>在<code>setContentView</code>里面也有使用，还是回去吧，看看<code>setContentView</code>里面是什么样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</div><div class="line">        // decor, when theme attributes and the like are crystalized. Do not check the feature</div><div class="line">        // before this happens.</div><div class="line">        if (mContentParent == null) &#123;</div><div class="line">            installDecor();//这个见过了，后面会再说</div><div class="line">        &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">            mContentParent.removeAllViews();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">        //这个在共享元素里面用过</div><div class="line">            final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</div><div class="line">                    getContext());</div><div class="line">            transitionTo(newScene);</div><div class="line">        &#125; else &#123;</div><div class="line">        //这个就是把布局文件加入到mContentParent</div><div class="line">            mLayoutInflater.inflate(layoutResID, mContentParent);</div><div class="line">        &#125;</div><div class="line">        final Callback cb = getCallback();</div><div class="line">        //就是回调喽，可以发现我们可以多次调用setContentView，因为会removeAllViews，并且会回调onContentChanged，在这个方法里面就可以执行想要的操作了。</div><div class="line">        if (cb != null &amp;&amp; !isDestroyed()) &#123;</div><div class="line">            cb.onContentChanged();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里有两个疑问，<code>mContentParent</code>是啥？<code>installDecor();</code>里面到底干了啥？下面再细说一下。</p>
<p>###installDecor()</p>
<p>直接进入这个方法看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//只看关键的</div><div class="line">private void installDecor() &#123;</div><div class="line">     if (mDecor == null) &#123;</div><div class="line">            mDecor = generateDecor();</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">         if (mContentParent == null) &#123;</div><div class="line">            mContentParent = generateLayout(mDecor);</div><div class="line">          &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要关注<code>generateDecor</code>和<code>generateLayout(mDecor)</code>，这里顺便把上面的<code>mContentParent</code>的问题提到了一点，<code>mContentParent</code>就是在这里初始化的，先看上面的<code>mDecor = generateDecor();</code>进去看到这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected DecorView generateDecor() &#123;</div><div class="line">      return new DecorView(getContext(), -1);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这个<code>DecorView</code>是啥？他是<code>PhoneWindow</code>的一个静态内部类：</p>
<pre><code>private final class DecorView extends FrameLayout implements RootViewSurfaceTaker
</code></pre><p>看到吧，其实就是个继承<code>FrameLayout</code>的<code>ViewGroup</code>，看一张图,转自<a href="http://blog.csdn.net/yanbober/article/details/45970721" target="_blank" rel="external">工匠若水</a></p>
<p><img src="http://img.blog.csdn.net/20150604144532934" alt=""><br>先说个结论：<code>mContentParent</code>就是<code>DecorView</code>里面的那个<code>content</code>,我们平时写的布局都是扔到了这个里面，所以叫做<code>setContentView()</code>，而<code>DecorView</code>就是包裹在外面的一层更根的布局。。不信可以进去<code>generateLayout(mDecor)</code>方法里面看看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</div><div class="line">        // Apply data from current theme.</div><div class="line"></div><div class="line">        TypedArray a = getWindowStyle();</div><div class="line"></div><div class="line">        //......</div><div class="line">        //依据主题style设置一堆值进行设置</div><div class="line"></div><div class="line">        // Inflate the window decor.</div><div class="line"></div><div class="line">        int layoutResource;</div><div class="line">        int features = getLocalFeatures();</div><div class="line">        //......</div><div class="line">        //根据设定好的features值选择不同的窗口修饰布局文件,得到layoutResource值</div><div class="line"></div><div class="line">        //把选中的窗口修饰布局文件添加到DecorView对象里，并且指定contentParent值</div><div class="line">        View in = mLayoutInflater.inflate(layoutResource, null);//加载了我们平时写的XML文件</div><div class="line">        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));//把我们写的文件加到DecorView中，并且设置为MATCH_PARENT，看吧，为什么默认都是MATCH_PARENT。</div><div class="line">        mContentRoot = (ViewGroup) in;</div><div class="line"></div><div class="line">        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);//这就是那个content</div><div class="line">        if (contentParent == null) &#123;</div><div class="line">            throw new RuntimeException(&quot;Window couldn&apos;t find content container view&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //......</div><div class="line">        //继续一堆属性设置，完事返回contentParent</div><div class="line">        return contentParent;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>总结一下<code>setContentView</code>的过程：</p>
<ol>
<li>创建一个DecorView的对象mDecor，该mDecor对象将作为整个应用窗口的根视图。</li>
<li>调用<code>generateLayout(DecorView decor)</code>依据Feature等style theme创建不同的窗口修饰布局文件，然后</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">View in = mLayoutInflater.inflate(layoutResource, null);</div><div class="line"></div><div class="line">decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); </div><div class="line"></div><div class="line">ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</div></pre></td></tr></table></figure>
<p>到这，<code>setContentView</code>就差不多走完了，这个工作我们一般是在<code>onCreate()</code>里面进行，但是还远没有到显示的地方，下面来简单说一下显示的过程，一个Activity的开始实际是<code>ActivityThread</code>的main方法(这个还没分析过Activity的启动过程，先就这么认为吧)，当启动Activity调运完<code>ActivityThread</code>的main方法之后，接着调用<code>ActivityThread</code>类<code>performLaunchActivity</code>来创建要启动的Activity组件，在创建Activity组件的过程中，还会为该Activity组件创建窗口对象和视图对象；接着Activity组件创建完成之后，通过调用ActivityThread类的<code>handleResumeActivity</code>将它激活。看一下这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">final void handleResumeActivity(IBinder token,</div><div class="line">            boolean clearHide, boolean isForward, boolean reallyResume) &#123;</div><div class="line"></div><div class="line">            //这个时候，Activity.onResume()已经调用了，但是现在界面还是不可见的</div><div class="line">            ActivityClientRecord r = performResumeActivity(token, clearHide);</div><div class="line"></div><div class="line">            if (r != null) &#123;</div><div class="line">                final Activity a = r.activity;</div><div class="line">                  if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</div><div class="line">                r.window = r.activity.getWindow();</div><div class="line">                View decor = r.window.getDecorView();</div><div class="line">                //decor对用户不可见</div><div class="line">                decor.setVisibility(View.INVISIBLE);</div><div class="line">                ViewManager wm = a.getWindowManager();</div><div class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</div><div class="line">                a.mDecor = decor;</div><div class="line">                //这里记住这个WindowManager.LayoutParams的type为TYPE_BASE_APPLICATION，后面介绍Window的时候会见到</div><div class="line">                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</div><div class="line"></div><div class="line">                if (a.mVisibleFromClient) &#123;</div><div class="line">                    a.mWindowAdded = true;</div><div class="line">                    //终于被添加进WindowManager了，但是这个时候，还是不可见的</div><div class="line">                    wm.addView(decor, l);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (!r.activity.mFinished &amp;&amp; willBeVisible</div><div class="line">                    &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123;</div><div class="line">                     //在这里，执行了重要的操作！</div><div class="line">                     if (r.activity.mVisibleFromClient) &#123;</div><div class="line">                            r.activity.makeVisible();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>其中的<code>makeVisible</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void makeVisible() &#123;</div><div class="line">        if (!mWindowAdded) &#123;</div><div class="line">            ViewManager wm = getWindowManager();</div><div class="line">            wm.addView(mDecor, getWindow().getAttributes());</div><div class="line">            mWindowAdded = true;</div><div class="line">        &#125;</div><div class="line">        mDecor.setVisibility(View.VISIBLE);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>到现在，整个界面才真正的显示出来，所以当调用了<code>onResume</code>方法，界面也不一定是显示的。这里还有几个问题，<code>mLayoutInflater.inflate(layoutResID, mContentParent)</code>这个到底是怎么把XML解析成view的，<code>findViewById</code>是怎么找view的，还有就是<code>WindowManager</code>是啥？他和前面提到的<code>Window</code>，<code>PhoneWindow</code>，<code>DecorView</code>啥关系？下面会再来扯一扯。</p>
<p>###findViewById<br>我们平时在<code>Activity</code>里面去使用，跟进去看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public View findViewById(@IdRes int id) &#123;</div><div class="line">        return getWindow().findViewById(id);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>好吧，熟悉吧，再进去看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Nullable</div><div class="line">   public View findViewById(@IdRes int id) &#123;</div><div class="line">       return getDecorView().findViewById(id);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>看，到了view的地方，再进去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public final View findViewById(@IdRes int id) &#123;</div><div class="line">        if (id &lt; 0) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        return findViewTraversal(id);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>再进去看看这个递归函数是怎么回事：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">protected View findViewTraversal(@IdRes int id) &#123;</div><div class="line">        if (id == mID) &#123;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>就是返回自己啊，但是仔细想想，还是得去<code>ViewGroup</code>去看，具体原因就不扯了，这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected View findViewTraversal(@IdRes int id) &#123;</div><div class="line">        if (id == mID) &#123;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final View[] where = mChildren;</div><div class="line">        final int len = mChildrenCount;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">            View v = where[i];</div><div class="line"></div><div class="line">            if ((v.mPrivateFlags &amp; PFLAG_IS_ROOT_NAMESPACE) == 0) &#123;</div><div class="line">                v = v.findViewById(id);</div><div class="line"></div><div class="line">                if (v != null) &#123;</div><div class="line">                    return v;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>就是去遍历<code>ViewGroup</code>里面的<code>View</code>，然后去调用<code>View</code>的<code>findViewById</code>，所以我们的<code>findViewById</code>都是在<code>DecorView</code>这个<code>ViewGroup</code>里面去查找的。</p>
<p>###mLayoutInflater.inflate<br>当需要加载个XML布局文件的时候，一般这样使用<code>LayoutInflater.from(this).inflate()</code>，里面有一些函数的重载，但是最终都是走到了这里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">        final Resources res = getContext().getResources();</div><div class="line">        if (DEBUG) &#123;</div><div class="line">            Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;</div><div class="line">                    + Integer.toHexString(resource) + &quot;)&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final XmlResourceParser parser = res.getLayout(resource);</div><div class="line">        try &#123;</div><div class="line">            return inflate(parser, root, attachToRoot);</div><div class="line">        &#125; finally &#123;</div><div class="line">            parser.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>使用XML解析器去解析XML文件，关键是第10行，进去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">        ...</div><div class="line">        //返回值</div><div class="line">            View result = root;</div><div class="line">        ...</div><div class="line">                //merge的布局优化，root必须非空且attachToRoot为true，</div><div class="line">                if (TAG_MERGE.equals(name)) &#123;</div><div class="line">                    if (root == null || !attachToRoot) &#123;</div><div class="line">                        throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</div><div class="line">                                + &quot;ViewGroup root and attachToRoot=true&quot;);</div><div class="line">                    &#125;</div><div class="line">                    //递归解析</div><div class="line">                    rInflate(parser, root, inflaterContext, attrs, false);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // Temp is the root view that was found in the xml根据节点创建view</div><div class="line">                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);</div><div class="line"></div><div class="line">                    ViewGroup.LayoutParams params = null;</div><div class="line">。。。</div><div class="line">                        // Create layout params that match root, if supplied  生成合适的layout params</div><div class="line">                        params = root.generateLayoutParams(attrs);</div><div class="line">                        if (!attachToRoot) &#123;</div><div class="line">                            // Set the layout params for temp if we are not</div><div class="line">                            // attaching. (If we are, we use addView, below)</div><div class="line">                            temp.setLayoutParams(params);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    // Inflate all children under temp against its context. 继续递归</div><div class="line">                    rInflateChildren(parser, temp, attrs, true);</div><div class="line"></div><div class="line">                    // We are supposed to attach all the views we found (int temp)</div><div class="line">                    // to root. Do that now.</div><div class="line">                    if (root != null &amp;&amp; attachToRoot) &#123;</div><div class="line">                //root非空且attachToRoot=true则将xml文件的root view加到形参提供的root里</div><div class="line">                        root.addView(temp, params);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // Decide whether to return the root that was passed in or the</div><div class="line">                    // top view found in xml.</div><div class="line">                    if (root == null || !attachToRoot) &#123;</div><div class="line">                    //这里就直接返回解析的view</div><div class="line">                        result = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">        。。。</div><div class="line"></div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>所以从上面的代码可以总结一下：</p>
<ul>
<li><p>inflate(xmlId, null); 只创建temp的View，然后直接返回temp。</p>
</li>
<li><p>inflate(xmlId, parent); 创建temp的View，然后执行root.addView(temp, params);最后返回root。</p>
</li>
<li><p>inflate(xmlId, parent, false); 创建temp的View，然后执行temp.setLayoutParams(params);然后再返回temp。</p>
</li>
<li><p>inflate(xmlId, parent, true); 创建temp的View，然后执行root.addView(temp, params);最后返回root。</p>
</li>
<li><p>inflate(xmlId, null, false); 只创建temp的View，然后直接返回temp。</p>
</li>
<li><p>inflate(xmlId, null, true); 只创建temp的View，然后直接返回temp。</p>
</li>
</ul>
<p>这里也引出了一个问题，就是有时候我们通过View的<code>layout_width</code>和<code>layout_height</code>来设置view的大小，然后通过<code>inflate</code>解析之后发现并不管用，这里的代码就可以说明问题，其实这两个属性并不是用来设置view的大小的，而是用来设置view在ViewGroup中的大小，(有点晕？后面会有专门的一篇来说这个)，所以叫做<code>layout_width</code>而不是直接叫做<code>width</code>。简单举个例子说一下：</p>
<ul>
<li><code>mInflater.inflate(R.layout.textview_layout, null)</code>不能正确处理我们设置的宽和高是因为layout_width，layout_height是相对了父级设置的，而此temp的getLayoutParams为null。</li>
<li><code>mInflater.inflate(R.layout.textview_layout, parent)</code>能正确显示我们设置的宽高是因为我们的View在设置setLayoutParams时<code>params = root.generateLayoutParams(attrs)</code>不为空。 </li>
</ul>
<p>其他就不多说了，也就是说只有这是了父布局才能正确的显示宽和高，同时可以注意到，在<code>Activity</code>中指定布局宽高的时候是可以正确显示的，这不正好说明了还存在更底层的一层id为content的FrameLayout吗。</p>
<p>参考：</p>
<p><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/49681321" target="_blank" rel="external">【凯子哥带你学Framework】Activity界面显示全解析</a></p>
<p><a href="http://blog.csdn.net/yanbober/article/details/45970721" target="_blank" rel="external"> Android应用setContentView与LayoutInflater加载解析机制源码分析</a></p>
<p><a href="http://grepcode.com/file/repo1.maven.org/maven2/org.robolectric/android-all/5.0.0_r2-robolectric-1/com/android/internal/policy/impl/PhoneWindow.java#PhoneWindow.generateLayout%28com.android.internal.policy.impl.PhoneWindow.DecorView%29" target="_blank" rel="external">PhoneWindow源码</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/07/09/Java/" class="prev">PREV</a><a href="/2016/07/09/Android Binder 浅析/" class="next">NEXT</a></div><div data-thread-key="2016/07/09/聊聊从setContentView到界面的显示/" data-title="聊聊从setContentView到界面的显示" data-url="http://yoursite.com/2016/07/09/聊聊从setContentView到界面的显示/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"70kg"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">70kg</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-81769413-1",'auto');ga('send','pageview');</script></body></html>