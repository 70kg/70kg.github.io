<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Volley源码解析 · 70kg</title><meta name="description" content="Volley源码解析 - 70kg"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="70kg"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/应聘Android开发工程师_王鹏.pdf" target="_self" class="nav-list-link">RESUME</a></li><li class="nav-list-item"><a href="/book/" target="_self" class="nav-list-link">BOOKS</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Volley源码解析</h1><div class="post-info">Jul 9, 2016</div><div class="post-content"><p>&emsp;&emsp;这篇博客想写挺久的了，因为之前接触到网络请求的第一个流行的库就是<code>Volley</code>，在使用的时候也感觉到它的功能和拓展性的强大，但是一直没有去探究他内部的流程，同时可以发现网上对<code>Volley</code>这个框架设计的评价都非常好，所以去了解内部的实现还是很有必要的。下面开始吧。<a id="more"></a></p>
<p>&emsp;&emsp;先从最开始怎么去使用说起，最常见的使用方式就是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">RequestQueue queue = Volley.newRequestQueue(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        StringRequest request = <span class="keyword">new</span> StringRequest(<span class="string">"http://70kg.info"</span>, <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        queue.add(request);</div></pre></td></tr></table></figure>
<p>先去创建一个<code>RequestQueue</code>，然后在去创建一个<code>request</code>，最后加入到队列里面就可以了。使用也是相当的方便清晰。那就从<code>RequestQueue</code>入手，看看这个队列是什么样的。</p>
<h4 id="RequestQueue"><a href="#RequestQueue" class="headerlink" title="RequestQueue"></a>RequestQueue</h4><p>这个类是在<code>toolbox</code>包里面，都是一下已经给我们实现一些功能的类，方便我们去使用。<code>Volley.newRequestQueue(this);</code>最终走到了这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span> </span>&#123;</div><div class="line">        <span class="comment">//缓存目录</span></div><div class="line">        File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class="line">        String userAgent = <span class="string">"volley/0"</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String packageName = context.getPackageName();</div><div class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</div><div class="line">            userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</div><div class="line">        &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</div><div class="line">                stack = <span class="keyword">new</span> HurlStack();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Network network = <span class="keyword">new</span> BasicNetwork(stack);</div><div class="line"></div><div class="line">        RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</div><div class="line">        queue.start();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> queue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里可以看到还有个<code>userAgent</code>，在使用使用<code>HttpClientStack</code>也就是API<9,使用`androidhttpclient`的时候使用，具体是什么会在下面的参考中给出，和本文关系不是很大，只要明白在>=9的时候使用了<code>HurlStack</code>，内部是<code>HttpURLConnection</code>就差不多了。下面还有个<code>Network</code>，是根据传进去的<code>stack</code>来选择不同的处理网络方式，后面会说。最重要的就是下面两行，真正的<code>new RequestQueue</code>，然后<code>star</code>,进去看看：</9,使用`androidhttpclient`的时候使用，具体是什么会在下面的参考中给出，和本文关系不是很大，只要明白在></p>
<p>经过各种重载构造函数，走到了这个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,</span></span></div><div class="line">           ResponseDelivery delivery) &#123;</div><div class="line">       <span class="comment">//默认缓存</span></div><div class="line">       mCache = cache;</div><div class="line">       <span class="comment">//处理网络的</span></div><div class="line">       mNetwork = network;</div><div class="line">       <span class="comment">//一个NetworkDispatcher数组，默认大小4</span></div><div class="line">       mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</div><div class="line">       <span class="comment">//一个ExecutorDelivery对象</span></div><div class="line">       mDelivery = delivery;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>然后就是去看<code>start</code>方法了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        stop();  </div><div class="line">        <span class="comment">//一个缓存调度线程</span></div><div class="line">        mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class="line">        mCacheDispatcher.start();</div><div class="line">        <span class="comment">//默认4个网络调度线程</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">            NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class="line">                    mCache, mDelivery);</div><div class="line">            mDispatchers[i] = networkDispatcher;</div><div class="line">            networkDispatcher.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>所以当我们新建了一个<code>RequestQueue</code>之后，其实是启动了5个线程在跑。接下来就是<code>queue.add(request);</code>的时候了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Request <span class="title">add</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">        <span class="comment">//相当于设个tag为当前的queue</span></div><div class="line">        request.setRequestQueue(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</div><div class="line">        <span class="comment">//private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;Request&lt;?&gt;&gt;();正在进行，尚未完成请求的集合</span></div><div class="line">            mCurrentRequests.add(request);</div><div class="line">        &#125;</div><div class="line">       <span class="comment">//序列号 可以理解为加入的顺序</span></div><div class="line">        request.setSequence(getSequenceNumber());</div><div class="line">        <span class="comment">//添加个标记</span></div><div class="line">        request.addMarker(<span class="string">"add-to-queue"</span>);</div><div class="line"></div><div class="line">        <span class="comment">//不缓存，就直接加入网络队列去请求网络</span></div><div class="line">        <span class="keyword">if</span> (!request.shouldCache()) &#123;</div><div class="line">            mNetworkQueue.add(request);</div><div class="line">            <span class="keyword">return</span> request;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</div><div class="line">            String cacheKey = request.getCacheKey();</div><div class="line">            <span class="comment">//维护了一个等待请求的集合，如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列。</span></div><div class="line">            <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class="line">            <span class="comment">//前面有相同的了 等待</span></div><div class="line">                Queue&lt;Request&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class="line">                <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</div><div class="line">                    stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&gt;();</div><div class="line">                &#125;</div><div class="line">                stagedRequests.add(request);</div><div class="line">                mWaitingRequests.put(cacheKey, stagedRequests);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//否则加入缓存队列</span></div><div class="line">                mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</div><div class="line">                mCacheQueue.add(request);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> request;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="CacheDispatcher"><a href="#CacheDispatcher" class="headerlink" title="CacheDispatcher"></a>CacheDispatcher</h4><p>Volley默认都是可以缓存的，而处理缓存的是<code>CacheDispatcher</code>，这是一个线程，那就可以去<code>Run</code>方法看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//线程优先级</span></div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        <span class="comment">//初始化缓存</span></div><div class="line">        mCache.initialize();</div><div class="line">         <span class="comment">//开启无限循环</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//从缓存队列中获取第一个</span></div><div class="line">                <span class="keyword">final</span> Request request = mCacheQueue.take();</div><div class="line">                request.addMarker(<span class="string">"cache-queue-take"</span>);</div><div class="line">               <span class="comment">//取消了  不去处理</span></div><div class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</div><div class="line">             request.finish(<span class="string">"cache-discard-canceled"</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">               <span class="comment">//从缓存中检所</span></div><div class="line">                Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">                    request.addMarker(<span class="string">"cache-miss"</span>);</div><div class="line">                    <span class="comment">//没找到  加入网络队列去请求</span></div><div class="line">                    mNetworkQueue.put(request);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//缓存过期了 也是网络请求</span></div><div class="line">                <span class="keyword">if</span> (entry.isExpired()) &#123;</div><div class="line">                    request.addMarker(<span class="string">"cache-hit-expired"</span>);</div><div class="line">                    request.setCacheEntry(entry);</div><div class="line">                    mNetworkQueue.put(request);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">//获取到正常可用的缓存的request</span></div><div class="line">                request.addMarker(<span class="string">"cache-hit"</span>);</div><div class="line">                <span class="comment">//转换成一个NetworkResponse</span></div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">                        <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line">                request.addMarker(<span class="string">"cache-hit-parsed"</span>);</div><div class="line">                <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</div><div class="line">                    <span class="comment">//mDelivery使用handler分发到主线程</span></div><div class="line">                    mDelivery.postResponse(request, response);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//检验新鲜度 request.addMarker("cache-hit-refresh-needed");</span></div><div class="line">                    request.setCacheEntry(entry);</div><div class="line">                    response.intermediate = <span class="keyword">true</span>;</div><div class="line">                   <span class="comment">//分发  再去加入网络队列检验新鲜度</span></div><div class="line">                    mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                mNetworkQueue.put(request);</div><div class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        </div><div class="line">                <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>整个过程差不多都注释了，再来个大招，非常棒的流程图：</p>
<p><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/CacheDispatcher-run-flow-chart.png" alt=""></p>
<h4 id="CacheDispatcher-1"><a href="#CacheDispatcher-1" class="headerlink" title="CacheDispatcher"></a>CacheDispatcher</h4><p>说完缓存分发，还有网络分发，还是看run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">//线程优先级</span></div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        Request request;</div><div class="line">        <span class="comment">//循环取</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              <span class="comment">//取一个</span></div><div class="line">                request = mQueue.take();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                <span class="keyword">if</span> (mQuit) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                request.addMarker(<span class="string">"network-queue-take"</span>);</div><div class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;                  request.finish(<span class="string">"network-discard-cancelled"</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Tag the request (if API &gt;= 14)</span></div><div class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</div><div class="line">                    TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 执行网络请求</span></div><div class="line">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">                request.addMarker(<span class="string">"network-http-complete"</span>);</div><div class="line"></div><div class="line">                <span class="comment">//返回304并且已经处理过这个，跳过</span></div><div class="line">                <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                    request.finish(<span class="string">"not-modified"</span>);</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">               <span class="comment">//解析成Response</span></div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">                request.addMarker(<span class="string">"network-parse-complete"</span>);</div><div class="line">                <span class="comment">//请求到之后缓存</span></div><div class="line">                <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</div><div class="line">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">               request.addMarker(<span class="string">"network-cache-written"</span>);</div><div class="line">                &#125;</div><div class="line">                request.markDelivered();</div><div class="line">                <span class="comment">//分发到主线程</span></div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</div><div class="line">                parseAndDeliverNetworkError(request, volleyError);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</div><div class="line">                mDelivery.postError(request, <span class="keyword">new</span> VolleyError(e));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>整个流程和缓存差不多，再来一个图：<br><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/NetworkDispatcher-run-flow-chart.png" alt=""></p>
<h4 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h4><p>在上面的网络分发中看到了主要就是<code>mNetwork.performRequest(request);</code>这句话执行了真正的网络请求操作，而<code>Network</code>是一个接口，实现类是在创建<code>RequestQueue</code>时候创建的<code>BasicNetwork</code>，看看这个里面的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicNetwork</span> <span class="keyword">implements</span> <span class="title">Network</span> </span>&#123;</div><div class="line">       <span class="comment">//...省略看不懂的网络操作</span></div><div class="line">         <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</div><div class="line">     <span class="comment">//...</span></div><div class="line">     <span class="comment">//这就是前面根据版本不同选择不同的网络处理方式</span></div><div class="line">     httpResponse = mHttpStack.performRequest(request, headers);</div><div class="line">    </div><div class="line">    <span class="comment">//....</span></div><div class="line">    <span class="comment">//组装返回值</span></div><div class="line">     networkResponse = <span class="keyword">new</span> NetworkResponse(statusCode, responseContents,responseHeaders, <span class="keyword">false</span>);</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">       </div><div class="line">       <span class="comment">//省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到现在请求的结果也回来了，那么具体是怎么去分发<code>Response</code>的呢？主要是这句话<code>mDelivery.postResponse(request, response);</code><br>而<code>ResponseDelivery</code>是一个接口，实现类是创建<code>RequestQueue</code>的时候创建的<code>public class ExecutorDelivery implements ResponseDelivery</code>，看一下它的<code>postResponse</code>方法，主要就是<code>mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, null));</code>可以理解为向主线程发送了一个<code>Runnable</code>而在这个<code>Runnable</code>里面呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mResponse.isSuccess()) &#123;</div><div class="line">              mRequest.deliverResponse(mResponse.result);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">              mRequest.deliverError(mResponse.error);</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>第一个方法是不是就比较熟悉了，就是自定义<code>Request</code>的时候要重写的两个方法之一，一般就直接<code>mListener.onResponse(response);</code>就可以了，而错误的分发<code>Request</code>基类已经实现完了。<br>到这，基本的过程差不多了，还有重试策略和缓存的具体没写，大概就这样吧。</p>
<p>参考：</p>
<p><a href="http://www.cnblogs.com/tianzhijiexian/p/4264468.html" target="_blank" rel="external">详细解读Volley（五）—— 通过源码来分析业务流程</a></p>
<p><a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">Volley 源码解析</a></p>
<p><a href="http://bxbxbai.github.io/2014/12/24/read-volley-source-code/" target="_blank" rel="external">Volley源码分析</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/07/09/Android Binder 浅析/" class="prev">上一篇</a><a href="/2016/07/09/触摸事件/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = '70kg-info';
var disqus_identifier = '2016/07/09/Volley源码解析/';
var disqus_title = 'Volley源码解析';
var disqus_url = 'http://yoursite.com/2016/07/09/Volley源码解析/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//70kg-info.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">70kg</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-81769413-1",'auto');ga('send','pageview');</script></body></html>