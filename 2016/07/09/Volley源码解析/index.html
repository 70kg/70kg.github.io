<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Volley源码解析 · 70kg</title><meta name="description" content="Volley源码解析 - 70kg"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="70kg"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/2790907881/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/70kg" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Volley源码解析</h1><div class="post-info">Jul 9, 2016</div><div class="post-content"><p>&emsp;&emsp;这篇博客想写挺久的了，因为之前接触到网络请求的第一个流行的库就是<code>Volley</code>，在使用的时候也感觉到它的功能和拓展性的强大，但是一直没有去探究他内部的流程，同时可以发现网上对<code>Volley</code>这个框架设计的评价都非常好，所以去了解内部的实现还是很有必要的。下面开始吧。<a id="more"></a></p>
<p>&emsp;&emsp;先从最开始怎么去使用说起，最常见的使用方式就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">RequestQueue queue = Volley.newRequestQueue(this);</div><div class="line"></div><div class="line">        StringRequest request = new StringRequest(&quot;http://70kg.info&quot;, new Response.Listener&lt;String&gt;() &#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onResponse(String response) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;, new Response.ErrorListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onErrorResponse(VolleyError error) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        queue.add(request);</div></pre></td></tr></table></figure>
<p>先去创建一个<code>RequestQueue</code>，然后在去创建一个<code>request</code>，最后加入到队列里面就可以了。使用也是相当的方便清晰。那就从<code>RequestQueue</code>入手，看看这个队列是什么样的。</p>
<p>###RequestQueue<br>这个类是在<code>toolbox</code>包里面，都是一下已经给我们实现一些功能的类，方便我们去使用。<code>Volley.newRequestQueue(this);</code>最终走到了这里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static RequestQueue newRequestQueue(Context context, HttpStack stack) &#123;</div><div class="line">        //缓存目录</div><div class="line">        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class="line">        String userAgent = &quot;volley/0&quot;;</div><div class="line">        try &#123;</div><div class="line">            String packageName = context.getPackageName();</div><div class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);</div><div class="line">            userAgent = packageName + &quot;/&quot; + info.versionCode;</div><div class="line">        &#125; catch (NameNotFoundException e) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (stack == null) &#123;</div><div class="line">            if (Build.VERSION.SDK_INT &gt;= 9) &#123;</div><div class="line">                stack = new HurlStack();</div><div class="line">            &#125; else &#123;</div><div class="line">                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Network network = new BasicNetwork(stack);</div><div class="line"></div><div class="line">        RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);</div><div class="line">        queue.start();</div><div class="line"></div><div class="line">        return queue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里可以看到还有个<code>userAgent</code>，在使用使用<code>HttpClientStack</code>也就是API<9,使用`androidhttpclient`的时候使用，具体是什么会在下面的参考中给出，和本文关系不是很大，只要明白在>=9的时候使用了<code>HurlStack</code>，内部是<code>HttpURLConnection</code>就差不多了。下面还有个<code>Network</code>，是根据传进去的<code>stack</code>来选择不同的处理网络方式，后面会说。最重要的就是下面两行，真正的<code>new RequestQueue</code>，然后<code>star</code>,进去看看：</9,使用`androidhttpclient`的时候使用，具体是什么会在下面的参考中给出，和本文关系不是很大，只要明白在></p>
<p>经过各种重载构造函数，走到了这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public RequestQueue(Cache cache, Network network, int threadPoolSize,</div><div class="line">           ResponseDelivery delivery) &#123;</div><div class="line">       //默认缓存</div><div class="line">       mCache = cache;</div><div class="line">       //处理网络的</div><div class="line">       mNetwork = network;</div><div class="line">       //一个NetworkDispatcher数组，默认大小4</div><div class="line">       mDispatchers = new NetworkDispatcher[threadPoolSize];</div><div class="line">       //一个ExecutorDelivery对象</div><div class="line">       mDelivery = delivery;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>然后就是去看<code>star</code>方法了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void start() &#123;</div><div class="line">        stop();  </div><div class="line">        //一个缓存调度线程</div><div class="line">        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class="line">        mCacheDispatcher.start();</div><div class="line">        //默认4个网络调度线程</div><div class="line">        for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class="line">                    mCache, mDelivery);</div><div class="line">            mDispatchers[i] = networkDispatcher;</div><div class="line">            networkDispatcher.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>所以当我们新建了一个<code>RequestQueue</code>之后，其实是启动了5个线程在跑。接下来就是<code>queue.add(request);</code>的时候了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public Request add(Request request) &#123;</div><div class="line">        //相当于设个tag为当前的queue</div><div class="line">        request.setRequestQueue(this);</div><div class="line">        synchronized (mCurrentRequests) &#123;</div><div class="line">        //private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;Request&lt;?&gt;&gt;();正在进行，尚未完成请求的集合</div><div class="line">            mCurrentRequests.add(request);</div><div class="line">        &#125;</div><div class="line">       //序列号 可以理解为加入的顺序</div><div class="line">        request.setSequence(getSequenceNumber());</div><div class="line">        //添加个标记</div><div class="line">        request.addMarker(&quot;add-to-queue&quot;);</div><div class="line"></div><div class="line">        //不缓存，就直接加入网络队列去请求网络</div><div class="line">        if (!request.shouldCache()) &#123;</div><div class="line">            mNetworkQueue.add(request);</div><div class="line">            return request;</div><div class="line">        &#125;</div><div class="line">        synchronized (mWaitingRequests) &#123;</div><div class="line">            String cacheKey = request.getCacheKey();</div><div class="line">            //维护了一个等待请求的集合，如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列。</div><div class="line">            if (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class="line">            //前面有相同的了 等待</div><div class="line">                Queue&lt;Request&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class="line">                if (stagedRequests == null) &#123;</div><div class="line">                    stagedRequests = new LinkedList&lt;Request&gt;();</div><div class="line">                &#125;</div><div class="line">                stagedRequests.add(request);</div><div class="line">                mWaitingRequests.put(cacheKey, stagedRequests);</div><div class="line">            &#125; else &#123;</div><div class="line">                //否则加入缓存队列</div><div class="line">                mWaitingRequests.put(cacheKey, null);</div><div class="line">                mCacheQueue.add(request);</div><div class="line">            &#125;</div><div class="line">            return request;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>###CacheDispatcher<br>Volley默认都是可以缓存的，而处理缓存的是<code>CacheDispatcher</code>，这是一个线程，那就可以去<code>Run</code>方法看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public void run() &#123;</div><div class="line">        //线程优先级</div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        //初始化缓存</div><div class="line">        mCache.initialize();</div><div class="line">         //开启无限循环</div><div class="line">        while (true) &#123;</div><div class="line">            try &#123;</div><div class="line">                //从缓存队列中获取第一个</div><div class="line">                final Request request = mCacheQueue.take();</div><div class="line">                request.addMarker(&quot;cache-queue-take&quot;);</div><div class="line">               //取消了  不去处理</div><div class="line">                if (request.isCanceled()) &#123;</div><div class="line">             request.finish(&quot;cache-discard-canceled&quot;);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">               //从缓存中检所</div><div class="line">                Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line">                if (entry == null) &#123;</div><div class="line">                    request.addMarker(&quot;cache-miss&quot;);</div><div class="line">                    //没找到  加入网络队列去请求</div><div class="line">                    mNetworkQueue.put(request);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                //缓存过期了 也是网络请求</div><div class="line">                if (entry.isExpired()) &#123;</div><div class="line">                    request.addMarker(&quot;cache-hit-expired&quot;);</div><div class="line">                    request.setCacheEntry(entry);</div><div class="line">                    mNetworkQueue.put(request);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                //获取到正常可用的缓存的request</div><div class="line">                request.addMarker(&quot;cache-hit&quot;);</div><div class="line">                //转换成一个NetworkResponse</div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">                        new NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line">                request.addMarker(&quot;cache-hit-parsed&quot;);</div><div class="line">                if (!entry.refreshNeeded()) &#123;</div><div class="line">                    //mDelivery使用handler分发到主线程</div><div class="line">                    mDelivery.postResponse(request, response);</div><div class="line">                &#125; else &#123;</div><div class="line">                    //检验新鲜度 request.addMarker(&quot;cache-hit-refresh-needed&quot;);</div><div class="line">                    request.setCacheEntry(entry);</div><div class="line">                    response.intermediate = true;</div><div class="line">                   //分发  再去加入网络队列检验新鲜度</div><div class="line">                    mDelivery.postResponse(request, response, new Runnable() &#123;</div><div class="line">                        @Override</div><div class="line">                        public void run() &#123;</div><div class="line">                            try &#123;</div><div class="line">                                mNetworkQueue.put(request);</div><div class="line">                            &#125; catch (InterruptedException e) &#123;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">        </div><div class="line">                if (mQuit) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>整个过程差不多都注释了，再来个大招，非常棒的流程图：</p>
<p><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/CacheDispatcher-run-flow-chart.png" alt=""></p>
<p>###CacheDispatcher<br>说完缓存分发，还有网络分发，还是看run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public void run() &#123;</div><div class="line">       //线程优先级</div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        Request request;</div><div class="line">        //循环取</div><div class="line">        while (true) &#123;</div><div class="line">            try &#123;</div><div class="line">              //取一个</div><div class="line">                request = mQueue.take();</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                if (mQuit) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                request.addMarker(&quot;network-queue-take&quot;);</div><div class="line">                if (request.isCanceled()) &#123;                  request.finish(&quot;network-discard-cancelled&quot;);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Tag the request (if API &gt;= 14)</div><div class="line">                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</div><div class="line">                    TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // 执行网络请求</div><div class="line">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">                request.addMarker(&quot;network-http-complete&quot;);</div><div class="line"></div><div class="line">                //返回304并且已经处理过这个，跳过</div><div class="line">                if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                    request.finish(&quot;not-modified&quot;);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">               //解析成Response</div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">                request.addMarker(&quot;network-parse-complete&quot;);</div><div class="line">                //请求到之后缓存</div><div class="line">                if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</div><div class="line">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">               request.addMarker(&quot;network-cache-written&quot;);</div><div class="line">                &#125;</div><div class="line">                request.markDelivered();</div><div class="line">                //分发到主线程</div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; catch (VolleyError volleyError) &#123;</div><div class="line">                parseAndDeliverNetworkError(request, volleyError);</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</div><div class="line">                mDelivery.postError(request, new VolleyError(e));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>整个流程和缓存差不多，再来一个图：<br><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/NetworkDispatcher-run-flow-chart.png" alt=""></p>
<p>###Network<br>在上面的网络分发中看到了主要就是<code>mNetwork.performRequest(request);</code>这句话执行了真正的网络请求操作，而<code>Network</code>是一个接口，实现类是在创建<code>RequestQueue</code>时候创建的<code>BasicNetwork</code>，看看这个里面的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class BasicNetwork implements Network &#123;</div><div class="line">       //...省略看不懂的网络操作</div><div class="line">         @Override</div><div class="line">    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123;</div><div class="line">     //...</div><div class="line">     //这就是前面根据版本不同选择不同的网络处理方式</div><div class="line">     httpResponse = mHttpStack.performRequest(request, headers);</div><div class="line">    </div><div class="line">    //....</div><div class="line">    //组装返回值</div><div class="line">     networkResponse = new NetworkResponse(statusCode, responseContents,responseHeaders, false);</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">       </div><div class="line">       //省略</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到现在请求的结果也回来了，那么具体是怎么去分发<code>Response</code>的呢？主要是这句话<code>mDelivery.postResponse(request, response);</code><br>而<code>ResponseDelivery</code>是一个接口，实现类是创建<code>RequestQueue</code>的时候创建的<code>public class ExecutorDelivery implements ResponseDelivery</code>，看一下它的<code>postResponse</code>方法，主要就是<code>mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, null));</code>可以理解为向主线程发送了一个<code>Runnable</code>而在这个<code>Runnable</code>里面呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (mResponse.isSuccess()) &#123;</div><div class="line">              mRequest.deliverResponse(mResponse.result);</div><div class="line">          &#125; else &#123;</div><div class="line">              mRequest.deliverError(mResponse.error);</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>第一个方法是不是就比较熟悉了，就是自定义<code>Request</code>的时候要重写的两个方法之一，一般就直接<code>mListener.onResponse(response);</code>就可以了，而错误的分发<code>Request</code>基类已经实现完了。<br>到这，基本的过程差不多了，还有重试策略和缓存的具体没写，大概就这样吧。</p>
<p>参考：</p>
<p><a href="http://www.cnblogs.com/tianzhijiexian/p/4264468.html" target="_blank" rel="external">详细解读Volley（五）—— 通过源码来分析业务流程</a></p>
<p><a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">Volley 源码解析</a></p>
<p><a href="http://bxbxbai.github.io/2014/12/24/read-volley-source-code/" target="_blank" rel="external">Volley源码分析</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/07/09/View的绘制过程/" class="prev">PREV</a><a href="/2016/07/09/触摸事件/" class="next">NEXT</a></div><div data-thread-key="2016/07/09/Volley源码解析/" data-title="Volley源码解析" data-url="http://yoursite.com/2016/07/09/Volley源码解析/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"70kg"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">70kg</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-81769413-1",'auto');ga('send','pageview');</script></body></html>