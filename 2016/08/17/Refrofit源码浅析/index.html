<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Retrofit源码浅析 · 70kg</title><meta name="description" content="Retrofit源码浅析 - 70kg"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="70kg"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/2790907881/profile?topnav=1&amp;wvr=6&amp;is_all=1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/70kg" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/book/" target="_self" class="nav-list-link">BOOKS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Retrofit源码浅析</h1><div class="post-info">Aug 17, 2016</div><div class="post-content"><p> 这篇主要会走读一下<code>Retrofit</code>的源码，解析一下里面遇到的一些设计模式，网络请求的过程等。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>从创建<code>Retrofit</code>开始，看一下常见的创建<code>Retrofit</code>的实例的方式<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();</div><div class="line">        interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</div><div class="line">        OkHttpClient client = new OkHttpClient.Builder()</div><div class="line">                .addInterceptor(interceptor)</div><div class="line">                .retryOnConnectionFailure(true)</div><div class="line">                .connectTimeout(15, TimeUnit.SECONDS)</div><div class="line">                .addNetworkInterceptor(createHeaderInterceptor())</div><div class="line">                .build();</div><div class="line">                </div><div class="line">Retrofit retrofit = new Retrofit.Builder()</div><div class="line">                .baseUrl(BuildConfig.BASE_API_URL)</div><div class="line">                .client(client)</div><div class="line">                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div><div class="line">                .addConverterFactory(BolomeGsonConverterFactory.create())</div><div class="line">                .build();</div><div class="line">          Net net = retrofit.create(Net.class)</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出，<code>Retrofit</code>并没有去真正的执行网络请求，还是交给了<code>OkHttp</code>来进行实现，<code>Retrofit</code>可以看作的对<code>OkHttp</code>的一层非常棒的封装，<code>Retrofit</code>的关注点是在如何让你更快捷更灵活的去进行网络请求。如果你使用过<code>Retrofit</code>的话，你也会明白用<code>Retrofit</code>去实现一次网络请求是多方便的事情。</p>
<h3 id="retrofit-create"><a href="#retrofit-create" class="headerlink" title="retrofit.create"></a><code>retrofit.create</code></h3><p>从<code>Net net = retrofit.create(Net.class)</code>这里开始入手，用过<code>Retrofit</code>的几乎都知道<code>Retrofit</code>是用了动态代理，动态代理说简单点就是动态的去生成接口的实现类，也可以在原始的结果返回前对参数或者结果进行修改，这个特性也使得一些<code>Hook</code>框架大量使用了动态代理，比如很著名的360的<code>DroidPlugin</code>。有点扯远了，还是去源码里面去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</div><div class="line">  ...</div><div class="line">  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">      new InvocationHandler() &#123;</div><div class="line">        private final Platform platform = Platform.get();</div><div class="line"></div><div class="line">        @Override public Object invoke(Object proxy, Method method, Object... args)</div><div class="line">            throws Throwable &#123;</div><div class="line">          ...</div><div class="line">          ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">          OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">          return serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里省略了一下判断的逻辑，但是主要的就是最后的三行代码，从方法的签名来看，是传进来一个接口类，返回一个接口类型的实例，但是这个实例的具体实现类型是由<code>serviceMethod.callAdapter.adapt</code>方法动态决定了，而且这个接口里面的每一次方法调用，都会进入这个<code>invoke</code>方法，也就是由接口的实现类去完成功能。例如，<code>Retrofit</code>默认的请求方式是<code>Call&lt;T&gt;</code>,这里默认的实现类就是<code>ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt;</code>，而在这个类里面又是用代理类的方式去交给<code>Okhttp</code>的<code>call</code>去执行真正的请求，这个就是后面再说了。</p>
<h3 id="ServiceMethod"><a href="#ServiceMethod" class="headerlink" title="ServiceMethod"></a><code>ServiceMethod</code></h3><p>这个类主要是储存了请求的信息和<code>Retrofit</code>的配置信息以及对请求注解的解析生成正常的地址和请求。</p>
<h3 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a><code>OkHttpCall</code></h3><p>第二行<code>OkHttpCall</code>可以看成是<code>OkHttp</code>的<code>call</code>在<code>Retrofit</code>层面的一次封装。从上面一步看到，把请求参数和配置信息交给了这个<code>OkHttpCall</code>，然后让<code>OkHttp</code>去执行请求操作。</p>
<h3 id="callAdapter"><a href="#callAdapter" class="headerlink" title="callAdapter"></a><code>callAdapter</code></h3><p>不知道该怎么去具体描述这个类的意思，可以理解成将请求转换成不同的请求形式，例如默认的<code>call</code>或者常见的<code>Rxjava</code>的<code>Observable&lt;T&gt;</code>的形式亦或者是<code>Agera</code>的<code>Supplier&lt;Result&lt;T&gt;&gt;</code>的形式等等。以<code>@drakeet</code>的<a href="https://github.com/drakeet/retrofit-agera-call-adapter" target="_blank" rel="external">retrofit-agera-call-adapter</a>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">public final class AgeraCallAdapterFactory extends CallAdapter.Factory &#123;</div><div class="line"></div><div class="line">    public static AgeraCallAdapterFactory create() &#123;</div><div class="line">        return new AgeraCallAdapterFactory();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private AgeraCallAdapterFactory() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">        ...</div><div class="line">        支持Supplier&lt;Result&lt;T&gt;&gt;形式</div><div class="line">            return new BodyCallAdapter(innerTypeOfInnerType);</div><div class="line">        &#125;</div><div class="line">        ...支持Supplier&lt;Result&lt;Response&lt;T&gt;&gt;&gt;形式</div><div class="line">        return new ResponseCallAdapter(responseType);</div><div class="line">    &#125;</div><div class="line">    private static class BodyCallAdapter implements CallAdapter&lt;Supplier&lt;?&gt;&gt; &#123;</div><div class="line"></div><div class="line">        private final Type responseType;</div><div class="line"></div><div class="line"></div><div class="line">        BodyCallAdapter(Type responseType) &#123;</div><div class="line">            this.responseType = responseType;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        @Override public Type responseType() &#123;</div><div class="line">            return responseType;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        @Override</div><div class="line">        public &lt;T&gt; Supplier&lt;Result&lt;T&gt;&gt; adapt(Call&lt;T&gt; call) &#123;</div><div class="line">            return new CallSupplier(call);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class CallSupplier&lt;T&gt; implements Supplier&lt;Result&lt;T&gt;&gt; &#123;</div><div class="line"></div><div class="line">    private final Call&lt;T&gt; originalCall;</div><div class="line"></div><div class="line"></div><div class="line">    CallSupplier(@NonNull final Call&lt;T&gt; call) &#123;</div><div class="line">        this.originalCall = checkNotNull(call);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @NonNull @Override public Result&lt;T&gt; get() &#123;</div><div class="line">        Result&lt;T&gt; result;</div><div class="line">        try &#123;</div><div class="line">            Response&lt;T&gt; response = originalCall.clone().execute();</div><div class="line">            //将Response转换成Result&lt;T&gt;的形式 因为数据要从Result中取，而不像默认的call那样直接走回调</div><div class="line">            if (response.isSuccessful()) &#123;</div><div class="line">                result = Result.success(response.body());</div><div class="line">            &#125; else &#123;</div><div class="line">                result = Result.failure(new HttpException(response));</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            result = Result.failure(e);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码没太多难度，看看就明白了。也是非常棒的自定义<code>CallAdapter</code>教程。</p>
<h3 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a><code>enqueue</code></h3><p>异步请求的时候是这个样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mNet.getLiveShows(20, 1).enqueue(new Callback&lt;LiveBlock&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onResponse(Call&lt;LiveBlock&gt; call, Response&lt;LiveBlock&gt; response) &#123;</div><div class="line">               </div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onFailure(Call&lt;LiveBlock&gt; call, Throwable t) &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure>
<p>而<code>getLiveShows</code>返回的<code>call</code>其实是上面说的<code>ExecutorCallbackCall</code>，这个的<code>enqueue</code>是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">      if (callback == null) throw new NullPointerException(&quot;callback == null&quot;);</div><div class="line"></div><div class="line">      delegate.enqueue(new Callback&lt;T&gt;() &#123;</div><div class="line">        @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</div><div class="line">          callbackExecutor.execute(new Runnable() &#123;</div><div class="line">            @Override public void run() &#123;</div><div class="line">              if (delegate.isCanceled()) &#123;</div><div class="line">                // Emulate OkHttp&apos;s behavior of throwing/delivering an IOException on cancellation.</div><div class="line">                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">              &#125; else &#123;</div><div class="line">                callback.onResponse(ExecutorCallbackCall.this, response);</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</div><div class="line">          callbackExecutor.execute(new Runnable() &#123;</div><div class="line">            @Override public void run() &#123;</div><div class="line">              callback.onFailure(ExecutorCallbackCall.this, t);</div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用了<code>delegate.enqueue</code>这个<code>delegate</code>就是上面说到的<code>OkHttpCall</code>看这个里面的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">call.enqueue(new okhttp3.Callback() &#123;</div><div class="line">      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)</div><div class="line">          throws IOException &#123;</div><div class="line">        Response&lt;T&gt; response;</div><div class="line">        try &#123;</div><div class="line">          response = parseResponse(rawResponse);</div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">          callFailure(e);</div><div class="line">          return;</div><div class="line">        &#125;</div><div class="line">        callSuccess(response);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public void onFailure(okhttp3.Call call, IOException e) &#123;</div><div class="line">        try &#123;</div><div class="line">          callback.onFailure(OkHttpCall.this, e);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      private void callFailure(Throwable e) &#123;</div><div class="line">        try &#123;</div><div class="line">          callback.onFailure(OkHttpCall.this, e);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      private void callSuccess(Response&lt;T&gt; response) &#123;</div><div class="line">        try &#123;</div><div class="line">          callback.onResponse(OkHttpCall.this, response);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;</div><div class="line">    ResponseBody rawBody = rawResponse.body();</div><div class="line">   .....//使用responseConverter.convert(body)</div><div class="line">      T body = serviceMethod.toResponse(catchingBody);</div><div class="line">      return Response.success(body, rawResponse);</div><div class="line">    ....</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>注意的是这里几个<code>call</code>的区别和三个<code>enqueue</code>的区别和作用</p>
<p>###<code>Converter</code><br>这个是用来将<code>RequestBody</code>和<code>responseBody</code>转换成相应的类型，具体去看看官方的<code>GsonConverterFactory</code>就可以了</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/09/30/Redux/" class="prev">PREV</a><a href="/2016/08/01/自定义控件学习笔记/" class="next">NEXT</a></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script><script>var cloudTieConfig = {
    url: document.location.href,
    sourceId: "2016/08/17/Refrofit源码浅析/",
    productKey: "f39e35695dd943529768f0f9c5440f14",
    target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);</script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">70kg</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-81769413-1",'auto');ga('send','pageview');</script></body></html>