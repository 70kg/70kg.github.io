<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>70kg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-27T13:55:04.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>70kg</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReactNative框架</title>
    <link href="http://yoursite.com/2017/08/27/ReactNative%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2017/08/27/ReactNative框架/</id>
    <published>2017-08-27T13:49:44.000Z</published>
    <updated>2017-08-27T13:55:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>slider地址：https:70kg.info/sliders/rn</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;slider地址：https:70kg.info/sliders/rn&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Handler</title>
    <link href="http://yoursite.com/2017/07/07/Handler/"/>
    <id>http://yoursite.com/2017/07/07/Handler/</id>
    <published>2017-07-07T00:28:33.000Z</published>
    <updated>2017-07-08T06:59:13.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="sendMessage的message保存在哪？"><a href="#sendMessage的message保存在哪？" class="headerlink" title="sendMessage的message保存在哪？"></a><code>sendMessage</code>的<code>message</code>保存在哪？</h4><p>保存在<code>MessageQueue</code>的<code>Message mMessages</code>成员变量中，通过<code>message</code>中的<code>next</code>维护一个单向链表。<code>message</code>本身一直在java层，和<code>native</code>的message没有直接操作关系。<code>looper</code>分发的消息都是通过<code>messagequeue.mMessages</code>间接获取的。当<code>sendMessage</code>时，进入<code>messagequeue</code>的<code>enqueueMessage</code>方法，<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Message p = mMessages;</div><div class="line">           <span class="keyword">boolean</span> needWake;</div><div class="line">           <span class="comment">//代表MessageQueue没有消息，或者msg的触发时间是队列中最早的</span></div><div class="line">           <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">               <span class="comment">// New head, wake up the event queue if blocked.</span></div><div class="line">               msg.next = p;</div><div class="line">               mMessages = msg;</div><div class="line">               <span class="comment">//mBlocked在空消息为true</span></div><div class="line">               needWake = mBlocked;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake up the event queue unless there is a barrier at the head of the queue and the message is the earliest asynchronous message in the queue.</span></div><div class="line">               needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">               Message prev;</div><div class="line">               <span class="comment">//遍历mMessages  找到合适位置插入msg</span></div><div class="line">               <span class="keyword">for</span> (;;) &#123;</div><div class="line">                   prev = p;</div><div class="line">                   p = p.next;</div><div class="line">                   <span class="comment">//当p==null 说明是链表的最后一个的next 要将msg插入到链表的最后，当when &lt; p.when说明后面还有时间没到的在排队，插入到这些的前面</span></div><div class="line">                   <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                       needWake = <span class="keyword">false</span>;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">               prev.next = msg;</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<p>接受消息在<code>messagequeue.next()</code>中，<code>nativePollOnce(ptr, nextPollTimeoutMillis);</code>方法是陷入到<code>native</code>层，一般<code>nextPollTimeoutMillis</code>都为0，说明要马上处理<code>message</code>，就会执行下面的语句。当没有消息时，<code>nextPollTimeoutMillis</code>为-1，表示无限阻塞，直到mEpollFd所监控的文件描述符发生了要监控的IO事件后或者监控时间超时后，线程就从epoll_wait返回了，也就会执行下面的操作，说明有新的message可以处理了。也就是说没消息的阻塞是在<code>nativePollOnce</code>实现的（具体是在native looper ::pollInner），但是这个阻塞不是忙等待，而是闲等待，让出CPU时间。</p>
<blockquote>
<p>A. Android应用程序的消息处理机制由消息循环、消息发送和消息处理三个部分组成的。</p>
<p>B. Android应用程序的主线程在进入消息循环过程前，会在内部创建一个Linux管道（Pipe），这个管道的作用是使得Android应用程序主线程在消息队列为空时可以进入空闲等待状态，并且使得当应用程序的消息队列有消息需要处理时唤醒应用程序的主线程。</p>
<p>C. Android应用程序的主线程进入空闲等待状态的方式实际上就是在管道的读端等待管道中有新的内容可读，具体来说就是是通过Linux系统的Epoll机制中的epoll_wait函数进行的。</p>
<p>D. 当往Android应用程序的消息队列中加入新的消息时，会同时往管道中的写端写入内容，通过这种方式就可以唤醒正在等待消息到来的应用程序主线程。</p>
<p>E. 当应用程序主线程在进入空闲等待前，会认为当前线程处理空闲状态，于是就会调用那些已经注册了的IdleHandler接口，使得应用程序有机会在空闲的时候处理一些事情。<br>—-&gt;<a href="http://blog.csdn.net/luoshengyang/article/details/6817933" target="_blank" rel="external">Android应用程序消息处理机制（Looper、Handler）分析</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;sendMessage的message保存在哪？&quot;&gt;&lt;a href=&quot;#sendMessage的message保存在哪？&quot; class=&quot;headerlink&quot; title=&quot;sendMessage的message保存在哪？&quot;&gt;&lt;/a&gt;&lt;code&gt;sendMessage&lt;/code&gt;的&lt;code&gt;message&lt;/code&gt;保存在哪？&lt;/h4&gt;&lt;p&gt;保存在&lt;code&gt;MessageQueue&lt;/code&gt;的&lt;code&gt;Message mMessages&lt;/code&gt;成员变量中，通过&lt;code&gt;message&lt;/code&gt;中的&lt;code&gt;next&lt;/code&gt;维护一个单向链表。&lt;code&gt;message&lt;/code&gt;本身一直在java层，和&lt;code&gt;native&lt;/code&gt;的message没有直接操作关系。&lt;code&gt;looper&lt;/code&gt;分发的消息都是通过&lt;code&gt;messagequeue.mMessages&lt;/code&gt;间接获取的。当&lt;code&gt;sendMessage&lt;/code&gt;时，进入&lt;code&gt;messagequeue&lt;/code&gt;的&lt;code&gt;enqueueMessage&lt;/code&gt;方法，
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>部署阿里云</title>
    <link href="http://yoursite.com/2017/06/28/%E9%83%A8%E7%BD%B2%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    <id>http://yoursite.com/2017/06/28/部署阿里云/</id>
    <published>2017-06-28T12:54:10.000Z</published>
    <updated>2017-06-28T12:54:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近搞了台阿里云的服务器，倒腾了半天，现在写点折腾的坑吧。<a id="more"></a></p>
<p>我之前是没点部署运维的经验，绝大部分时间都是在不停的Google。。目前上面部署了一个<code>node.js</code>写的<code>RESTful</code> 服务，当然还有配套的<code>mongoDb</code>等,一个<code>python</code>写的微信机器人，用的是图灵机器人的接口，还有几个脚本，都可以通过微信指令去调用，也是挺方便的。还有就是把博客从<code>GitHub</code>迁移到阿里云上面去了，速度提升杠杠的，因为迁移到了国内，备案是肯定的，好在阿里云有个代办备案的系统，除了等的时间长了点也没什么毛病(<del>除了备案本身</del>)。还有就是上面部署了个<code>git</code>服务器，这样也算是有个私人仓库了。这里面最折腾人的算是<code>nginx</code>了，因为之前对反向代理没点认识，一点不知道这玩意是干嘛的，只是按照教程一步步来，实在是累。后面慢慢理解点了，其实坑都是自己挖的，也只能自己去填了。下面随便说几个还记得的几点吧。</p>
<p>阿里云默认是root用户，权限太大，太危险。首先要去新建用户，以后都在这个用户下面操作。</p>
<p>刚登录的时候，是<code>Ubuntu</code>裸机，先使用<code>sudo apt-get update</code>更新一下，不然后面很多软件都装不上。</p>
<p>阿里云默认是不开放80和443端口的，所以你再怎么折腾也是连不上的，要先去控制台的安全组里面添加端口，后来我索性把全部端口都开放了，以后也懒得再来修改添加。</p>
<p>使用Mac通过<code>ssh</code>连到服务器之后，有时候会遇到中文乱码，<a href="https://blog.fazero.me/2015/09/04/Mac-iTerm2--chinese/" target="_blank" rel="external">https://blog.fazero.me/2015/09/04/Mac-iTerm2--chinese/</a> 看这个解决吧，后面我装了zsh之后，好像也不再需要上面的步骤了。</p>
<p>遇到<code>nginx</code>老是启动不了，也停止不了，搜了半天也解决不了，还是直接尝试<code>pkill nginx &amp;&amp; service nginx restart</code>吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近搞了台阿里云的服务器，倒腾了半天，现在写点折腾的坑吧。
    
    </summary>
    
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP简单理解</title>
    <link href="http://yoursite.com/2017/06/26/TCP-IP%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/06/26/TCP-IP简单理解/</id>
    <published>2017-06-26T14:38:46.000Z</published>
    <updated>2017-06-26T14:40:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近把《计算机网络》大致翻了一遍，主要是看了网络层往上的部分，包括网络层，运输层，应用层的一些协议和实现，还有一些网络安全，流媒体服务，无线网络等的介绍。对于应用开发，再往下的数据链路层和物理层也没太大的意义去研究。<a id="more"></a></p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层向上提供无连接的，尽最大努力交付的数据报服务。<br>网络层负责端到端的。<br>网络层主要是围绕IP来进行的，与IP协议配套使用的包括ARP:地址解析协议,ICMP：网际控制报文协议，IGMP:网际组管理协议。<br>IP地址的编码方式主要有：分类的IP地址，子网划分(CIDR)，构成超网。<br>网络层通过ARP协议将IP转换为数据链路层使用的物理mac地址。<br>IP数据报的首部包括源地址，目的地址，总长度，生存时间等信息。<br>路由器选择协议主要有RIP和OSPF,前者是基于距离向量的选择协议，间隔具体时间和相邻路由器交换路由信息，信息包括当前路由表(最短距离)和下一跳地址。OSPF是分布式链路状态协议，只有链路状态改变才使用泛洪法发送与所有相邻路由器的链路状态信息，信息包括本路由器于哪些路由器相邻和连接的”代价”。</p>
<h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>运输层负责端口到端口的通信。<br>熟悉的TCP/UDP是运输层的重要协议。<br><strong>UDP</strong></p>
<ul>
<li>无连接</li>
<li>尽最大努力交付，不保证可靠交付</li>
<li>面向报文:应用层交给UDP多大的报文，保留边界发送，如果过长，IP层负责分片。</li>
<li>没有拥塞控制</li>
<li>支持一对多，多对一，一对一的交互通信</li>
<li>部首小(源端口，目的端口，长度，检验和)</li>
</ul>
<p><strong>TCP</strong></p>
<ul>
<li>面向连接(建立连接-通信-释放连接)</li>
<li>只能是点对点</li>
<li>提供可靠交付(无差错，不丢失，不重复，按序到达)</li>
<li>提供全双工通信</li>
<li>面向字节流</li>
</ul>
<p>为保证可靠传输，使用以下协议:</p>
<ul>
<li>停止等待协议(效率低)</li>
<li>连续ARQ和滑动窗口</li>
</ul>
<p>部首：</p>
<ul>
<li>源端口和目的端口</li>
<li>序号:面向字节流，每一个字节都按顺序编号</li>
<li>确认号：期望收到对方下一个报文段的第一个字节的序号</li>
<li>数据偏移：也就是首部长度</li>
<li>紧急URG：尽快发送</li>
<li>确认ACK</li>
<li>推送PSH</li>
<li>复位RST</li>
<li>同步SYN</li>
<li>终止FIN</li>
<li>窗口：接收方允许对方发送的数据量</li>
<li>校验和</li>
<li>紧急指针</li>
<li>选项<br>以字节为单位的滑动窗口，三个指针描述<br>拥塞控制：慢开始，拥塞避免，快重传。<br>TCP建立连接的三次握手，最后一次确认是为了防止已失效的连接建立请求。<br>释放连接的四次握手</li>
</ul>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>面向应用进程<br>DNS域名解析：递归查询，迭代查询<br>FTP文件传输协议<br>TELNET远程终端协议<br>HTTP协议<br>SMTP简单邮件传送协议<br>等</p>
<h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><p>被动攻击和主动攻击</p>
<p>对称密钥<br>DES，IDEA<br>公钥密码<br>数字签名：报文鉴别，报文完整性，不可否认<br>SSL/TLS连接建立</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近把《计算机网络》大致翻了一遍，主要是看了网络层往上的部分，包括网络层，运输层，应用层的一些协议和实现，还有一些网络安全，流媒体服务，无线网络等的介绍。对于应用开发，再往下的数据链路层和物理层也没太大的意义去研究。
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Tinker补丁构建走读</title>
    <link href="http://yoursite.com/2017/05/23/Tinker%E8%A1%A5%E4%B8%81%E6%9E%84%E5%BB%BA%E8%B5%B0%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/05/23/Tinker补丁构建走读/</id>
    <published>2017-05-23T00:18:44.000Z</published>
    <updated>2017-05-23T00:19:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tinker简单问答"><a href="#Tinker简单问答" class="headerlink" title="Tinker简单问答"></a>Tinker简单问答</h2><h4 id="为什么要替换-Application"><a href="#为什么要替换-Application" class="headerlink" title="为什么要替换 Application"></a>为什么要替换 Application</h4><p>看上一篇和 Instant Run 的对比，可能考虑不全</p>
<ul>
<li>确保 Multidex 开启</li>
<li>保证应用 Application 类可修复</li>
<li>7.0 混合编译的影响，要去替换掉原始 PathClassLoader 的加载功能<a id="more"></a></li>
</ul>
<h4 id="为什么还要在-dexElements-前面插入而不是直接替换？"><a href="#为什么还要在-dexElements-前面插入而不是直接替换？" class="headerlink" title="为什么还要在 dexElements 前面插入而不是直接替换？"></a>为什么还要在 dexElements 前面插入而不是直接替换？</h4><p>因为 Tinker 是全量合成 dex ，比如在补丁前dex顺序是这样的：oldDex1 -&gt; oldDex2 -&gt; oldDex3..，那么假如修改了dex1中的文件，那么补丁顺序是这样的newDex1 -&gt; oldDex1 -&gt; oldDex2… 那为什么不直接使用newDex1去替换调oldDex呢？我觉得:</p>
<ul>
<li>运行期去替换调正在使用的dex是有风险的(也是我瞎猜)</li>
<li>考虑到版本回退和以后的增量升级，在前面插入确实比替换更加方便安全</li>
</ul>
<h2 id="Tinker补丁构建走读"><a href="#Tinker补丁构建走读" class="headerlink" title="Tinker补丁构建走读"></a>Tinker补丁构建走读</h2><p>Tinker的补丁加载网上资料很多了，读起来也没太大难度，这里就不多说了。关于补丁构建的整个过程倒是不多，这里简单走读一下。</p>
<h4 id="TinkerPatchSchemaTask"><a href="#TinkerPatchSchemaTask" class="headerlink" title="TinkerPatchSchemaTask"></a>TinkerPatchSchemaTask</h4><p>关于代码的变动  dex的patch  资源的patch</p>
<p>这个 Task 主要是用于 oldApk和 newApk 的差分，生成patch，包括dex,res,so的差分，主要起作用的类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ManifestDecoder manifestDecoder;<span class="comment">//检测是否增加了四大组件  关于dexMode的检测提示</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UniqueDexDiffDecoder dexPatchDecoder;<span class="comment">//dex 的patch</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BsDiffDecoder soPatchDecoder;<span class="comment">//so 的patch</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResDiffDecoder resPatchDecoder;<span class="comment">//资源的patch</span></div></pre></td></tr></table></figure>
<p>这个 Task 也是最关键的，可以从 <code>ApkDecoder</code> 这个类开始，首先会先把两个apk解压到<code>build/outputs/tinkerPatch/{variant}/apkName</code>目录下，在打patch 过程中<code>tinkerPatch</code> 目录下会生成很多过程文件，类似最终的patch apk,用于查看资源合成结果的 <code>resources_out.zip</code>，还有一下log.txt。关键的patch从</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Files.walkFileTree(mNewApkDir.toPath(), <span class="keyword">new</span> ApkFilesVisitor(config, mNewApkDir.toPath(), mOldApkDir.toPath(), dexPatchDecoder, soPatchDecoder, resPatchDecoder));</div></pre></td></tr></table></figure>
<p>这里开始，遍历newApk解压后的目录，根据<code>Pattern</code>去匹配使用上面四个中哪个<code>Decoder</code>去处理这两个新旧文件。</p>
<ul>
<li>dex查分</li>
</ul>
<p>从<code>UniqueDexDiffDecoder dexPatchDecoder;</code>处理dex开始，这里假如我们oldApk只有一个classes.dex,来到<code>DexDiffDecoder.patch</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不是为了对比 是为了检查dex的一些规则</span></div><div class="line">           excludedClassModifiedChecker.checkIfExcludedClassWasModifiedInNewDex(oldFile, newFile);</div></pre></td></tr></table></figure>
<p>这里去检查一下第一个dex中的一些限制，例如tinker的一些loader类一定要在第一个dex中等限制。<br>如果新增了一个dex<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//new add file 在new apk中多了一个dex 直接复制</span></div><div class="line">        <span class="keyword">if</span> (oldFile == <span class="keyword">null</span> || !oldFile.exists() || oldFile.length() == <span class="number">0</span>) &#123;</div><div class="line">            hasDexChanged = <span class="keyword">true</span>;</div><div class="line">            copyNewDexAndLogToDexMeta(newFile, newMd5, dexDiffOut);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>然后正常的修改了dex</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Before starting real diff works, we collect added class descriptor</div><div class="line">     * and deleted class descriptor for further analysing in &#123;<span class="doctag">@code</span> checkCrossDexMovingClasses&#125;.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectAddedOrDeletedClasses</span><span class="params">(File oldFile, File newFile)</span></span></div></pre></td></tr></table></figure>
<p>把对应的dex保存在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// collect current old dex file and corresponding new dex file for further processing.</span></div><div class="line">       oldAndNewDexFilePairList.add(<span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(oldFile, newFile));</div></pre></td></tr></table></figure></p>
<p>然后走到<code>dexPatchDecoder.onAllPatchesEnd();//开始生成 保存patch文件</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (config.mIsProtectedApp) &#123;<span class="comment">//仅仅在加固的时候使用 只将变化的类合成补丁</span></div><div class="line">            generateChangedClassesDexFile();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            generatePatchInfoFile();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>然后来到这个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">            DexPatchGenerator dexPatchGen = <span class="keyword">new</span> DexPatchGenerator(oldDexFile, newDexFile);</div><div class="line">            dexPatchGen.setAdditionalRemovingClassPatterns(config.mDexLoaderPattern);<span class="comment">//查分时候排除dex.loader闭包中的类</span></div><div class="line"></div><div class="line">            logWriter.writeLineToInfoFile(</div><div class="line">                    String.format(</div><div class="line">                            <span class="string">"Start diff between [%s] as old and [%s] as new:"</span>,</div><div class="line">                            getRelativeStringBy(oldDexFile, config.mTempUnzipOldDir),</div><div class="line">                            getRelativeStringBy(newDexFile, config.mTempUnzipNewDir)</div><div class="line">                    )</div><div class="line">            );</div><div class="line"></div><div class="line">            dexPatchGen.executeAndSaveTo(dexDiffOut);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerPatchException(e);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>这里就是具体的dexDiff算法了，我也看不懂，就当个黑盒，反正会生产处一个查分dex保存，然后后面还会在合成一个全量dex用来查看，保存一下log日志之类的，大致的dex查分就完成了。</p>
<ul>
<li>res 查分<br>回到遍历newApk目录的地方，还是根据<code>Pattern</code>去匹配资源文件，在这个方法中进行查分</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//处理修改的资源</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dealWithModeFile</span><span class="params">(String name, String newMd5, File oldFile, File newFile, File outputFile)</span></span></div></pre></td></tr></table></figure>
<p>还是使用了BSD进行差分，输出log，修改的文件复制到tinker_result的目录下。然后到<code>onAllPatchesEnd</code>，和dex一样，还是会生成全量的<code>resources_out.zip</code>去查看合成结果，还有log输出。</p>
<ul>
<li>so查分<br>这个也是使用了BSD查分，没太多好说的。</li>
</ul>
<h4 id="TinkerManifestTask"><a href="#TinkerManifestTask" class="headerlink" title="TinkerManifestTask"></a>TinkerManifestTask</h4><p>自动添加/修改tinker_id，运行时检查补丁版本</p>
<h4 id="TinkerResourceIdTask"><a href="#TinkerResourceIdTask" class="headerlink" title="TinkerResourceIdTask"></a>TinkerResourceIdTask</h4><p>R.txt 的保存 ids.xml public.xml的处理，用于处理资源改变时ID变动问题，将基础包的R.txt处理成ids.xml，public.xml，保存到<code>intermediates/res/merged/{variant}/values/</code>下，用于打包时候的资源ID分配。保证资源ID的不变动。</p>
<h4 id="TinkerProguardConfigTask"><a href="#TinkerProguardConfigTask" class="headerlink" title="TinkerProguardConfigTask"></a>TinkerProguardConfigTask</h4><p>混淆的处理，主要的作用是将tinker中默认的混淆信息和基准包的mapping信息加入混淆列表。</p>
<h4 id="TinkerMultidexConfigTask"><a href="#TinkerMultidexConfigTask" class="headerlink" title="TinkerMultidexConfigTask"></a>TinkerMultidexConfigTask</h4><p>主要将dex.loader中配置的class也keep进main dex.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Tinker简单问答&quot;&gt;&lt;a href=&quot;#Tinker简单问答&quot; class=&quot;headerlink&quot; title=&quot;Tinker简单问答&quot;&gt;&lt;/a&gt;Tinker简单问答&lt;/h2&gt;&lt;h4 id=&quot;为什么要替换-Application&quot;&gt;&lt;a href=&quot;#为什么要替换-Application&quot; class=&quot;headerlink&quot; title=&quot;为什么要替换 Application&quot;&gt;&lt;/a&gt;为什么要替换 Application&lt;/h4&gt;&lt;p&gt;看上一篇和 Instant Run 的对比，可能考虑不全&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保 Multidex 开启&lt;/li&gt;
&lt;li&gt;保证应用 Application 类可修复&lt;/li&gt;
&lt;li&gt;7.0 混合编译的影响，要去替换掉原始 PathClassLoader 的加载功能
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>由View.post引发的问题</title>
    <link href="http://yoursite.com/2017/05/14/%E7%94%B1View-post%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/05/14/由View-post引发的问题/</id>
    <published>2017-05-14T12:31:42.000Z</published>
    <updated>2017-05-14T12:36:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到<a href="http://www.jianshu.com/p/571e9b4f4b89" target="_blank" rel="external">记一次错误的使用View.post(Runnable)</a>这篇的时候，自己去实验了一下，当时是在 Activity 的 onDestory 中做的，以为到了 onDestory View 肯定是 Detach 的，结果并不是这样的。。后来发现在 API 24的时候，关于 View.Post 这部分的代码有重写，所有就捋了捋关于这部分的东西，简单记录一下。<a id="more"></a></p>
<h4 id="View-Detach"><a href="#View-Detach" class="headerlink" title="View Detach"></a>View Detach</h4><p>View 什么时候才会 Detach ？当 View 中 mAttachInfo 这个变量置空的时候，就 Detach 了，是在 dispatchDetachedFromWindow 这个方法中置空的，这方法是在 ViewRootImpl.dispatchDetachedFromWindow() 中调用的，ViewRootImpl 可以看做是在 View 和 WindowManager 中间一个类 ，WMS 通过 IWindow 进行 ipc 通信控制通知客户端的 WindowManager， WindowManager 还要稍微使用 WindowManagerGlobal 中转处理一下，然后再去调用 ViewRootImpl 中的一些方法，而 ViewRootImpl 是持有 DecorView ，DecorView 中又有 WindowCallBack ，其实就是 Activity ,因为 Activity 实现了 WindowCallBack。这样再去调用 Activity 中关于 Window 相关的回调。回到问题，什么时候Detach？ 当然还是在 Activity 销毁的时候，简单说下情形，A 启动 B ,在 B 中调用 finish。B finish-&gt; B onPause-&gt;A onResume-&gt;B onStop-&gt;B onDestroy-&gt;B onDetachedFromWindow 。大致的流程是ActivityManagerNative通知AMS,AMS通过IApplicationThread调用ActivityThread.H去sendMessage，然后再去ActivityThread某个类似performPauseActivity，然后Instrumentation，然后就是activity生命周期。在最后调用handleDestroyActivity中，先调用ondestory 然后调用wm的removeViewImmediate，[ActivityThread.handleDestroyActivity() –&gt;<br>WindowManager.removeViewImmediate() –&gt;<br>WindowManagerGlobal.removeViewLocked()方法 —&gt;<br>ViewRootImpl.die() –&gt; doDie() –&gt;<br>ViewRootImpl.dispatchDetachedFromWindow()],这个时候view.attachInfo 置空，所以当回调 Activity 的 onDestory 的时候，还没去调用 dispatchDetachedFromWindow ，当然还没 Detach 。关于 View 什么时候 Attached ，是在 onResume 之后，具体就不说了，和上面差不多。</p>
<h4 id="View-post"><a href="#View-post" class="headerlink" title="View.post"></a>View.post</h4><p>说一下现象，当在 Attached 的时候，使用 View.post 就是走 handler 那一套，使用的 handelr 是 ViewRootImpl 中的 ViewRootHandler ，looper 就是 mainLooper ，这个没什么好分析的，这个时候怎么post都是有回调的。当在 Detach 的时候，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</div><div class="line">        <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> attachInfo.mHandler.post(action);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></div><div class="line">        <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></div><div class="line">        getRunQueue().post(action);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>走下面的 <code>getRunQueue().post(action);</code> 这个在24 以前 看开头那篇分析，是用 ThreadLocal 来进行的线程隔离，在 24 的时候，getRunQueue 变成了view的私有变量 mRunQueue:HandlerActionQueue ,当post 到这个里面去的时候，基本上是不会在调用了，因为它的 <code>mRunQueue.executeActions(info.mHandler);</code>是在 <code>dispatchAttachedToWindow</code> 中调用的。。一个activity生命周期只会调一次，也基本上用不到什么自行车了。。</p>
<h4 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h4><p>看下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.onDestroy();</div><div class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">              button.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                  <span class="meta">@Override</span></div><div class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                      Log.e(<span class="string">"ssssss"</span>, <span class="string">"onDestroy"</span>);</div><div class="line">                  &#125;</div><div class="line">              &#125;);</div><div class="line">          &#125;</div><div class="line">      &#125;).start();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里面的Log会不会调用？？说实话，看缘分。。。不信自己去试试</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到&lt;a href=&quot;http://www.jianshu.com/p/571e9b4f4b89&quot;&gt;记一次错误的使用View.post(Runnable)&lt;/a&gt;这篇的时候，自己去实验了一下，当时是在 Activity 的 onDestory 中做的，以为到了 onDestory View 肯定是 Detach 的，结果并不是这样的。。后来发现在 API 24的时候，关于 View.Post 这部分的代码有重写，所有就捋了捋关于这部分的东西，简单记录一下。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Instant-Run与Tinker中Application替换</title>
    <link href="http://yoursite.com/2017/05/08/Instant-Run%E4%B8%8ETinker%E4%B8%ADApplication%E6%9B%BF%E6%8D%A2/"/>
    <id>http://yoursite.com/2017/05/08/Instant-Run与Tinker中Application替换/</id>
    <published>2017-05-08T14:58:02.000Z</published>
    <updated>2017-05-16T01:02:21.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>为什么要替换application</li>
</ul>
<p>因为5.0以下开始只会去加载第一个dex,如果appliaction不在第一个dex,则无法启动。如果把自己的appliaction放在第一个dex中，而自己的application没有使用multidex,则只会去加载原始加载生成的dex,也是会报错。所以办法就是去代理掉原始的application，将app启动的application设置为这个代理的application，在这个代理的application中可以确保使用multidex功能。</p>
<p>还有因为补丁是在appliaction中加载，这样会导致无法对appliaction的修复，还有因为 Android N 的混合编译的影响 ，Tinker 使用了类似 Instant-run 中 IncrementalClassLoader （具体实现过程还是有差距），新建一个classLoader，去 “替换”掉原始的 PathClassLoader 去加载所有dex。这些都需要在appliaction中进行修改。<br><a id="more"></a></p>
<ul>
<li>替换操作的差异</li>
</ul>
<p>Instant run 是在attachBaseContext的时候再去反射创建原始的application，然后再反射替换掉Framework中已经初始化的application(这个时候还是代理的application),还原回去我们原始的application。接下来就是正常的流程，在app中去get application也不会有问题。</p>
<p>Tinker使用的是静态代理，使用代理方案代码会更复杂一些，因为要去模拟出一个applicationLike的接口，在tinker中，我们真正的application只需要实现这个接口，并不需要去继承Android中的application，因为会在代理的application中反射调用我们的application生命周期方法。也就是说tinker中只有一个真正的application。</p>
<ul>
<li>优缺点</li>
</ul>
<p>在instant run中application的替换的透明的，两个application都是真正的Android application。好处就是透明，坏处也是使用了反射替换运行期的application，兼容性不如静态代理好，类似tinker中反射插入dex就分了好多个版本实习，这个会更复杂。tinker更加稳定。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;为什么要替换application&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为5.0以下开始只会去加载第一个dex,如果appliaction不在第一个dex,则无法启动。如果把自己的appliaction放在第一个dex中，而自己的application没有使用multidex,则只会去加载原始加载生成的dex,也是会报错。所以办法就是去代理掉原始的application，将app启动的application设置为这个代理的application，在这个代理的application中可以确保使用multidex功能。&lt;/p&gt;
&lt;p&gt;还有因为补丁是在appliaction中加载，这样会导致无法对appliaction的修复，还有因为 Android N 的混合编译的影响 ，Tinker 使用了类似 Instant-run 中 IncrementalClassLoader （具体实现过程还是有差距），新建一个classLoader，去 “替换”掉原始的 PathClassLoader 去加载所有dex。这些都需要在appliaction中进行修改。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Express + React 搭建简易web微博</title>
    <link href="http://yoursite.com/2017/03/02/%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93web%E5%BE%AE%E5%8D%9A/"/>
    <id>http://yoursite.com/2017/03/02/搭建简易web微博/</id>
    <published>2017-03-02T00:47:52.000Z</published>
    <updated>2017-07-28T13:33:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近用 React 写了个简单的web微博，因为js的跨域问题，无法直接请求web Weibo的API，所以只能使用Node来中转一下，这样玩法也更丰富，随便处理数据。目前的功能只包括看微博和查看大图。<a id="more"></a></p>
<p>微博的自动登录使用的是<a href="https://github.com/ruansongsong/nodejs-weibo-login" target="_blank" rel="external">nodejs-weibo-login</a>,但是这个库是为了pc端微博设计的，最初还是可以兼容web版的微博登录，后来估计是新浪修改了规则，不再兼容了，所以目前只能手动传 cookie 了。<br>基本没用第三方的react类库，就是个很简单的东西。</p>
<p><a href="https://coding.net/u/70kg/p/express/git" target="_blank" rel="external">服务端代码</a><br><a href="https://coding.net/u/70kg/p/React/git" target="_blank" rel="external">Weibo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近用 React 写了个简单的web微博，因为js的跨域问题，无法直接请求web Weibo的API，所以只能使用Node来中转一下，这样玩法也更丰富，随便处理数据。目前的功能只包括看微博和查看大图。
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》笔记</title>
    <link href="http://yoursite.com/2016/12/31/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/12/31/《深入理解Java虚拟机》笔记/</id>
    <published>2016-12-31T08:54:38.000Z</published>
    <updated>2017-07-28T13:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自动内存管理机制"><a href="#自动内存管理机制" class="headerlink" title="自动内存管理机制"></a>自动内存管理机制</h2><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul>
<li>通过改变这个计数器的指决定执行的下一条指令</li>
<li>线程私有 每条线程独立</li>
<li>不会 oom <a id="more"></a><h4 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h4>存放基本类型和引用和   returnAddress类型(指向了一条字节码指令的地址）<br>描述 Java 方法执行的内存模型<h4 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h4></li>
<li>存放对象实例</li>
<li>线程共享，内存最大</li>
<li>GC 的主要区域</li>
<li>基于分代回收，大致分为新生代和老年代<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4></li>
<li>线程共享</li>
<li>类信息，常量，静态变量<h2 id="虚拟机对象"><a href="#虚拟机对象" class="headerlink" title="虚拟机对象"></a>虚拟机对象</h2><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4>new指令的参数是否能在常量池中定位到一个类的符号引用-&gt;是否已经加载，解析初始化-&gt;分配内存(指针碰撞，空闲列表)-&gt;初始化为零值-&gt;为对象进行必要设置-&gt;&lt; init &gt; 方法。(ps：new 关键字其实为new和init两个方法)</li>
</ul>
<h3 id="对象的内存分布"><a href="#对象的内存分布" class="headerlink" title="对象的内存分布"></a>对象的内存分布</h3><ul>
<li>对象头<br>1.分用于存储对象自身的运行时数据,e.g.哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时 间戳等<br>2.类型指针,对象指向它的类元数据的指针,虚拟机通过这个指 针来确定这个对象是哪个类的实例.</li>
<li>实例数据</li>
<li>对其填充</li>
</ul>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>使用栈上的引用去操作堆上的实例。</p>
<ol>
<li>句柄<br>在堆中有一块内存区域作为句柄池，栈中的引用存储的是对象的句柄地址，句柄中包括对象的实例数据(实例池)和类型数据(方法区)。<br>好处：GC 时只会改变句柄中实例指针，不会影响栈中的指向。<ol>
<li>直接指针<br>栈中的引用直接指向对象地址。<br>好处：速度快，省一次指针定向</li>
</ol>
</li>
</ol>
<p>ps: <code>String.intern</code>的问题 <a href="http://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="external">点这里</a></p>
<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p>先标记需要回收的对象，然后统一回收。缺点是效率不高，会产生内存碎片问题。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>1：1分割内存，只用一半，回收时把存活的复制到另一半，清除原来一半。<br>实际使用在新生代，适合回收频率高的。朝生夕死。每次清理都有大量对象死亡。<code>HotSpot</code>默认为8:1:1,浪费10%的内存空间，使用8和1，当回收时候，复制到另一个1中。空间不够时候，需要依赖老年代。</p>
<h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h3><p>先标记，把存活的移动到一端，清除。适合老年代</p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>通过使用一组<code>OopMap</code>的数据结构知道哪些地方存放对象引用。在类加载完成时，<code>HotSpot</code>就把对象内什么偏移量上是什么类型的数据计算出来，在<code>JIT</code>编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，这样GC扫描时就可以直接得知。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>上面特定的位置是安全点，只有在安全点处暂停。主要使用主动式中断让所有线程都跑到安全点再停顿。不直接对线程操作，设置一个标志，各个线程主动去轮训，发现中断标志true就自己中断挂起。</p>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全区域用来解决在程序没有CPU时间，例如线程sleep或者block的时候进入GC。安全区域是指在一段代码之后，引用关系不会发生变化，在这个区域任何地方GC都是安全的。当程序执行到安全区域，首先标识进入，然后GC可以随时进行。当程序要离开安全区域时，先去检查GC是否完成，是-&gt;继续执行，否-&gt;等待完成。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>最基本最久远的收集器，单线程,STW。没有线程切换的开销，简单。复制算法</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>Serial收集器的多线程版本。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>和ParNew收集器类似，关注吞吐量</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial收集器的的老年代版本。标记-整理</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Scavenge收集器的老年代版本，标记-整理。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）<br>1，3步骤STW。1只标记GC roots能直接关联对象，很快。并发标记阶段就是进行GC RootsTracing 的过程,而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变 动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远 比并发标记的时间短。整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作<img src="http://7xjlmz.com1.z0.glb.clouddn.com/Java%E8%99%9A%E6%8B%9F%E6%9C%BAcms.png" alt=""><br>优点：<br>并发收集，低停顿<br>缺点：<br>对CPU资源敏感，默认回收线程(cpu数量+3)/4<br>cms无法处理”浮动垃圾”（当并发收集同时产生的垃圾）<br>标记-清除算法内存碎片问题</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>特点：</p>
<ul>
<li>分代收集</li>
<li>并行与并发</li>
<li>空间整合</li>
<li>可预测的停顿<br>将整个Java堆划分 为多个大小相等的独立区域(Region)<br>大致过程：<ol>
<li>初始标记(Initial Marking)</li>
<li>并发标记(Concurrent Marking)</li>
<li>最终标记(Final Marking)</li>
<li>筛选回收(Live Data Counting and Evacuation)<br>4-&gt;筛选回收阶段首先对各个Region的回收价值和成本进行排序, 根据用户所期望的GC停顿时间来制定回收计划</li>
</ol>
</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下,对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时,虚拟 机将发起一次Minor GC</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对 象年龄(Age)计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活,并且能被 Survivor容纳的话,将被移动到Survivor空间中,并且对象年龄设为1。对象在Survivor区中 每“熬过”一次Minor GC,年龄就增加1岁,当它的年龄增加到一定程度(默认为15岁),就 将会被晋升到老年代中。</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>如果在Survivor空间中相同年龄所有对象大小的总 和大于Survivor空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代,无须等 到MaxTenuringThreshold中要求的年龄。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC之前,虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有 对象总空间,如果这个条件成立,那么Minor GC可以确保是安全的。如果不成立,则虚拟机 会查看HandlePromotionFailure设置值是否允许担保失败。如果允许,那么会继续检查老年代 最大可用的连续空间是否大于历次晋升到老年代对象的平均大小,如果大于,将尝试着进行 一次Minor GC,尽管这次Minor GC是有风险的;如果小于,或者HandlePromotionFailure设置 不允许冒险,那这时也要改为进行一次Full GC。</p>
<h1 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h1><p>略</p>
<h1 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h1><p>略</p>
<h1 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h1><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>Class文件格式采用一种类似C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表<br>无符号数属于基本类型，有u1,u2,u4,u8表示几个字节，可以用来描述数字，索引引用，数据值或者按照UTF-8编码的字符串<br>表是由多个无符号数或者其他表作为数据结构的复合数据结构，表习惯以_info结尾。<br>整个Class本质上就是一个表<br>Class文件格式：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt=""></p>
<h3 id="魔数-u4"><a href="#魔数-u4" class="headerlink" title="魔数 u4"></a>魔数 u4</h3><p><code>0xCAFFBABE</code></p>
<h3 id="次版本号-u2"><a href="#次版本号-u2" class="headerlink" title="次版本号 u2"></a>次版本号 u2</h3><h3 id="主版本号-u2"><a href="#主版本号-u2" class="headerlink" title="主版本号 u2"></a>主版本号 u2</h3><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>u2的常量池大小 index从1开始，第0项空出<br>常量池中主要存放两大类常亮：字面量和符号引用<br>字面量类似Java的常量<br>符号引用包括：</p>
<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ol>
<p>常量池中每一项都是一个表(都对应一个Class)。一共14种表，表开始的第一位u1代表当前这个常量属于哪种常量类型<br>具体如下：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%B1%BB%E5%9E%8B.jpg" alt=""></p>
<h3 id="访问标志-u2"><a href="#访问标志-u2" class="headerlink" title="访问标志 u2"></a>访问标志 u2</h3><p>用于标识一些类或者接口成次的访问信息<br>具体如下：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.jpg" alt=""></p>
<h3 id="类索引、父类索引与接口索引集合-u2-u2-List"><a href="#类索引、父类索引与接口索引集合-u2-u2-List" class="headerlink" title="类索引、父类索引与接口索引集合 u2,u2,List"></a>类索引、父类索引与接口索引集合 u2,u2,List<u2></u2></h3><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>用于描述接口或类中的变量<br>字段包括类级变量(static)和实例级变量 不包括方法内部的局部变量</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>对方法的描述</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>用于描述某些场景专用信息。下面的必备的9个属性:<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E5%B1%9E%E6%80%A7%E8%A1%A8.png" alt=""></p>
<h4 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h4><p>简单理解就是方法体,具体的结构如下：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class_code%E5%B1%9E%E6%80%A7.jpg" alt=""></p>
<p>Code属性是Class文件中最重要的属性，如果把Java程序中信息分为代码（Code）和元数据(类，字段，方法定有以及其他信息)两部分。Code属性属于描述代码，所有的其他数据项目都用于描述元数据</p>
<h2 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h2><h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><p>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输<br>Tload -&gt; 将一个局部变量加载到操作栈<br>Tstore -&gt; 将一个数值从操作数栈存储到局部变量表<br>Tipush -&gt; 将一个变量加载到操作数栈<br>wide -&gt; 扩充局部变量表的访问索引指令</p>
<h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><p>用于对两个操作数栈上的值进行某种特定的运算，并把结果重新存入到操作栈顶。<br>算术运算大致分为对整形数据进行运算的指令和对浮点数进行运算的指令</p>
<p>加法指令 ：Tadd<br>减法指令: Tsub<br>乘法指令： Tmul<br>除法指令：Tdiv<br>求余指令：Trem<br>取反指令：Tneg<br>位移指令：Tshl,Tshr,Tushr<br>按位或指令：Tor<br>按位与指令：Tand<br>按位异或指令：Txor<br>局部变量自增指令：Tinc<br>比较指令：Tcmpg,Rcmpl</p>
<h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><p>用于将两种不同的数值类型进行相互转换，一般用于实现用户代码中的显式类型转换或者用于处理字节码指令集中数据类型相关指令无法一一对应的问题<br>i2b,i2c…</p>
<h3 id="对象创建和访问指令"><a href="#对象创建和访问指令" class="headerlink" title="对象创建和访问指令"></a>对象创建和访问指令</h3><p>Java虚拟机对类实例和数组的创建于操作用了不同的字节码指令。<br>创建类实例 -&gt; new<br>创建数组 -&gt; newarray,anewarray,multianewarray<br>访问类字段和实例字段 -&gt; getfield,putfield,getstatic,putstatic<br>把一个数组元素加载到操作数栈 -&gt; Taload<br>将一个操作数栈的值存储到数组元素中 -&gt;Tastore<br>取数组长度 -&gt; arraylength<br>检查类实例类型 -&gt; instanceof,checkcast</p>
<h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><p>直接操作操作数栈的指令<br>将操作数栈的栈顶一个或两个元素出栈 -&gt;pop,pop2<br>复制栈顶两个数值并将双份复制值从新压入栈顶 -&gt; dup2,dup2_x1,dup2_x2<br>栈顶两个数值交换 -&gt; swap</p>
<h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><p>条件分支，复合条件分支，无条件分支<br>各种类型的比较最终都会转化成int类型的比较操作，所以Java虚拟机提供的int类型的条件分支指令是最丰富和强大的</p>
<h3 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h3><p>invokevirtual -&gt;调用实例方法，最常见的<br>invokeinterface -&gt;调用接口方法，会在运行时搜索一个实现了这个接口方法的对象，找到合适的方法进行调用<br>invokespecial -&gt; 调用一些需要特殊处理的实例方法，包括实例初始化方法，私有方法和父类方法<br>invokestatic -&gt; 调用类方法<br>invokedynamic -&gt; 在运行时动态解析出调用点限定符所引用的方法，并执行该方法？？？？</p>
<p>方法调用指令与数据类型无关，返回指令是根据返回值的类型区分的.Treturn</p>
<h3 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h3><p>显示抛出异常(throw)都是由athrow指令实现。<br>处理异常不是由字节码指令实现的，采用异常表完成。</p>
<h3 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h3><p>支持方法级同步和方法内部一段指令序列的同步，是使用管程(Monitor)支持。</p>
<p>方法级的同步是隐式的,即无须通过字节码指令来控制,它实现在方法调用和返回操作 之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个 方法是否声明为同步方法。当方法调用时,调用指令将会检查方法的ACC_SYNCHRONIZED 访问标志是否被设置,如果设置了,执行线程就要求先成功持有管程,然后才能执行方法, 最后当方法完成(无论是正常完成还是非正常完成)时释放管程。在方法执行期间,执行线 程持有了管程,其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出 了异常,并且在方法内部无法处理此异常,那么这个同步方法所持有的管程将在异常抛到同 步方法之外时自动释放。</p>
<p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的,Java虚拟机的 指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义,正确实现 synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自动内存管理机制&quot;&gt;&lt;a href=&quot;#自动内存管理机制&quot; class=&quot;headerlink&quot; title=&quot;自动内存管理机制&quot;&gt;&lt;/a&gt;自动内存管理机制&lt;/h2&gt;&lt;h4 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;通过改变这个计数器的指决定执行的下一条指令&lt;/li&gt;
&lt;li&gt;线程私有 每条线程独立&lt;/li&gt;
&lt;li&gt;不会 oom
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从零撸一个Redux</title>
    <link href="http://yoursite.com/2016/12/25/Redux-2/"/>
    <id>http://yoursite.com/2016/12/25/Redux-2/</id>
    <published>2016-12-25T13:53:53.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="扯一扯"><a href="#扯一扯" class="headerlink" title="扯一扯"></a>扯一扯</h4><p>这段时间在看 <code>Redux</code> 的东西，稍微梳理一下整个框架的流程。其实整个 <code>Redux</code> 的代码很少，现在我也不能理解很多它的思想，反正先撸出个简单的 <code>Redux</code> 吧。目标是照着它的流程写一个最简单的，也要支持异步 <code>Action</code>。也算是个笔记性的东西。<a id="more"></a></p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a><code>Action</code></h4><p>这里把 <code>Action</code> 放到了 <code>Store</code> 中，这样在 <code>Component</code> 中使用的时候只要导入 <code>store</code> 就可以，不用导入很多的 <code>Action</code>, <del>就是懒</del>。当然也可以使用 <code>React-Redux</code> 之类的进行绑定，但是这个库主要不是干这个的。。这个后面会提到一些。因为 <code>Actions</code> 都是提前定义的，所有写在了一个 <code>StoreConfig</code> 中，在创建 <code>Store</code> 的时候就可以把 <code>actions</code> 注入到 <code>Store</code> 中了。当然你也可以不这么做。先贴一下完整的代码吧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> createStore <span class="keyword">from</span> <span class="string">'./createStore'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> store = createStore(&#123;</div><div class="line">    <span class="comment">//把所有的action都放在了store中</span></div><div class="line">    actions: &#123;</div><div class="line">        <span class="comment">//同步的action</span></div><div class="line">        <span class="string">'printText'</span>: createRequest(<span class="function">(<span class="params">text</span>)=&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> &#123;<span class="attr">text</span>: text + <span class="string">"我想修改"</span>&#125;;</div><div class="line">        &#125;),</div><div class="line">        <span class="comment">//异步的action，async await可以看上一篇</span></div><div class="line">        <span class="string">'testAsync'</span>: createRequest(<span class="keyword">async</span>()=&gt; &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">await</span> Longtime();</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">initState</span>: &#123;&#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">//测试的代码不用说吧</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Longtime</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            resolve(&#123;<span class="attr">text</span>: <span class="string">'success'</span>&#125;);</div><div class="line">            <span class="comment">// reject('error');</span></div><div class="line">        &#125;, <span class="number">2000</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//这个是个actionCreater 之前有写过在项目中的使用 这里也不多说</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRequest</span>(<span class="params">actionCreator</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> finalActionCreator = <span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span></div><div class="line">        ? actionCreator</div><div class="line">        : <span class="function">(<span class="params">t</span>) =&gt;</span> t;</div><div class="line">    <span class="keyword">const</span> actionHandler = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">const</span> action = &#123;</div><div class="line">            <span class="attr">type</span>: actionHandler.toString()</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//真正的action都放在payload中，同步则是数据，异步是Promise。</span></div><div class="line">        <span class="keyword">const</span> payload = finalActionCreator(...args);</div><div class="line">        <span class="keyword">if</span> (!(payload === <span class="literal">null</span> || payload === <span class="literal">undefined</span>)) &#123;</div><div class="line">            action.payload = payload;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (action.payload <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</div><div class="line">            action.error = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> action;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> actionHandler;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</div></pre></td></tr></table></figure>
<h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a><code>Reducer</code></h4><p>这里的 <code>Reducer</code> 只创建了一个，就是直接把成功的数据更新到 <code>Store</code> 中，也没什么好看的，关于异步的 <code>Promise</code> 会在结果返回之后再去通知 <code>Reducer</code>去更新 <code>Store</code>，当然这就不是这个 <code>Reducer</code> 的工作了。代码很简单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">acceptSuccessActionReducer</span>(<span class="params">state, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!action.error &amp;&amp; action.payload) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, action.payload);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a><code>Store</code></h4><p>我觉得 <code>Redux</code> 的最重要的东西就是 <code>Store</code> 了。所有的 <code>Action</code> 都要经过 <code>Store</code> 分发，当结果返回之后也要通知 <code>Store</code> 去更新，<code>Component</code> 的数据也是从 <code>Store</code> 中获取。先贴一下 <code>CreateStore</code> 代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;handleActions&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</div><div class="line"><span class="keyword">import</span> &#123;applyMiddleware&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> promiseMiddleware <span class="keyword">from</span> <span class="string">'redux-promise'</span>;</div><div class="line"><span class="keyword">import</span> acceptSuccessActionReducer <span class="keyword">from</span> <span class="string">'../reducers/SuccessReducer'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> actions = config.actions;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> initState = config.initState;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> reducersDict = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="built_in">Object</span>.keys(actions).forEach(<span class="function"><span class="params">key</span>=&gt;</span> &#123;</div><div class="line">        <span class="keyword">var</span> action = actions[key];</div><div class="line">        action.toString = <span class="function"><span class="params">()</span>=&gt;</span>key;</div><div class="line">        reducersDict[key] = acceptSuccessActionReducer;<span class="comment">//将action与reducer绑定</span></div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//这个reducers应该是个类似arrays.reduce的function   果然--&gt; @see 'reduce-reducers'   what's means??</span></div><div class="line">    <span class="keyword">var</span> reducers = handleActions(reducersDict, initState);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> store = generateStore(reducers, applyMiddleware(promiseMiddleware));</div><div class="line"></div><div class="line">    store.actions = &#123;&#125;;</div><div class="line">    <span class="built_in">Object</span>.assign(store.actions, actions);</div><div class="line"></div><div class="line">    store.subscribe(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'这是修改后的===&gt;'</span>, store.getState());</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> store;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</div><div class="line">        enhancer = preloadedState;</div><div class="line">        preloadedState = <span class="literal">undefined</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> enhancer(generateStore)(reducer, preloadedState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> currentState = preloadedState;</div><div class="line">    <span class="keyword">let</span> currentReducer = reducer;</div><div class="line">    <span class="keyword">let</span> listeners = [];</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        getState() &#123;</div><div class="line">            <span class="keyword">return</span> currentState;<span class="comment">//返回当前 state</span></div><div class="line">        &#125;,</div><div class="line">        subscribe(listener) &#123;</div><div class="line">            <span class="keyword">let</span> index = listeners.length;</div><div class="line">            listeners.push(listener); <span class="comment">//缓存 listener</span></div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> listeners.splice(index, <span class="number">1</span>); <span class="comment">//返回删除该 listener 的函数</span></div><div class="line">        &#125;,</div><div class="line">        dispatch(action) &#123;</div><div class="line">            currentState = currentReducer(currentState, action);</div><div class="line">            listeners.slice().forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener());</div><div class="line">            <span class="keyword">return</span> action;<span class="comment">//返回 action 对象</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里偷懒用了一些库，但是仅仅是很简单的几个方法，例如 <code>import {handleActions} from &#39;redux-actions&#39;;</code> 这个里面的代码我没看的懂，但是知道返回一个类似<code>arrays.reduce</code>的<code>function</code>，这个可以理解返回一个 <code>rootReducer</code> ，也就是会迭代累加调用所有的 <code>Reducer</code> 。<code>generateStore</code> 也是抄了一部分的源码，大致的原理应该差不多。从这个也会发现一个问题，每当 <code>dispatch</code> 一个 <code>action</code> 都会去遍历所有的 <code>listeners</code> ，我们一般都是在 <code>listener</code> 中去做更新 <code>UI</code> 的工作，这样就会造成很多次无用的刷新。这个就可以使用上面提到过的 <code>React-Redux</code> 的 <code>mapStateToProps</code> 在某个 <code>Component</code> 中只去接受自己感兴趣的 <code>State</code> 的更新，然后再使用类似 <code>Immutable</code> 的库进去比较就可以很好的控制更新。当然这里不会多去说这个，因为我也没具体去理解过，以后可以多去学习学习。<br>这里还偷懒直接用了 <code>redux</code> 中的 <code>applyMiddleware</code>。我觉得这是我学习 <code>Redux</code> 中看到的最精彩的代码，贴一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, middlewares = <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) &#123;</div><div class="line">    middlewares[_key] = <span class="built_in">arguments</span>[_key];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);</div><div class="line">      <span class="keyword">var</span> _dispatch = store.dispatch;</div><div class="line">      <span class="keyword">var</span> chain = [];</div><div class="line"></div><div class="line">      <span class="keyword">var</span> middlewareAPI = &#123;</div><div class="line">        <span class="attr">getState</span>: store.getState,</div><div class="line">        <span class="attr">dispatch</span>: <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> _dispatch(action);</div><div class="line">        &#125;</div><div class="line">      &#125;;</div><div class="line">      chain = middlewares.map(<span class="function"><span class="keyword">function</span> (<span class="params">middleware</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> middleware(middlewareAPI);</div><div class="line">      &#125;);</div><div class="line">      _dispatch = _compose2[<span class="string">'default'</span>].apply(<span class="literal">undefined</span>, chain)(store.dispatch);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> _extends(&#123;&#125;, store, &#123;</div><div class="line">        <span class="attr">dispatch</span>: _dispatch</div><div class="line">      &#125;);</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过和上面的 <code>generateStore</code> 一起看，特别是 <code>applyMiddleware</code> 返回的匿名<code>Function</code>，真是精彩的代码。再去试想一下如果使用 <code>Java</code> 这样的强类型语言去实现得是多麻烦的事情。还有就是 <code>Function</code> 的一等公民地位的体现。真的值得多去读一读，很赞。不得不去佩服写这段代码的人。甚至有点自举的感觉。在还没创建 <code>store</code> 的时候就可以去使用 <code>Store.dispatch</code>，(这句话是有问题的，意会即可)。还有就是 <code>applyMiddleware</code> 的整个过程其实没有完全的弄明白，这里也不班门弄斧，等明白了会再来更新的。</p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>最后就是使用了，没什么好说的<code>store.dispatch(store.actions.testAsync());</code>就可以了。使用手动的 <code>subscribe</code> 或者 <code>React-redux</code> 的 <code>connect</code> 都能实现 <code>UI</code> 的更新，当然更推荐后者。后面还会去学习一个 <code>React-Redux</code> 这个东西，毕竟又使用 <code>React</code> 又使用 <code>Redux</code> 肯定也少不了这个东西。<br>先说到这吧，有什么想说的再来补一补。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;扯一扯&quot;&gt;&lt;a href=&quot;#扯一扯&quot; class=&quot;headerlink&quot; title=&quot;扯一扯&quot;&gt;&lt;/a&gt;扯一扯&lt;/h4&gt;&lt;p&gt;这段时间在看 &lt;code&gt;Redux&lt;/code&gt; 的东西，稍微梳理一下整个框架的流程。其实整个 &lt;code&gt;Redux&lt;/code&gt; 的代码很少，现在我也不能理解很多它的思想，反正先撸出个简单的 &lt;code&gt;Redux&lt;/code&gt; 吧。目标是照着它的流程写一个最简单的，也要支持异步 &lt;code&gt;Action&lt;/code&gt;。也算是个笔记性的东西。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Asncy await Promise的使用</title>
    <link href="http://yoursite.com/2016/12/15/Promise%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/12/15/Promise的使用/</id>
    <published>2016-12-15T03:53:56.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fetch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="comment">// resolve('success');</span></div><div class="line">            reject(<span class="string">'error'</span>);</div><div class="line">        &#125;, <span class="number">2000</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> testAsync = <span class="keyword">async</span>() =&gt; &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">await</span> fetch();</div><div class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">testAsync().then(<span class="function">(<span class="params">result</span>)=&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'这是成功的---&gt;'</span> + result);</div><div class="line">&#125;).catch(<span class="function">(<span class="params">error</span>)=&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'这是失败的---&gt;'</span> + error);</div><div class="line">&#125;);;</div></pre></td></tr></table></figure>
<p><code>async</code>函数返回的一个 <code>Promise</code>， 调用耗时函数前面加 <code>await</code> 关键字，返回成功的值，可以使用 <code>try..catch</code> 来进行捕获错误。上面的代码可以模拟一次请求的过程，最基本用法差不多都包括了<a id="more"></a></p>
<p><a href="http://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=true&amp;presets=latest,react,stage-2&amp;code=const%20fetch%20=%20%28%29%20=%3E%20%7B%0A%20%20%20%20return%20new%20Promise%28%28resolve,%20reject%29%20=%3E%20%7B%0A%20%20%20%20%20%20%20%20setTimeout%28%28%29%20=%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20//%20resolve%28%27success%27%29;%0A%20%20%20%20%20%20%20%20%20%20%20%20reject%28%27error%27%29;%0A%20%20%20%20%20%20%20%20%7D,%202000%29;%0A%20%20%20%20%7D%29;%0A%7D;%0A%0Aconst%20testAsync%20=%20async%28%29%20=%3E%20%7B%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%20%20%20return%20await%20fetch%28%29;%0A%20%20%20%20%7D%20catch%20%28error%29%20%7B%0A%20%20%20%20%20%20%20%20return%20Promise.reject%28error%29;%0A%20%20%20%20%7D%0A%7D;%0A%0AtestAsync%28%29.then%28%28result%29=%3E%20%7B%0A%20%20%20%20console.log%28%27%E8%BF%99%E6%98%AF%E6%88%90%E5%8A%9F%E7%9A%84---%3E%27%20%2b%20result%29;%0A%7D%29.catch%28%28error%29=%3E%20%7B%0A%20%20%20%20console.log%28%27%E8%BF%99%E6%98%AF%E5%A4%B1%E8%B4%A5%E7%9A%84---%3E%27%20%2b%20error%29;%0A%7D%29;;&amp;experimental=false&amp;loose=false&amp;spec=false&amp;playground=true" target="_blank" rel="external">点我运行</a></p>
<h4 id="Promise-then是异步的"><a href="#Promise-then是异步的" class="headerlink" title="Promise.then是异步的"></a><code>Promise.then</code>是异步的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(function (resolve)&#123;</div><div class="line">    console.log(&quot;inner promise&quot;); // 1</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div><div class="line">promise.then(function(value)&#123;</div><div class="line">    console.log(value); // 3</div><div class="line">&#125;);</div><div class="line">console.log(&quot;outer promise&quot;); // 2</div><div class="line"></div><div class="line"></div><div class="line">----------</div><div class="line">inner promise // 1</div><div class="line">outer promise // 2</div><div class="line">42            // 3</div></pre></td></tr></table></figure>
<p><a href="https://wohugb.gitbooks.io/promise/content/usage/async.html" target="_blank" rel="external">为啥这样</a></p>
<p>更多的关于 <code>Promise</code> 看下面的这本电子书，就不扯了，啦啦啦。</p>
<p>参考:<br><a href="https://wohugb.gitbooks.io/promise/content/index.html" target="_blank" rel="external">JavaScript Promise迷你书（中文版）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fetch = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// resolve(&#39;success&#39;);&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            reject(&lt;span class=&quot;string&quot;&gt;&#39;error&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;, &lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; testAsync = &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt;() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; fetch();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (error) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.reject(error);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;testAsync().then(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;result&lt;/span&gt;)=&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;这是成功的---&amp;gt;&#39;&lt;/span&gt; + result);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;).catch(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;error&lt;/span&gt;)=&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;这是失败的---&amp;gt;&#39;&lt;/span&gt; + error);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;函数返回的一个 &lt;code&gt;Promise&lt;/code&gt;， 调用耗时函数前面加 &lt;code&gt;await&lt;/code&gt; 关键字，返回成功的值，可以使用 &lt;code&gt;try..catch&lt;/code&gt; 来进行捕获错误。上面的代码可以模拟一次请求的过程，最基本用法差不多都包括了
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>简单谈谈Redux在项目中的使用</title>
    <link href="http://yoursite.com/2016/12/05/Redux-1/"/>
    <id>http://yoursite.com/2016/12/05/Redux-1/</id>
    <published>2016-12-05T10:54:46.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h1><p><code>Reducer</code> :为了描述 <code>action</code> 如何改变 <code>state tree</code>。 输入 <code>action</code> 和 <code>state</code>，一般根据 <code>action</code> 的 <code>type</code> 进行区分，然后处理，改变 <code>state tree</code>。<a id="more"></a></p>
<p><code>Reducer</code> 是纯函数，纯函数就是输入一个值，会输出一个确定的值，也就是 <code>Reducer</code> 里面不应该有 <code>getDate()</code>, 调用 <code>API</code> 等等之类不确定的操作。</p>
<p>e.g :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">const</span> store = configStore(reducers)</div><div class="line"></div><div class="line">    KeyboardReducer</div><div class="line">    </div><div class="line">    <span class="keyword">export</span> <span class="keyword">const</span> setKeyboardHeight = createRequest(<span class="string">'setKeyboardHeight'</span>, (keyboardHeight) =&gt; &#123;</div><div class="line">    <span class="keyword">var</span> oldKeyboarHeight = store.getState()[<span class="string">'keyboardHeight'</span>];</div><div class="line">    <span class="keyword">if</span> (oldKeyboarHeight == keyboardHeight) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;keyboardHeight&#125;;</div><div class="line">&#125;</div><div class="line">    <span class="keyword">export</span> <span class="keyword">default</span> KeyboardReducer = handleActions(&#123;</div><div class="line">        [setKeyboardHeight]: acceptSuccessActionReducer,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">keyboardHeight</span>: <span class="number">0</span>,</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里有个 <code>KeyboardReducer</code> 的一个自定义的 <code>Reducer</code> ,用来处理键盘高度的事件，先不看实现，这个 <code>Reducer</code> 接受一个 <code>type</code>  为 <code>setKeyboardHeight</code> 的 <code>action</code> ，然后获取原 <code>store</code> 中的 <code>oldState</code> 中的 <code>keyboardHeight</code> ，然后对比，改变 <code>state tree</code> 中的 <code>keyboardHeight</code> 这个 <code>state</code>。 同时可以发现，在创建给某个模块使用的 <code>store</code> 的时候，这个 <code>reducer</code> 已经对 <code>state tree</code> 做了一些改变，设置了 <code>keyboardHeight : 0</code> 这个默认值,举例这个我们可以在cs模块的 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = configStore(reducers);</div><div class="line">store.dispatch(getQuestions());</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</div></pre></td></tr></table></figure>
<p>在处理模块自己的 <code>action</code> 之前，断点可以看到</p>
<pre><code>store.getState()[&apos;keyboardHeight&apos;] ：0
</code></pre><p>也就印证了我们的猜想。</p>
<h4 id="拆分-Reducer"><a href="#拆分-Reducer" class="headerlink" title="拆分 Reducer"></a>拆分 <code>Reducer</code></h4><p><code>Reducer</code>接受一个 <code>state</code> 和 <code>action</code> ，返回一个新的 <code>State</code>,如果项目很大，对应的 <code>state</code> 也会很大，如果使用一个 <code>Reducer</code> 进行整个的 <code>state</code> 的处理就会非常的臃肿。这个时候就可以进行拆分 <code>Reducer</code> ,每个 <code>Reducer</code> 去处理自己职责范围内的 <code>state</code> ，类似上面的  <code>KeyboardReducer</code> 就只对 <code>store.getState()[&#39;keyboardHeight&#39;];</code> 这个 <code>stage</code> 感兴趣。 因为 <code>store</code> 只有一个，当分成多个 <code>Reducer</code> 的时候，那就需要一个 <code>Reducer</code> 去管理这些 <code>Reducers</code> 。可以使用 <code>combineReducers</code> 进行 <code>Reducer</code> 的合成，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">state = &#123;&#125;,action</span>)</span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type)&#123;</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,........);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">state = &#123;&#125;,action</span>)</span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type)&#123;</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,........);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> App = combineReducers(&#123;</div><div class="line">    foo,</div><div class="line">    foo1</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在项目中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> reducers = handleActions(&#123;</div><div class="line">    [setBrandId]: acceptSuccessActionReducer,</div><div class="line">    [getBrandCatalogs]: acceptSuccessActionReducer,</div><div class="line">    [getBrandInfo]: acceptSuccessActionReducer,</div><div class="line">    [setOrderByAndDirect]: acceptSuccessActionReducer,</div><div class="line">    [getFilterInfo]: acceptSuccessActionReducer,</div><div class="line">    [setFilter]: acceptSuccessActionReducer,</div><div class="line">    [followBrand]: acceptSuccessActionReducer,</div><div class="line">    [setPriceSelect]: acceptSuccessActionReducer,</div><div class="line">    [getCampaign]: acceptSuccessActionReducer,</div><div class="line">    [resetgetCampaigned]: acceptSuccessActionReducer,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里每个请求都对于同样的 <code>acceptSuccessActionReducer</code> 这个 <code>Reducer</code>，代码很简单就不贴了，最终这些 <code>reducer</code> 的统一处理是在 <code>createStore</code> 的时候，下面会说到</p>
<p>项目中管理这些 <code>Reducers</code> 是使用了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">reduceReducers(actionStateReducers, KeyboardReducer, reducer)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">reduceReducers</span>(<span class="params">...reducers</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</div><div class="line">        <span class="comment">//框架的安全检查类型，可暂时忽略。。</span></div><div class="line">        <span class="comment">// if (action.type === ActionTypes.INIT) &#123;</span></div><div class="line">        <span class="keyword">if</span> (action.type === <span class="string">'@@redux/INIT'</span>) &#123;</div><div class="line">            <span class="keyword">var</span> state = &#123;&#125;;</div><div class="line">            <span class="comment">// collect all init state.</span></div><div class="line">            reducers.forEach(<span class="function"><span class="params">reduce</span> =&gt;</span> &#123;</div><div class="line">                state = <span class="built_in">Object</span>.assign(state, reduce(<span class="literal">undefined</span>, action));</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> reducers.reduce(</div><div class="line">                <span class="comment">//迭代累加调用reducer</span></div><div class="line">                (state, reduce) =&gt; reduce(state, action),</div><div class="line">                state</div><div class="line">            );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a><code>Action</code></h1><p><code>Action</code>可以理解为一个动作或者事件。它的作用是将信息传递给某个 <code>Reducer</code> 进而去影响 <code>State tree</code>,而使用这些 <code>Action</code> 只有一种方法就是 <code>store.dispatch(action)</code>, 在项目中可以手动去调用，也可以使用 <code>react-redux</code> 的 <code>bindActionCreators</code>方法自动将多个 <code>Action</code> 绑定到 <code>Dispatch()</code> 方法上。这个肯定也是调用了 <code>store.dispatch(action)</code> ,一般的 <code>Action</code> 的结构类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    type: &quot;action-type&quot;</div><div class="line">    value: &quot;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>action</code>的定义十分灵活，一般只有 <code>type</code>是固定的，其他随便。但是在异步的 <code>action</code> 中，通过 <code>actionCreater</code>创建的一般都是 <code>function</code>，返回值才是起作用的 <code>action</code>。</p>
<h1 id="Store"><a href="#Store" class="headerlink" title="Store"></a><code>Store</code></h1><p>每个 <code>Redux</code>应用只有一个 <code>store</code>，如果觉得数据很多很臃肿，应该去使用组合 <code>Reducer</code> 的方法而不是去创建多个 <code>store</code> 解决。 <code>store</code>  有下面几个重要方法：</p>
<ul>
<li><code>store.getState</code> 对当前 <code>store</code> 进行快照，获取当前 <code>store</code> 对应的 <code>state</code>.</li>
<li><code>dispatch(action)</code> 分发 <code>action</code> 给 <code>reducer</code>。</li>
<li><code>subscribe(listener)</code> 注册监听器，当 <code>store</code> 改变时回调监听器。</li>
</ul>
<p>e.g.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">//当进入品牌详情页面，设置brandId导致store的改变，进而回调这里，去请求网络。</span></div><div class="line">    <span class="keyword">var</span> brandId = store.getState()[<span class="string">'brandId'</span>];</div><div class="line">    <span class="keyword">if</span>(brandId &amp;&amp; brandId !== lastBrandId) &#123;</div><div class="line">        lastBrandId = brandId;</div><div class="line">        store.dispatch(getBrandInfo());</div><div class="line">        store.dispatch(getFilterInfo());</div><div class="line">        store.dispatch(getBrandCatalogs(<span class="literal">true</span>));</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a><code>Middleware</code></h1><p>对于中间件，看这个就够了，我也说不了比它更好：</p>
<p><a href="http://cn.redux.js.org/docs/advanced/Middleware.html" target="_blank" rel="external">点击了解Middleware</a></p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><p>来简单的看一下项目中的一个请求 <code>action</code> 是如果经过一步步到最终 UI 上面展示的。先从创建 <code>Store</code> 开始，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//参数reducer是我们在模块中自己定义 一般一个请求对应一个reducer 参考actions目录</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configStore</span>(<span class="params">reducer</span>) </span>&#123;</div><div class="line">    <span class="comment">//createStore 第一个参数是reducer</span></div><div class="line">    <span class="keyword">const</span> store = createStore(</div><div class="line">        <span class="comment">//array.reducer类似一个迭代累加的效果 这里就是迭代去调用各种reducer,累加对store的影响</span></div><div class="line">        <span class="comment">//actionStateReducers:主要是为了异步的action 自动多了ACTION_WILL_START,ACTION_WILL_END这两个action</span></div><div class="line">        <span class="comment">//KeyboardReducer :处理键盘的</span></div><div class="line">        <span class="comment">//我们在模块中自己定义的各个reducer 详情见模块下的actions/index.js 中的export const reducers = handleActions。。。。。</span></div><div class="line">        <span class="comment">//类似注册的作用 预先创建各个 Reducers 到使用的时候一般由下面的中间件中调用。</span></div><div class="line">        reduceReducers(actionStateReducers, KeyboardReducer, reducer),</div><div class="line">        </div><div class="line">        <span class="comment">//Middleware作用在action创建之后,到达reducer之前的阶段</span></div><div class="line">        <span class="comment">//actionStateMiddleware:对应上面的actionStateReducers,处理多出来的两个action</span></div><div class="line">        <span class="comment">//会去调用上面注册的东西</span></div><div class="line">        applyMiddleware(actionStateMiddleware, errorHandlerMiddleware, promiseMiddleware, createLogger(&#123;</div><div class="line">            <span class="attr">predicate</span>: <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (action.type === <span class="string">'ACTION_WILL_START'</span> || action.type === <span class="string">'ACTION_WILL_END'</span> || action.type === <span class="string">'CONCURRENT_EXECUTION_ERROR'</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;,</div><div class="line">        &#125;))</div><div class="line">    );</div><div class="line"></div><div class="line">    global.store = store;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> store;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们去创建一个请求，都是使用 <code>createRequest</code> ，其实也就是创建了一个 <code>action</code> ，但是这个 <code>action</code> 是个 <code>function</code>，这个 <code>function</code>的返回值是真正的 <code>action</code>， 这个先不管，但是起作用的 <code>action</code> 结构类似 ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//同步 &#123;</span></div><div class="line">        <span class="comment">//   type:setBrandId</span></div><div class="line">        <span class="comment">//   payload:object</span></div><div class="line">        <span class="comment">// &#125;</span></div><div class="line"><span class="comment">//异步&#123;</span></div><div class="line">        <span class="comment">//   type:getBrand</span></div><div class="line">        <span class="comment">//   payload:promise</span></div><div class="line">        <span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>对于最常用的异步 <code>action</code> ,对应与 <code>actionStateReducers</code> 这个 <code>reducer</code> ，详情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//每个action都会多创建这两个action，在原始action开始和结束的时候分发。</span></div><div class="line"><span class="keyword">const</span> actionWillStart = createAction(<span class="string">'ACTION_WILL_START'</span>);</div><div class="line"><span class="keyword">const</span> actionDidEnd = createAction(<span class="string">'ACTION_WILL_END'</span>);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> actionStateReducers = handleActions(&#123;</div><div class="line">    [actionWillStart]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">var</span> actionName = action.payload;<span class="comment">//请求回来的数据会在action.payload中 进而去改变store action type也就是请求名</span></div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'调用处理开始的action的地方,action--&gt;'</span>, action);</div><div class="line"></div><div class="line">        <span class="comment">//state中包含actionstate和我们自己定义的各种state</span></div><div class="line">        <span class="keyword">var</span> actionState = state[<span class="string">'actionState'</span>];</div><div class="line">        <span class="comment">//actionstate的结构类似这样:</span></div><div class="line">        <span class="comment">//&#123;</span></div><div class="line">        <span class="comment">// getLiveShow:1   //是action的名称 和 数量 这个数量暂时还不知道是干什么用的  一般就是0或者1</span></div><div class="line">        <span class="comment">// &#125;</span></div><div class="line">        <span class="keyword">var</span> count = actionState[actionName];</div><div class="line">        <span class="keyword">if</span> (count) &#123;</div><div class="line">            count += <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            count = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        actionState[actionName] = count;</div><div class="line">        <span class="comment">//如果是ACTION_WILL_START这个action  就把对应的action中的actionstate +1 表明创建了这个一个action??</span></div><div class="line">        <span class="comment">//然后应用修改的state</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;actionState&#125;);</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//这个是ACTION_WILL_END 同上</span></div><div class="line">    [actionDidEnd]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;<span class="comment">//在数据回来的时候调用</span></div><div class="line">        <span class="keyword">var</span> actionName = action.payload;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> actionState = state[<span class="string">'actionState'</span>];</div><div class="line">        <span class="keyword">var</span> count = actionState[actionName];</div><div class="line">        --count;</div><div class="line">        actionState[actionName] = count;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'调用处理结束的action的地方,action--&gt;'</span>, action);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;actionState&#125;);</div><div class="line">    &#125;,</div><div class="line">&#125;, &#123;</div><div class="line">    <span class="attr">actionState</span>: &#123;&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> 上面的代码主要是帮我们多创建了两个 <code>action</code>，而何时去调用，调用的顺序是在下面的 <code>actionStateMiddleware</code> 中定义的，详情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">actionStateMiddleware</span>(<span class="params">&#123;dispatch, getState&#125;</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</div><div class="line">            <span class="comment">// action throttling</span></div><div class="line">            <span class="keyword">if</span> (isPromise(action.payload)) &#123;</div><div class="line">                <span class="keyword">if</span> (action.type == <span class="string">'CONCURRENT_EXECUTION_ERROR'</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> next(action);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'进来中间件,action--&gt;'</span>, action);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (action.type !== actionWillStart.toString() &amp;&amp;</div><div class="line">                    action.type !== actionDidEnd.toString()) &#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">'分发开始的action,action--&gt;'</span>, action);</div><div class="line">                    dispatch(actionWillStart(action.type));<span class="comment">//不是那两种 action, 分发actionWillStart:&#123;type:action.type&#125;</span></div><div class="line">                &#125;</div><div class="line">                <span class="comment">//这里的payload是个promise</span></div><div class="line">                action.payload.then(</div><div class="line">                    <span class="function"><span class="params">result</span> =&gt;</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (action.type !== actionWillStart.toString() &amp;&amp;</div><div class="line">                            action.type !== actionDidEnd.toString()) &#123;</div><div class="line">                            <span class="built_in">console</span>.log(<span class="string">'分发结束的action,action--&gt;'</span>, action);</div><div class="line">                            dispatch(actionDidEnd(action.type));<span class="comment">//数据回来的时候 调用这个</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;,</div><div class="line">                    error =&gt; &#123;</div><div class="line">                        <span class="keyword">if</span> (action.type !== actionWillStart.toString() &amp;&amp;</div><div class="line">                            action.type !== actionDidEnd.toString()) &#123;</div><div class="line">                            dispatch(actionDidEnd(action.type));</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                );</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isFSA(action) &amp;&amp; !action.error &amp;&amp; !action.payload) &#123;</div><div class="line">                <span class="comment">// return action directly, and the payload will not be reduced into store.</span></div><div class="line">                <span class="keyword">return</span> action;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> next(action);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而处理原始的 <code>action</code> 则是在 <code>acceptSuccessActionReducer</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">acceptSuccessActionReducer</span>(<span class="params">state, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!action.error &amp;&amp; action.payload) &#123;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'调用处理原始的action的地方,action--&gt;'</span>, action);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, action.payload);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>何时去调用则是在 <code>promiseMiddleware</code> 这个中间件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">....略</div><div class="line"> return isPromise(action.payload) ? action.payload.then(function (result) &#123;</div><div class="line">        return dispatch(_extends(&#123;&#125;, action, &#123; payload: result &#125;));</div><div class="line">....</div></pre></td></tr></table></figure>
<p>最后以品牌详情切换排序方式为例，看一下完整的 <code>action</code> 到 UI 改变的过程。</p>
<p><img src="http://7xjlmz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-04%20%E4%B8%8B%E5%8D%888.54.40.png" alt=""> </p>
<p>无论是开始还是结束的action，都会触发 <code>state</code> 中的 <code>actionState</code> 的改变，进而触发 <code>store</code> 的改变，进而触发页面中 <code>state</code> 的更新。所以会出现多次更新 UI的情况。</p>
<p>createRequest<br>-&gt;dispatch(action)<br>-&gt;actionStateMiddleware<br>-&gt;dispatch(actionWillStart(action.type))<br>-&gt;reduceReducers<br>-&gt;迭代执行reducers(1:包括start,end的actionStateReducers，2：KeyboardReducer，3：模块中定义的reducers：handactions(…..))<br>-&gt;调用handleActions中start action对应的reducer逻辑<br>-&gt;修改start action 对应的actionstate<br>-&gt;请求结果返回<br>-&gt;调用handleActions中end action对应的reducer逻辑<br>-&gt;修改end action 对应的actionstate<br>-&gt;调用promiseMiddleware中的promise响应<br>-&gt;修改store<br>-&gt;调用组件中mapStateToProps<br>-&gt;调用componentWillReceiveProps。</p>
<h2 id="Why-Redux"><a href="#Why-Redux" class="headerlink" title="Why Redux"></a><code>Why Redux</code></h2><p>扯了半天，为什么要用 <code>Redux</code>? 它的定义是 :<strong>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</strong> 为什么说是可预测的状态，因为一个确定的 <code>state</code> 就对应一个确定的 <code>view</code>，使用 <code>Redux</code> 能感受到它的数据的单向流动性，用户触发某个动作，发出一个 <code>action</code> ，经过 <code>Reducer</code>,改变 <code>store</code> 的数据，进而去控制 UI的效果，仅仅有这一种方式，单向数据流也保证了可预测的状态。如果不这样做，我们的 <code>View</code> 可以被各种各样的 <code>event</code>,<code>Model</code>甚至其他的 <code>View</code>控制，一个 <code>View</code> 的状态无法预测，当改变因素很多的时候就无法控制。这只是我浅显的理解。<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/WechatIMG4.jpeg" alt=""></p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>好大老师改了原 <code>actions/index.js</code>和 <code>store/index.js</code>，结合了这两个，看完了上面的这些东西，再去看改动应该就没什么压力了，也更理解为什么这么改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Reducer&quot;&gt;&lt;a href=&quot;#Reducer&quot; class=&quot;headerlink&quot; title=&quot;Reducer&quot;&gt;&lt;/a&gt;Reducer&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Reducer&lt;/code&gt; :为了描述 &lt;code&gt;action&lt;/code&gt; 如何改变 &lt;code&gt;state tree&lt;/code&gt;。 输入 &lt;code&gt;action&lt;/code&gt; 和 &lt;code&gt;state&lt;/code&gt;，一般根据 &lt;code&gt;action&lt;/code&gt; 的 &lt;code&gt;type&lt;/code&gt; 进行区分，然后处理，改变 &lt;code&gt;state tree&lt;/code&gt;。
    
    </summary>
    
    
      <category term="Redux" scheme="http://yoursite.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Router设计</title>
    <link href="http://yoursite.com/2016/11/16/Router%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2016/11/16/Router设计/</id>
    <published>2016-11-16T11:20:57.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近公司的项目要进行页面间跳转的重构，首先项目是单 <code>Activity</code> + 多 <code>Fragment</code> 的结构，因为是电商的项目，所以涉及到很多 H5 , <code>Native</code> 和 <code>React Native</code> 页面之间的交互与跳转，这篇不是介绍两者之间是如何进行通信的，而是当 H5 或者外部分享的链接打开后传递过来 <code>Uri</code> 要解析跳转到 <code>Native</code> 的页面的处理。当然各个页面的 <code>Host</code>  是提前统一定义好的，具体的做法这里也不说了，也没什么难点。原来的写法是都放到一个 <code>Util</code> 类里面，各种 <code>Switch</code> <code>Case</code> 来进行分支判断，当项目越来越大维护起来十分的困难，而且本身 <code>Native</code> 的页面之间还有一套跳转的逻辑，同时维护两套的代价是很大的，所有希望将项目重构一下，统一两端的处理逻辑，就产生了下面的这个路由结构。<a id="more"></a></p>
<p>&emsp;&emsp;在开始重构之前，也是去搜索了一下网上的一些开源例子，绝大多数都是基于 <code>Activity</code> 的跳转，写的功能虽然很多，但是对于我们的项目却是很冗余并且也不怎么合适，所以要去定制一套适合自己的路由，目标就是统一 H5 , <code>Native</code> 和 <code>React Native</code> 这三端之间的跳转逻辑，同时做到简单易用，容易维护和容易拓展。去写人人都能很容易看的懂的代码，而不是写那么花里胡哨的各种”炫技”的代码。</p>
<p>&emsp;&emsp;先放一下这个项目的类图，不怎么熟悉 <code>UML</code>,里面有些关系表示的不正确，大概的意思还是可以表达出来的。首先要去统一两端的逻辑，肯定需要在跳转直接转换成统一的 <code>Uri</code> 进行跳转，从 H5 过来的就很简单就是个 <code>Uri</code>,而 <code>Native</code> 的跳转则要去进行处理拼接，然后通过统一的路由进行处理，最后跳转到具体的页面。</p>
<p><img src="http://7xjlmz.com1.z0.glb.clouddn.com/Class%20Diagram%20%282%29.png" alt=""></p>
<p>&emsp;&emsp;先说一下设计的思想，一个页面对应一个 <code>Uri</code>,并且使用不同的 <code>Host</code> 或者 <code>Path</code> 进行区分和信息的传递，这里先建立了一个全局的”路由表”,让 <code>Url</code> 和一个具体页面的切换器进行对应，当路由获取到一个 <code>Uri</code> 的时候，在路由表中找到对应的切换器，切换到具体的页面。当然在切换之前还需要一些其他的处理，这里加入了拦截器的机制，默认实现了两种拦截器，<code>LoginInterceptor</code> 和 <code>LogInterceptor</code> 分别进行需要登录页面的 <code>Uri</code> 的拦截使其跳转到登录页面和打印 <code>Uri</code> 和其他跳转参数。当然也可以去实现其他的拦截器，这样就使得整个路由十分的灵活。</p>
<p>&emsp;&emsp;说一下怎么使用，首先在 <code>Application</code> 中初始化路由表，这个路由表是个 <code>pageMap : Map&lt;String, Switcher&gt;</code> ，这里的 <code>Key</code> 就是每个页面对应的 <code>Host</code> ,<code>Value</code> 的 <code>Switcher</code> 就是处理每个页面切换逻辑的地方，类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pageMap.put(REACT_NATIVE, new RnSwitcher());</div><div class="line">pageMap.put(SCHEMA_HTTP, new H5Switcher());</div><div class="line">pageMap.put(HOST_CATALOG, new CatalogDetailSwitcher());</div></pre></td></tr></table></figure>
<p>这样就初始化了全局的路由表。因为是单 <code>Activity</code> +多 <code>Fragment</code> 的结构，几乎所有的页面都是 <code>Fragment</code> ,不像切换 <code>Activity</code> 那么简单，这里要去处理相对复杂的 <code>Fragment</code> 的切换逻辑和维护回退栈的操作，所以封装了一个 <code>NavigationManager</code> 用来处理这些操作。看一下初始化的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Router.install(mNavigationManager)</div><div class="line">            .addInterceptor(new LoginInterceptor())</div><div class="line">            .addInterceptor(new LogInterceptor());</div></pre></td></tr></table></figure>
<p>因为要持有 <code>Activiry</code> 所以要在 <code>onDestroy</code> 的时候及时释放引用 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Router.unInstall();</div></pre></td></tr></table></figure>
<p>然后看一下具体的跳转：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Router.config().setUri(uri).start()</div></pre></td></tr></table></figure>
<p>这样就可以跳转到具体的页面了，当然只是简单的示例一下，实际使用的时候肯定还有其他的配置。因为使用者不可能记得每个页面的 <code>Uri</code> 是怎么拼接的，所以还可以在写个工具类来封装一下，这个就不说了。</p>
<p> &emsp;&emsp;说一下这个路由的优点：</p>
<ol>
<li>简单易懂，几乎人人都读得懂，基本不需要学习成本。更没有任何的注解反射之类的。</li>
<li>方便统一进行跳转管理，使用了拦截器，可以打印出跳转中的 <code>Uri</code> 和其他参数，调试十分方便。加入了登录拦截器，使得跳转可以无脑跳转，无需关心页面是否需要登录，路由帮你做好了判断和后续登录成功跳转到目标页面。</li>
<li>容易拓展，无论是新增页面还是修改维护旧页面。将每个页面切换逻辑封装到对应的 <code>Switcher</code> 里面，快速定位。</li>
<li>统一 <code>H5</code> , <code>Native</code> 和 <code>React Native</code> 三端的跳转，更加方便维护。</li>
<li>啦啦啦啦。。。</li>
</ol>
<p>&emsp;&emsp;以后甚至可以将路由表让服务端去控制，无论是灵活性还是稳定性都大大提高，只是目前还没有这样的需求，但是改造起来将十分的简单。这个路由从设计到项目的改造大概花了一周的时间，也算是独立设计开发的完整的重要模块，现在还处于比较初级的阶段，肯定有提升空间。目前用在 <a href="http://www.bolome.com/" target="_blank" rel="external">波罗蜜全球购</a> 的 <code>Android</code> 客户端中，欢迎大家支持。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;最近公司的项目要进行页面间跳转的重构，首先项目是单 &lt;code&gt;Activity&lt;/code&gt; + 多 &lt;code&gt;Fragment&lt;/code&gt; 的结构，因为是电商的项目，所以涉及到很多 H5 , &lt;code&gt;Native&lt;/code&gt; 和 &lt;code&gt;React Native&lt;/code&gt; 页面之间的交互与跳转，这篇不是介绍两者之间是如何进行通信的，而是当 H5 或者外部分享的链接打开后传递过来 &lt;code&gt;Uri&lt;/code&gt; 要解析跳转到 &lt;code&gt;Native&lt;/code&gt; 的页面的处理。当然各个页面的 &lt;code&gt;Host&lt;/code&gt;  是提前统一定义好的，具体的做法这里也不说了，也没什么难点。原来的写法是都放到一个 &lt;code&gt;Util&lt;/code&gt; 类里面，各种 &lt;code&gt;Switch&lt;/code&gt; &lt;code&gt;Case&lt;/code&gt; 来进行分支判断，当项目越来越大维护起来十分的困难，而且本身 &lt;code&gt;Native&lt;/code&gt; 的页面之间还有一套跳转的逻辑，同时维护两套的代价是很大的，所有希望将项目重构一下，统一两端的处理逻辑，就产生了下面的这个路由结构。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>React Native + Redux + React-Redux</title>
    <link href="http://yoursite.com/2016/09/30/Redux/"/>
    <id>http://yoursite.com/2016/09/30/Redux/</id>
    <published>2016-09-30T07:17:53.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>Component</code>中的<code>state</code>相当于组件内的本地变量，用于储存view的本地变化</p>
<p><code>props</code>中存储数据， <code>props</code>属于readOnly的常量dic<a id="more"></a></p>
<p>store相当于全集的数据状态仓库，只有一个，改变它的唯一方式就是store.dispatch(action)，可以通过store.getState对当前的store进行一次快照，store还有store.subscribe方法，也就是在store.dispatch触发了store的数据更新，回调这个subscribe方法。</p>
<p>使用了React-Redux这个库有两个重要的方法：<code>mapStateToProps</code>是用来把外部的state,也就是当前store的快照映射到UI组件的参数上(props),也就是输入数据。<code>mapDispatchToProps</code>是把对UI组件的操作映射成action，</p>
<p>当dispatch一个action后，reduce会自动生成一个当前store的快照 =&gt;state，调用mapStateToProps，将state映射到props,调用React native的生命周期方法<code>componentWillReceiveProps</code>,这里可以再处理一下数据，改变this.state的值。</p>
<p><code>mapStateToProps</code>会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;Component&lt;/code&gt;中的&lt;code&gt;state&lt;/code&gt;相当于组件内的本地变量，用于储存view的本地变化&lt;/p&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt;中存储数据， &lt;code&gt;props&lt;/code&gt;属于readOnly的常量dic
    
    </summary>
    
    
      <category term="React Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit源码浅析</title>
    <link href="http://yoursite.com/2016/08/17/Refrofit%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2016/08/17/Refrofit源码浅析/</id>
    <published>2016-08-16T16:49:43.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p> 这篇主要会走读一下<code>Retrofit</code>的源码，解析一下里面遇到的一些设计模式，网络请求的过程等。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>从创建<code>Retrofit</code>开始，看一下常见的创建<code>Retrofit</code>的实例的方式<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();</div><div class="line">        interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</div><div class="line">        OkHttpClient client = new OkHttpClient.Builder()</div><div class="line">                .addInterceptor(interceptor)</div><div class="line">                .retryOnConnectionFailure(true)</div><div class="line">                .connectTimeout(15, TimeUnit.SECONDS)</div><div class="line">                .addNetworkInterceptor(createHeaderInterceptor())</div><div class="line">                .build();</div><div class="line">                </div><div class="line">Retrofit retrofit = new Retrofit.Builder()</div><div class="line">                .baseUrl(BuildConfig.BASE_API_URL)</div><div class="line">                .client(client)</div><div class="line">                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div><div class="line">                .addConverterFactory(BolomeGsonConverterFactory.create())</div><div class="line">                .build();</div><div class="line">          Net net = retrofit.create(Net.class)</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出，<code>Retrofit</code>并没有去真正的执行网络请求，还是交给了<code>OkHttp</code>来进行实现，<code>Retrofit</code>可以看作的对<code>OkHttp</code>的一层非常棒的封装，<code>Retrofit</code>的关注点是在如何让你更快捷更灵活的去进行网络请求。如果你使用过<code>Retrofit</code>的话，你也会明白用<code>Retrofit</code>去实现一次网络请求是多方便的事情。</p>
<h3 id="retrofit-create"><a href="#retrofit-create" class="headerlink" title="retrofit.create"></a><code>retrofit.create</code></h3><p>从<code>Net net = retrofit.create(Net.class)</code>这里开始入手，用过<code>Retrofit</code>的几乎都知道<code>Retrofit</code>是用了动态代理，动态代理说简单点就是动态的去生成接口的实现类，也可以在原始的结果返回前对参数或者结果进行修改，这个特性也使得一些<code>Hook</code>框架大量使用了动态代理，比如很著名的360的<code>DroidPlugin</code>。有点扯远了，还是去源码里面去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</div><div class="line">  ...</div><div class="line">  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">      new InvocationHandler() &#123;</div><div class="line">        private final Platform platform = Platform.get();</div><div class="line"></div><div class="line">        @Override public Object invoke(Object proxy, Method method, Object... args)</div><div class="line">            throws Throwable &#123;</div><div class="line">          ...</div><div class="line">          ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">          OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">          return serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里省略了一下判断的逻辑，但是主要的就是最后的三行代码，从方法的签名来看，是传进来一个接口类，返回一个接口类型的实例，但是这个实例的具体实现类型是由<code>serviceMethod.callAdapter.adapt</code>方法动态决定了，而且这个接口里面的每一次方法调用，都会进入这个<code>invoke</code>方法，也就是由接口的实现类去完成功能。例如，<code>Retrofit</code>默认的请求方式是<code>Call&lt;T&gt;</code>,这里默认的实现类就是<code>ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt;</code>，而在这个类里面又是用代理类的方式去交给<code>Okhttp</code>的<code>call</code>去执行真正的请求，这个就是后面再说了。</p>
<h3 id="ServiceMethod"><a href="#ServiceMethod" class="headerlink" title="ServiceMethod"></a><code>ServiceMethod</code></h3><p>这个类主要是储存了请求的信息和<code>Retrofit</code>的配置信息以及对请求注解的解析生成正常的地址和请求。</p>
<h3 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a><code>OkHttpCall</code></h3><p>第二行<code>OkHttpCall</code>可以看成是<code>OkHttp</code>的<code>call</code>在<code>Retrofit</code>层面的一次封装。从上面一步看到，把请求参数和配置信息交给了这个<code>OkHttpCall</code>，然后让<code>OkHttp</code>去执行请求操作。</p>
<h3 id="callAdapter"><a href="#callAdapter" class="headerlink" title="callAdapter"></a><code>callAdapter</code></h3><p>不知道该怎么去具体描述这个类的意思，可以理解成将请求转换成不同的请求形式，例如默认的<code>call</code>或者常见的<code>Rxjava</code>的<code>Observable&lt;T&gt;</code>的形式亦或者是<code>Agera</code>的<code>Supplier&lt;Result&lt;T&gt;&gt;</code>的形式等等。以<code>@drakeet</code>的<a href="https://github.com/drakeet/retrofit-agera-call-adapter" target="_blank" rel="external">retrofit-agera-call-adapter</a>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">public final class AgeraCallAdapterFactory extends CallAdapter.Factory &#123;</div><div class="line"></div><div class="line">    public static AgeraCallAdapterFactory create() &#123;</div><div class="line">        return new AgeraCallAdapterFactory();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private AgeraCallAdapterFactory() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">        ...</div><div class="line">        支持Supplier&lt;Result&lt;T&gt;&gt;形式</div><div class="line">            return new BodyCallAdapter(innerTypeOfInnerType);</div><div class="line">        &#125;</div><div class="line">        ...支持Supplier&lt;Result&lt;Response&lt;T&gt;&gt;&gt;形式</div><div class="line">        return new ResponseCallAdapter(responseType);</div><div class="line">    &#125;</div><div class="line">    private static class BodyCallAdapter implements CallAdapter&lt;Supplier&lt;?&gt;&gt; &#123;</div><div class="line"></div><div class="line">        private final Type responseType;</div><div class="line"></div><div class="line"></div><div class="line">        BodyCallAdapter(Type responseType) &#123;</div><div class="line">            this.responseType = responseType;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        @Override public Type responseType() &#123;</div><div class="line">            return responseType;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        @Override</div><div class="line">        public &lt;T&gt; Supplier&lt;Result&lt;T&gt;&gt; adapt(Call&lt;T&gt; call) &#123;</div><div class="line">            return new CallSupplier(call);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class CallSupplier&lt;T&gt; implements Supplier&lt;Result&lt;T&gt;&gt; &#123;</div><div class="line"></div><div class="line">    private final Call&lt;T&gt; originalCall;</div><div class="line"></div><div class="line"></div><div class="line">    CallSupplier(@NonNull final Call&lt;T&gt; call) &#123;</div><div class="line">        this.originalCall = checkNotNull(call);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @NonNull @Override public Result&lt;T&gt; get() &#123;</div><div class="line">        Result&lt;T&gt; result;</div><div class="line">        try &#123;</div><div class="line">            Response&lt;T&gt; response = originalCall.clone().execute();</div><div class="line">            //将Response转换成Result&lt;T&gt;的形式 因为数据要从Result中取，而不像默认的call那样直接走回调</div><div class="line">            if (response.isSuccessful()) &#123;</div><div class="line">                result = Result.success(response.body());</div><div class="line">            &#125; else &#123;</div><div class="line">                result = Result.failure(new HttpException(response));</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            result = Result.failure(e);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码没太多难度，看看就明白了。也是非常棒的自定义<code>CallAdapter</code>教程。</p>
<h3 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a><code>enqueue</code></h3><p>异步请求的时候是这个样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mNet.getLiveShows(20, 1).enqueue(new Callback&lt;LiveBlock&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onResponse(Call&lt;LiveBlock&gt; call, Response&lt;LiveBlock&gt; response) &#123;</div><div class="line">               </div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onFailure(Call&lt;LiveBlock&gt; call, Throwable t) &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure>
<p>而<code>getLiveShows</code>返回的<code>call</code>其实是上面说的<code>ExecutorCallbackCall</code>，这个的<code>enqueue</code>是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">      if (callback == null) throw new NullPointerException(&quot;callback == null&quot;);</div><div class="line"></div><div class="line">      delegate.enqueue(new Callback&lt;T&gt;() &#123;</div><div class="line">        @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</div><div class="line">          callbackExecutor.execute(new Runnable() &#123;</div><div class="line">            @Override public void run() &#123;</div><div class="line">              if (delegate.isCanceled()) &#123;</div><div class="line">                // Emulate OkHttp&apos;s behavior of throwing/delivering an IOException on cancellation.</div><div class="line">                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">              &#125; else &#123;</div><div class="line">                callback.onResponse(ExecutorCallbackCall.this, response);</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</div><div class="line">          callbackExecutor.execute(new Runnable() &#123;</div><div class="line">            @Override public void run() &#123;</div><div class="line">              callback.onFailure(ExecutorCallbackCall.this, t);</div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用了<code>delegate.enqueue</code>这个<code>delegate</code>就是上面说到的<code>OkHttpCall</code>看这个里面的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">call.enqueue(new okhttp3.Callback() &#123;</div><div class="line">      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)</div><div class="line">          throws IOException &#123;</div><div class="line">        Response&lt;T&gt; response;</div><div class="line">        try &#123;</div><div class="line">          response = parseResponse(rawResponse);</div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">          callFailure(e);</div><div class="line">          return;</div><div class="line">        &#125;</div><div class="line">        callSuccess(response);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public void onFailure(okhttp3.Call call, IOException e) &#123;</div><div class="line">        try &#123;</div><div class="line">          callback.onFailure(OkHttpCall.this, e);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      private void callFailure(Throwable e) &#123;</div><div class="line">        try &#123;</div><div class="line">          callback.onFailure(OkHttpCall.this, e);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      private void callSuccess(Response&lt;T&gt; response) &#123;</div><div class="line">        try &#123;</div><div class="line">          callback.onResponse(OkHttpCall.this, response);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;</div><div class="line">    ResponseBody rawBody = rawResponse.body();</div><div class="line">   .....//使用responseConverter.convert(body)</div><div class="line">      T body = serviceMethod.toResponse(catchingBody);</div><div class="line">      return Response.success(body, rawResponse);</div><div class="line">    ....</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>注意的是这里几个<code>call</code>的区别和三个<code>enqueue</code>的区别和作用</p>
<p>###<code>Converter</code><br>这个是用来将<code>RequestBody</code>和<code>responseBody</code>转换成相应的类型，具体去看看官方的<code>GsonConverterFactory</code>就可以了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 这篇主要会走读一下&lt;code&gt;Retrofit&lt;/code&gt;的源码，解析一下里面遇到的一些设计模式，网络请求的过程等。&lt;/p&gt;
&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;从创建&lt;code&gt;Retrofit&lt;/code&gt;开始，看一下常见的创建&lt;code&gt;Retrofit&lt;/code&gt;的实例的方式&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>浅谈CoordinatorLayout</title>
    <link href="http://yoursite.com/2016/08/01/%E6%B5%85%E8%B0%88CoordinatorLayout/"/>
    <id>http://yoursite.com/2016/08/01/浅谈CoordinatorLayout/</id>
    <published>2016-08-01T14:24:32.000Z</published>
    <updated>2017-07-28T13:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>最近这一周空余的时间比较多，然后去重构了一个公司项目里的一个个人中心的页面，原来使用了<code>ListView</code>再加上<code>addHead</code>的方式，然后动态的去控制<code>Head</code>的高度去实现嵌套滑动的效果，因为我的模拟器没有跑起来，所以也没有去录下个GIF来，因为这篇主要说一下<code>CoordinatorLayout</code>的处理嵌套滑动的原理，没有效果图也影响不大。<a id="more"></a></p>
<h4 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h4><p>先写出来点大纲吧：</p>
<ul>
<li>为什么要有<code>CoordinatorLayout</code> </li>
<li><code>CoordinatorLayout</code>是怎么实现嵌套滑动的事件分发的</li>
<li><code>AppBarLayout</code>的一些东西</li>
</ul>
<h4 id="为什么要有CoordinatorLayout"><a href="#为什么要有CoordinatorLayout" class="headerlink" title="为什么要有CoordinatorLayout"></a>为什么要有<code>CoordinatorLayout</code></h4><p>先来回想一下<code>Android</code>系统的事件分发有什么不足的地方，就是一个<code>view</code>消费了事件，与此同时，其他的<code>view</code>的没有机会去接触到这个事件了。也就是在一个事件的某一时刻，有且只有一个<code>View</code>去相应这个事件。那么当我们要去做一些嵌套滑动的时候，就会有一些不方便。例如需要一个<code>View</code>跟随另一个<code>View</code>滑动，一般就是一个<code>CallBack</code>进行滑动状态的回调。<code>CoordinatorLayout</code>就可以比较优雅的处理这种事件。</p>
<h4 id="CoordinatorLayout是怎么实现嵌套滑动的事件分发的"><a href="#CoordinatorLayout是怎么实现嵌套滑动的事件分发的" class="headerlink" title="CoordinatorLayout是怎么实现嵌套滑动的事件分发的"></a><code>CoordinatorLayout</code>是怎么实现嵌套滑动的事件分发的</h4><p>先说一下两个接口吧，<code>NestedScrollingParent</code>和<code>NestedScrollingChild</code>，这两个接口看名字就比较容易理解他们的作用，就是一个给嵌套滑动的parent实现的，一个是给child实现，在现在的组件中，只有<code>CoordinatorLayout</code>实现了parent，所以下面说到parent就理解成<code>CoordinatorLayout</code>就OK啦，而child这个接口其实方法已经在<code>View</code>这个类里面帮我们实现好了，也就是说想要去成为一个可以嵌套滑动的child，仅仅去实现这个child接口就OK了，其他的<code>View</code>已经帮你写完了。下面还是以<code>RecycleView</code>为例子，它是实现了这个child的接口，还是回到情景里面说吧，说一下到底是怎么传递事件的。</p>
<ul>
<li>在<code>ReclceView</code>上down -&gt; <code>parent.onStartNestedScroll</code> -&gt;遍历有<code>Behavior</code>的直接子view -&gt;child的<code>Behavior.onStartNestedScroll</code>。<br>这里说一下<code>onStartNestedScroll</code>这个方法是有boolean的返回值，<code>true</code>的意思是要去处理这个事件，同时还会去调用<code>parent.onNestedScrollAccepted</code> -&gt; 遍历有<code>Behavior</code>的直接子view  -&gt;child的<code>Behavior.onNestedScrollAccepted</code>.这个方法里面可以做一些view配置的初始化。如果不需要当然可以不去重写。</li>
<li>在<code>RecycleView</code>上move -&gt; <code>dispatchNestedPreScroll</code>(也是child这个接口里面的)-&gt;<code>parent.onNestedPreScroll</code> -&gt; 遍历有<code>Behavior</code>的直接子view  -&gt;child的<code>Behavior.onNestedPreScroll</code>,同时之后还有一个流程也是在move的时候触发的 -&gt;<code>dispatchNestedScroll</code>(也是child这个接口里面的) -&gt;<code>parent.onNestedScroll</code> -&gt; 遍历有<code>Behavior</code>的直接子view  -&gt;child的<code>Behavior.onNestedScroll</code>.。这两个的主要区别的pre那个方法里面可以去处理消费了多少的滑动距离，比如手指滑动了12px,你可以选择把consumed[1]赋值为2，那么head就移动(消费)了2px，剩下的10px就给了下面的recycleview，而在<code>onNestedScroll</code>方法中还有机会去已经消费的和没有消费的距离再进行一次处理。</li>
<li>在<code>RecycleView</code>上面up -&gt; <code>stopNestedScroll</code>(也是child这个接口里面的) -&gt;<code>parent.onStopNestedScroll</code> -&gt; 遍历有<code>Behavior</code>的直接子view  -&gt;child的<code>Behavior.onStopNestedScroll</code>。</li>
<li>还有两个关于<code>Fling</code>的方法，就不说了，一个套路。</li>
</ul>
<p>还有就是再说一下<code>CoordinatorLayout</code>的<code>onInterceptTouchEvent</code>和<code>onTouchEvent</code>，这里贴一下代码吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">       <span class="keyword">final</span> View child = topmostChildList.get(i);</div><div class="line">       <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line">       <span class="keyword">final</span> Behavior b = lp.getBehavior();</div><div class="line"></div><div class="line">       <span class="keyword">if</span> ((intercepted || newBlock) &amp;&amp; action != MotionEvent.ACTION_DOWN) &#123;</div><div class="line">           <span class="comment">// Cancel all behaviors beneath the one that intercepted.</span></div><div class="line">           <span class="comment">// If the event is "down" then we don't have anything to cancel yet.</span></div><div class="line">           <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">if</span> (cancelEvent == <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">                   cancelEvent = MotionEvent.obtain(now, now,</div><div class="line">                           MotionEvent.ACTION_CANCEL, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0</span>);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">switch</span> (type) &#123;</div><div class="line">                   <span class="keyword">case</span> TYPE_ON_INTERCEPT:</div><div class="line">                       b.onInterceptTouchEvent(<span class="keyword">this</span>, child, cancelEvent);</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">                   <span class="keyword">case</span> TYPE_ON_TOUCH:</div><div class="line">                       b.onTouchEvent(<span class="keyword">this</span>, child, cancelEvent);</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!intercepted &amp;&amp; b != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">switch</span> (type) &#123;</div><div class="line">               <span class="keyword">case</span> TYPE_ON_INTERCEPT:</div><div class="line">                   intercepted = b.onInterceptTouchEvent(<span class="keyword">this</span>, child, ev);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               <span class="keyword">case</span> TYPE_ON_TOUCH:</div><div class="line">                   intercepted = b.onTouchEvent(<span class="keyword">this</span>, child, ev);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (intercepted) &#123;</div><div class="line">               mBehaviorTouchView = child;</div><div class="line">           &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>可以看出，每个直接的childview都会接受到拦截事件，即使你的手势不是在这个child上面触发的。</p>
<ul>
<li>还有个方法就是<code>layoutDependsOn</code>这个方法是在哪里调用的，这个是在onpredraw的时候就调用了，也就是没显示之前就已经开始准备各个view直接的依赖关系。当然内部实现也是在parent里面去便利child来实现的，也就只有parent可以获取到所有的child。</li>
</ul>
<h4 id="AppBarLayout的一些东西"><a href="#AppBarLayout的一些东西" class="headerlink" title="AppBarLayout的一些东西"></a><code>AppBarLayout</code>的一些东西</h4><p>我觉得<code>AppBarLayout</code>这个组件还是十分重要的，特别是里面的两个<code>Behavior</code>的实现，给了我们很好的参考的例子。具体的还是去看源码吧，太多了要说也是再开一篇。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;最近这一周空余的时间比较多，然后去重构了一个公司项目里的一个个人中心的页面，原来使用了&lt;code&gt;ListView&lt;/code&gt;再加上&lt;code&gt;addHead&lt;/code&gt;的方式，然后动态的去控制&lt;code&gt;Head&lt;/code&gt;的高度去实现嵌套滑动的效果，因为我的模拟器没有跑起来，所以也没有去录下个GIF来，因为这篇主要说一下&lt;code&gt;CoordinatorLayout&lt;/code&gt;的处理嵌套滑动的原理，没有效果图也影响不大。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>RxJava和Retrofit的那些事</title>
    <link href="http://yoursite.com/2016/08/01/RxJava%E5%92%8CRetrofit%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2016/08/01/RxJava和Retrofit的那些事/</id>
    <published>2016-08-01T14:24:32.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>##关于Retrofit<br>这是一个最近很火的网络请求库，官网在这<a href="http://square.github.io/retrofit/" target="_blank" rel="external">官网</a>,当然这也是一个开源的项目<a href="https://github.com/square/retrofit" target="_blank" rel="external">GitHub地址</a>。可能你对这个不是很熟悉，但是说起他的兄弟，okhttp估计就比较熟悉了，还有大名鼎鼎的依赖注入dagger和图片加载库picasso还有检查内存泄露的LeakCanary都是出自Square公司。当然这只是在JAVA和Android端，在js和Python上也有很棒的项目，有兴趣就自己看了，扯远了。。<a id="more"></a></p>
<p>为什么要用Retrofit呢，因为他除了提供给我们常见的请求Callback形式，还封装了Observable的请求形式，这就很方便的支持了Rxjava,而Rxjava的强大就是体现在异步任务上。下面来简单的介绍一下使用。</p>
<p>对于RxJava的语法就不说了，有一篇写了关于这方面的，下面就直接开始了。</p>
<p>以github的开放API作为数据来源，我们要去获取某个项目的contributors，以square的retrofit为例，可以调用这个<code>https://api.github.com/repos/square/retrofit/contributors</code>返回的json是这样的array</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">login: &quot;JakeWharton&quot;,</div><div class="line">id: 66577,</div><div class="line">avatar_url: &quot;https://avatars.githubusercontent.com/u/66577?v=3&quot;,</div><div class="line">gravatar_id: &quot;&quot;,</div><div class="line">url: &quot;https://api.github.com/users/JakeWharton&quot;,</div><div class="line">html_url: &quot;https://github.com/JakeWharton&quot;,</div><div class="line">followers_url: &quot;https://api.github.com/users/JakeWharton/followers&quot;,</div><div class="line">following_url: &quot;https://api.github.com/users/JakeWharton/following&#123;/other_user&#125;&quot;,</div><div class="line">gists_url: &quot;https://api.github.com/users/JakeWharton/gists&#123;/gist_id&#125;&quot;,</div><div class="line">starred_url: &quot;https://api.github.com/users/JakeWharton/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,</div><div class="line">subscriptions_url: &quot;https://api.github.com/users/JakeWharton/subscriptions&quot;,</div><div class="line">organizations_url: &quot;https://api.github.com/users/JakeWharton/orgs&quot;,</div><div class="line">repos_url: &quot;https://api.github.com/users/JakeWharton/repos&quot;,</div><div class="line">events_url: &quot;https://api.github.com/users/JakeWharton/events&#123;/privacy&#125;&quot;,</div><div class="line">received_events_url: &quot;https://api.github.com/users/JakeWharton/received_events&quot;,</div><div class="line">type: &quot;User&quot;,</div><div class="line">site_admin: false,</div><div class="line">contributions: 619</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>这里我们只使用到<code>login</code>和<code>contributions</code></p>
<p> 1.定义一个接口，这个看代码就明白了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface GithubApi &#123;</div><div class="line"> @GET(&quot;/repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</div><div class="line">    Observable&lt;List&lt;Contributor&gt;&gt; contributors(@Path(&quot;owner&quot;) String owner,</div><div class="line">                                               @Path(&quot;repo&quot;) String repo);</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>通过注解来提供参数，这里注解有很多，还有<code>@Query</code>，<code>@QueryMap</code>，<code>@Body</code>等等，也可以通过<code>@Headers</code>设置请求头。参数基于base url,其实就是拼接成的。这个返回的是一个<code>Observable</code>，这样就很方便的去发布一个事件了。</p>
<p> 2.设置<code>RestAdapter</code>和<code>service</code>,先用<code>Endpoint(API)</code>并调用buid()方法来创建一个RestAdapter对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RestAdapter adapter = new RestAdapter.Builder().setEndpoint(</div><div class="line">              &quot;https://api.github.com/&quot;).setLogLevel(RestAdapter.LogLevel.FULL).build();</div></pre></td></tr></table></figure>
<p>然后使用我们的adapter来创建一个服务适配器(service for adapter)。<code>adapter.create(GithubApi.class);</code><br>完整的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private GithubApi _createGithubApi() &#123;</div><div class="line">      RestAdapter adapter = new RestAdapter.Builder().setEndpoint(</div><div class="line">            &quot;https://api.github.com/&quot;).setLogLevel(RestAdapter.LogLevel.FULL).build();</div><div class="line"></div><div class="line">      return adapter.create(GithubApi.class);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p> 3.这就到了Rxjava的地方了，上一步获取到了GithubApi对象，就可以去调用函数了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">_subscriptions.add(</div><div class="line">                _api.contributors(_username.getText().toString(), _repo.getText().toString())//事件源</div><div class="line">                        .subscribeOn(Schedulers.io())</div><div class="line">                        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">                        .subscribe(new Observer&lt;List&lt;Contributor&gt;&gt;() &#123;//订阅者</div><div class="line">                            @Override</div><div class="line">                            public void onCompleted() &#123;</div><div class="line">                                </div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            @Override</div><div class="line">                            public void onError(Throwable e) &#123;</div><div class="line">                               </div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            @Override</div><div class="line">                            public void onNext(List&lt;Contributor&gt; contributors) &#123;</div><div class="line">                                for (Contributor c : contributors) &#123;</div><div class="line">                                    _adapter.add(format(&quot;%s has made %d contributions to %s&quot;,</div><div class="line">                                            c.login,</div><div class="line">                                            c.contributions,</div><div class="line">                                            _repo.getText().toString()));</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;));</div></pre></td></tr></table></figure>
<p>当然这是一个比较简单的处理过程，并没有用到一下通配符，但是基本的流程就是这样的。</p>
<p>到现在发现我们并没有去解析json数据就自动生成了bean类，这是因为Retrofit已经集成了Gson，并且默认使用Gson来进行解析，当然你也可以自己去定义。在创建<code>RestAdapter</code>的时候使用<code>setConverter(new GsonConverter(gson))</code>。默认是使用okhttp进行加载的，当然你也可以去配置一些关于<code>OkHttpClient</code>的数据，然后通过<code>setClient(new OkClient(client))</code>进行设置进去。</p>
<p>现在<code>Retrofit</code>的2.0版本已经出了，主要就是 取消了同步和异步，可以取消正在进行中的业务，取消了Gson的依赖等等，具体可以看这里<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0915/3460.html" target="_blank" rel="external">Retrofit 2.0：有史以来最大的改进</a><br>这篇参考了GitHub上的项目<a href="https://github.com/70kg/RxJava-Android-Samples" target="_blank" rel="external">RxJava-Android-Samples</a>，这里只是拣取了关于Retrofit的部分，有兴趣可以看看其他的。</p>
<p>参考：<br><a href="http://www.tuicool.com/articles/26jUZjv" target="_blank" rel="external">http://www.tuicool.com/articles/26jUZjv</a><br><a href="http://www.cnblogs.com/angeldevil/p/3757335.html" target="_blank" rel="external">http://www.cnblogs.com/angeldevil/p/3757335.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##关于Retrofit&lt;br&gt;这是一个最近很火的网络请求库，官网在这&lt;a href=&quot;http://square.github.io/retrofit/&quot;&gt;官网&lt;/a&gt;,当然这也是一个开源的项目&lt;a href=&quot;https://github.com/square/retrofit&quot;&gt;GitHub地址&lt;/a&gt;。可能你对这个不是很熟悉，但是说起他的兄弟，okhttp估计就比较熟悉了，还有大名鼎鼎的依赖注入dagger和图片加载库picasso还有检查内存泄露的LeakCanary都是出自Square公司。当然这只是在JAVA和Android端，在js和Python上也有很棒的项目，有兴趣就自己看了，扯远了。。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>自定义控件学习笔记</title>
    <link href="http://yoursite.com/2016/08/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/08/01/自定义控件学习笔记/</id>
    <published>2016-08-01T14:24:32.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>#Canvas</p>
<p>##canvas简介<br>&emsp;&emsp;每个canvas都有bitmap为其保存像素，canvas有两个构造函数，无参函数和一个bitmap参数的函数，<code>Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);  
        Canvas canvas = new Canvas(bitmap);</code>这样就创建了一个canvas对象，Android推荐使用有参函数。其实无参和有参数的构造函数都是需要创建一个bitmap，无参会默认创建一个。一个canvas需要一个bitmap来保存像素信息，当然也是可以没有bitmap，但是画的东西没有地方保存，也就没有意义。<a id="more"></a></p>
<p>##canvas的主要方法<br>&emsp;&emsp;canvas主要有几种方法，draw…这类方法是用来画一下东西的，clip…就是用来裁剪的，还有scale,translate，skew，rotate是用来进行画布的变换，还有saveXXX和restoreXXX构成的画布锁定和还原。</p>
<p>##裁剪画布<br>&emsp;&emsp;裁剪画布可以裁剪规则区域<code>canvas.clipRect</code>和裁剪不规则的区域<code>canvas.clippath</code>，第一个就是传进去一个矩形，然后裁剪剩下矩形区域的画布，第二个就是按路径裁剪。还有就是Region.Op，中文就是区域，这个在API21弃用了，但是还是写一下吧，这个就跟图形的组合模式差不多，Region.Op是个枚举类，<br><img src="http://img.blog.csdn.net/20141216162324031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWlnZXN0dWRpbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>使用举例：</p>
<pre><code>// 填充颜色  
canvas.drawColor(Color.BLUE);  

canvas.save();  

// 裁剪区域A  
canvas.clipRegion(mRegionA);  

// 再通过组合方式裁剪区域B  
canvas.clipRegion(mRegionB, Region.Op.DIFFERENCE);  

// 填充颜色  
canvas.drawColor(Color.RED);  

canvas.restore(); 
</code></pre><p>Rect、Cricle、Ovel等封闭的曲线都可以使用Region.Op。Region和Rect有什么区别呢？首先最重要的一点，Region表示的是一个区域，而Rect表示的是一个矩形，这是最根本的区别之一，其次，Region有个很特别的地方是它不受Canvas的变换影响，Canvas的local不会直接影响到Region自身。</p>
<p>##Path<br>&emsp;&emsp;使用路径可以做出很多很有意思的图形或者动画，<br>先从简单的开始，<code>path.lineto()</code>这个是用来画直线，如果不设置起点，则是默认从（0.0）为起点，可以使用<code>path。moveto(x,y)</code>来将起点移动到合适的位置。要绘制一个闭合的图形，可以使用<code>paht.close()</code>可以自动将最后一个点和最初的一个点进行连接构成封闭的图形。</p>
<p>###贝塞尔曲线<br>&emsp;&emsp;要绘制贝塞尔曲线可以使用<code>quadTo(float x1, float y1, float x2, float y2)</code>前两个是控制点，后两个是终点。控制点就像一个磁铁，去吸引橡皮条上的另一个磁铁，橡皮条弯曲成一个曲线就类似控制点控制的贝塞尔曲线。<img src="http://img.blog.csdn.net/20141216160213685" alt=""><br>再来两张动图吧，这个的从<a href="http://blog.csdn.net/aigestudio/article/details/41960507" target="_blank" rel="external">爱歌</a>的<a href="http://blog.csdn.net/column/details/androidcustomview.html" target="_blank" rel="external">Android自定义控件其实很简单</a>专栏里面偷得，这篇博客也是看着他的博客总结的。</p>
<ul>
<li>一阶贝塞尔曲线<br><img src="http://img.blog.csdn.net/20141216154914760" alt=""></li>
<li>二阶贝塞尔曲线<br><img src="http://img.blog.csdn.net/20141216155508803" alt=""></li>
<li>三阶贝塞尔曲线<br><img src="http://img.blog.csdn.net/20141216155707332" alt=""></li>
<li>四阶贝塞尔曲线<br><img src="http://img.blog.csdn.net/20141216155817984" alt=""></li>
<li>五阶贝塞尔曲线<br><img src="http://img.blog.csdn.net/20141216155848359" alt=""><br>看着就挺爽的。在Android中除了上面提到的<code>quadTo(float x1, float y1, float x2, float y2)</code>来绘制二阶贝塞尔曲线，还有<code>cubicTo(float x1, float y1, float x2, float y2, float x3, float y3)</code>来实现三阶贝塞尔曲线。类似下面的<img src="http://img.blog.csdn.net/20141216160322419" alt=""><br>我们使用贝塞尔曲线主要就是要去控制它的起点终点和控制点。之前看网上写过一个类似QQ气泡拖拽消失的例子，地址：<a href="https://github.com/70kg/Android-Studio-Project/blob/master/app/src/main/java/com/com/mr_wrong/Bezier/BezierView.java" target="_blank" rel="external">我的GitHub</a>原理比较简单，就是计算各个点的坐标比较复杂一些。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Canvas&lt;/p&gt;
&lt;p&gt;##canvas简介&lt;br&gt;&amp;emsp;&amp;emsp;每个canvas都有bitmap为其保存像素，canvas有两个构造函数，无参函数和一个bitmap参数的函数，&lt;code&gt;Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);  
        Canvas canvas = new Canvas(bitmap);&lt;/code&gt;这样就创建了一个canvas对象，Android推荐使用有参函数。其实无参和有参数的构造函数都是需要创建一个bitmap，无参会默认创建一个。一个canvas需要一个bitmap来保存像素信息，当然也是可以没有bitmap，但是画的东西没有地方保存，也就没有意义。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 5.0 Transition介绍</title>
    <link href="http://yoursite.com/2016/07/09/transition%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2016/07/09/transition介绍/</id>
    <published>2016-07-09T15:38:49.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>###扯淡<br>之所以写这篇是因为看到别人写的APP都很酷炫，了解到之后发现5.0之后的动画丰富了那么多，特别是共享元素和圆形展开那个(不知道是不是这么叫的)特别酷，就去了解了一下。再加上我最近才上的5.0，终于有真机可以进行调试了，看到动画在自己手机上运行，还是挺有成就感的😂。<a id="more"></a><br>下面的文章来自国外的一篇译文，摘抄自泡网，我在这个dome上也注释了一些，<a href="">地址</a>.</p>
<p>##Activity和Fragment Transition介绍</p>
<p>###什么是Transition?<br>安卓5.0中Activity和Fragment 变换是建立在名叫Transitions的安卓新特性之上的。这个诞生于4.4的transition框架为在不同的UI状态之间产生动画效果提供了非常方便的API。该框架主要基于两个概念：场景（scenes）和变换（transitions）。场景（scenes）定义了当前的UI状态，变换（transitions）则定义了在不同场景之间动画变化的过程。虽然transition翻译为变换似乎很确切，但是总觉得还是没有直接使用transition直观，为了更好的理解下面个别地方直接用transition代表变换。</p>
<p>当一个场景改变的时候，transition主要负责：</p>
<p>（1）捕捉每个View在开始场景和结束场景时的状态。</p>
<p>（2）根据两个场景（开始和结束）之间的区别创建一个Animator。</p>
<p>考虑这样一个例子，当用户点击屏幕，让activity中的view逐渐消失。使用安卓的transition框架，我们只需几行代码就可完成，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class ExampleActivity extends Activity implements View.OnClickListener &#123;</div><div class="line">    private ViewGroup mRootView;</div><div class="line">    private View mRedBox, mGreenBox, mBlueBox, mBlackBox;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        mRootView = (ViewGroup) findViewById(R.id.layout_root_view);</div><div class="line">        mRootView.setOnClickListener(this);</div><div class="line">        mRedBox = findViewById(R.id.red_box);</div><div class="line">        mGreenBox = findViewById(R.id.green_box);</div><div class="line">        mBlueBox = findViewById(R.id.blue_box);</div><div class="line">        mBlackBox = findViewById(R.id.black_box);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        TransitionManager.beginDelayedTransition(mRootView, new Fade());</div><div class="line">        toggleVisibility(mRedBox, mGreenBox, mBlueBox, mBlackBox);</div><div class="line">    &#125;</div><div class="line">    private static void toggleVisibility(View... views) &#123;</div><div class="line">        for (View view : views) &#123;</div><div class="line">            boolean isVisible = view.getVisibility() == View.VISIBLE;</div><div class="line">            view.setVisibility(isVisible ? View.INVISIBLE : View.VISIBLE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了更好的理解幕后发生的事情，让我们来一步一步的分析，假设最开始每个view都是可见的：</p>
<p>（1）当点击事件发生之后调用TransitionManager的beginDelayedTransition()方法，并且传递了mRootView和一个Fade对象最为参数。之后，framework会立即调用transition类的captureStartValues()方法为每个view保存其当前的可见状态(visibility)。</p>
<p>（2）当beginDelayedTransition返回之后，在上面的代码中将每个view设置为不可见。</p>
<p>（3）在接下来的显示中framework会调用transition类的captureEndValues()方法，记录每个view最新的可见状态。</p>
<p>（4）接着，framework调用transition的createAnimator()方法。transition会分析每个view的开始和结束时的数据发现view在开始时是可见的，结束时是不可见的。Fade（transition的子类）会利用这些信息创建一个用于把view的alpha属性变为0的AnimatorSet，并且将此AnimatorSet对象返回。</p>
<p>（5）framework会运行返回的Animator，导致所有的View都渐渐消失。</p>
<blockquote>
<p>编者注：读者可以在这里回想假如不使用transition框架，我们自己使用属性动画（Animator）来实现是不是复杂很多，其实transition框架的作用就是封装了属性动画的操作。</p>
</blockquote>
<p>这个简单的例子强调了transition框架的两个主要优点。第一、Transitions抽象和封装了属性动画，Animator的概念对开发者来说是透明的，因此它极大的精简了代码量。开发者所做的所有事情只是改变一下view前后的状态数据，Transition就会自动的根据状态的区别去生成动画效果。第二、不同场景之间变换的动画效果可以简单的通过使用不同的Transition类来改变，本例中用的是Fade。<br><img src="http://jcodecraeer.com/uploads/20150113/1421146073174536.gif" alt=""><br>实现上图中的那两个不同的动画效果可以将Fade替换成Slide或者Explode即可。在接下来的文章中你将会发现，这些优点将使得我们只用少量代码就可以创建复杂的Activity 和Fragment切换动画。在接下来的小节中，将看到是如何使用Lollipop的Activity 和Fragment transition API来实现这种变换的。</p>
<p>###5.0中的Activity和Fragment Transition<br>Android 5.0中Transition可以被用来实现Activity或者Fragment切换时的异常复杂的动画效果。虽然在以前的版本中，已经可以使用Activity的overridePendingTransition() 和 FragmentTransaction的setCustomAnimation()来实现Activity或者Fragment的动画切换，但是他们仅仅局限与将整个视图一起动画变换。新的Lollipop api更进了一步，让单独的view也可以在进入或者退出其布局容器中时发生动画效果，甚至还可以在不同的activity/Fragment中共享一个view。</p>
<p>在开始讲解之前我们先做一些约定，虽然下面的约定是针对activity的，但是在Fragment中也是一样的约定。</p>
<blockquote>
<p>A和B分别是两个Activity，假设activity A 调用activity B。将A代表调用Activity ，B代表被调用Activity。</p>
</blockquote>
<p>Activity transition API围绕退出（exit），进入（enter），返回（return）和再次进入（reenter）四种transition。按照上面对A和B的约定，我这样描述这一过程。</p>
<blockquote>
<p>Activity A的退出变换（exit transition）决定了在A调用B的时候，A中的View是如何播放动画的。</p>
<p>Activity B的进入变换（enter transition）决定了在A调用B的时候，B中的View是如何播放动画的。</p>
<p>Activity B的返回变换（return transition）决定了在B返回A的时候，B中的View是如何播放动画的。</p>
<p>Activity A的再次进入变换（reenter transition）决定了在B返回A的时候，A中的View是如何播放动画的。</p>
</blockquote>
<p>最后framework提供了两种Activity transition- 内容transition和共享元素的transition：<br><img src="http://jcodecraeer.com/uploads/150113/1-150113195F54J.gif" alt=""><br>上图中演示了Google Play Newsstand 应用的效果，虽然我们无法查看它的源码，但是我敢打赌它用了以下的transition：</p>
<blockquote>
<p>activity A 中exit和reenter transition是为null的，因为A中的非共享view在退出和再次进入的时候没有动画效果。</p>
<p>activity B中的enter content transition使用了自定义的slide-in变换。该变换使B中list的元素从下到上过度。</p>
<p>activity B中return content transition是一组TransitionSet，同时播放了两个子元素的变换：上半部分和下半部分的slide变换。看起来就像整个界面被从从中间分割成了两半。</p>
<p>enter and return 共享元素变换是用了ChangeImageTransform。让两个activity中的ImageView无缝切换。</p>
</blockquote>
<p>你可能还注意到了在共享元素变换播放的同时还有个圆形水波效果的动画。我们将在以后的博客中讨论如何实现。目前为了是问题更简单，我们主要讨论熟悉的activity变换。</p>
<p>###Activity Transition API介绍<br>用5.0的API创建一个基本的Activity transition是较为简单的。下面的总结是实现Activity transition的步骤。这篇文章主要是对Activity transition做简单的介绍，作为引入的篇章。在后续的文章中我们再介绍一些高级的用法。</p>
<p>1.在调用与被调用的activity中，通过设定Window.FEATURE_ACTIVITY_TRANSITIONS  和 Window.FEATURE_CONTENT_TRANSITIONS 来启用transition api ，可以通过代码也可以通过设置主题来启用：</p>
<p>代码方式，在setContentView之前调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);</div></pre></td></tr></table></figure>
<p>主题xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;item name=&quot;android:windowContentTransitions&quot;&gt;true&lt;/item&gt;</div></pre></td></tr></table></figure>
<p>2.分别在调用与被调用的activity中设置exit 和enter transition。Material主题默认会将exit的transition设置成null而enter的transition设置成Fade .如果reenter 或者 return transition没有明确设置，则将用exit 和enter的transition替代。</p>
<p>3.分别在调用与被调用的activity中设置exit 和enter 共享元素的transition。Material主题默认会将exit的共享元素transition设置成null而enter的共享元素transition设置成@android:transition/move.如果reenter 或者 return transition没有明确设置，则将用exit 和enter的共享元素transition替代。开始一个activity的content transaction需要调用startActivity(Context, Bundle)方法，将下面的bundle作为第二个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ActivityOptions.makeSceneTransitionAnimation(activity, pairs).toBundle();</div></pre></td></tr></table></figure>
<p>其中pairs参数是一个数组：Pair<view, string=""> ，该数组列出了你想在activity之间共享的view和view的名称。别忘了给你的共享元素加上一个唯一的名称，否则transition可能不会有正确的结果。</view,></p>
<p>4.在代码中触发通过finishAfterTransition()方法触发返回动画，而不是调用finish()方法。</p>
<p>5.默认情况下，material主题的应用中enter/return的content transition会在exit/reenter的content transitions结束之前开始播放（只是稍微早于），这样会看起来更加连贯。如果你想明确屏蔽这种行为，可以调用setWindowAllowEnterTransitionOverlap() 和 setWindowAllowReturnTransitionOverlap()方法。</p>
<p>###Fragment Transition API介绍</p>
<p>如果你想在Fragment中使用transition，除了一小部分区别之外和activity大体一致：</p>
<p>1.Content的exit, enter, reenter, 和return transition需要调用fragment的相应方法来设置，或者通过fragment的xml属性来设置。</p>
<p>2.共享元素的enter和return transition也n需要调用fragment的相应方法来设置，或者通过fragment的xml属性来设置。</p>
<p>3.虽然在activity中transition是被startActivity()和finishAfterTransition()触发的，但是Fragment的transition却是在其被FragmentTransaction执行下列动作的时候自动发生的。added, removed, attached, detached, shown, ，hidden。</p>
<p>4.在Fragment commit之前，共享元素需要通过调用addSharedElement(View, String) 方法来成为FragmentTransaction的一部分。</p>
<p>总结<br>在本文中，我们仅仅是对新的Activitiy 和Fragment transition API做了一个简单的介绍。但是在接下来的文章中你会看到对基础概念的掌握会让你以后学习的更快，尤其是当你要做一些自定义Transition的时候。后面的文章中我们将更深入的去理解content transition和hared element transition，同时对Activity 和Fragment transition的工作原理有更深的理解。</p>
<p>##深入理解Content Transition</p>
<p>###什么是Content Transition<br>content transition决定了非共享view元素在activity和fragment切换期间是如何进入或者退出场景的。根据google最新的Material Design设计语言，content transition让我们毫不费力的去协调Activity/Fragment切换过程中view的进入和退出，让这个过程更流畅。在5.0之后content transition可以通过调用Window和Fragment的如下代码来设置：</p>
<p>ps:还记得上篇文章中对A和B的约定吗</p>
<p>(1)setExitTransition() - 当A start B时，使A中的View退出场景的transition</p>
<p>(2)setEnterTransition() - 当A start B时，使B中的View进入场景的transition</p>
<p>(3)setReturnTransition() - 当B 返回 A时，使B中的View退出场景的transition</p>
<p>(4)setReenterTransition() - 当B 返回 A时，使A中的View进入场景的transition</p>
<p>以下图为例，演示了google play Games app如何通过content transition实现activity之间的平滑切换。当第二个activity开始的时候，enter  transition让用户的头像从底部边缘慢慢滑入。而在activity退出的时候，屏幕被分成两半，各自消失在上下边缘。<br><img src="http://www.jcodecraeer.com/uploads/20150116/1421395105402519.gif" alt=""><br>到目前位置我们只是肤浅的勾勒出了content transition轮廓，有几个非常重要的问题仍然存在。content transition触发的内部机制，有哪些Transition类可用？framework如何确定哪些view是transitioning view？ViewGroup和它的孩子可以被作为一个整体播放动画吗？，我们将逐个解答。</p>
<p>###Content Transition内部揭秘<br>回忆上篇文章的内容，一个Transition主要有两个职责：捕获目标view的开始和结束时的状态、创建一个用于在两个状态之间播放动画的Animator。Content transition同样如此：在Content transition动画（animation）创建之前，framework必须通过设置transitioning view的visibility将动画需要的状态信息告诉animation。具体来说，当Activity A startsActivity B之时，发生了如下的事件：</p>
<p>一、Activity A 调用startActivity().<br>    1.framework遍历A的View树，确定当A的exit transition运行时哪些view会退出场景（即哪些view是transitioning view）。<br>    2.A的exit transition捕获A中transitioning view的开始状态。<br>    3.framework将A中所有的transitioning view设置为INVISIBLE。<br>    4.A的exit transition捕获到A中transitioning view的结束状态。<br>    5.A的exit transition比较每个transitioning view的开始和结束状态，然后根据前后状态的区别创建一个Animator。Animator开始运行，同时transitioning view退出场景。</p>
<p>二、Activity B启动.<br>    1.framework遍历B的View树，确定当B的enter transition运行时哪些view会进入场景，transitioning view会被初始化为INVISIBLE。<br>    2.B的enter transition捕获B中transitioning view的开始状态。<br>    3.framework将B中所有的transitioning view设置为VISIBLE。<br>    4.B的enter transition捕获到B中transitioning view的结束状态。<br>    5.B的enter transition比较每个transitioning view的开始和结束状态，然后根据前后状态的区别创建一个Animator。Animator开始运行，同时transitioning view进入场景。</p>
<p>通过在每个transitioning view中来回切换INVISIBLE 和VISIBLE，framework确保content transition得到创建animation（期望的animation）所需的状态信息。显然content Transition对象需要在开始和结束场景中都能记录到transitioning view的visibility。 非常幸运的是抽象类Visibility已经为你做了这些工作：Visibility的子类只需要实现onAppear() 和 onDisappear() 两个工厂方法，在这两个工厂方法中创建并返回一个进入或者退出场景的Animator对象。在api 21中，有三个现成的Visibility的实现：Fade, Slide, 和 Explode</p>
<p>他们都可以用在Activity 和 Fragment中创建content transition。如果必要，还可以自定义Visibility，这将在今后的文章中讲解。</p>
<p>###Transitioning Views以及Transition Groups<br>到目前为止，我们假设了content transition是操作非共享元素的（即提到了很多次的transitioning view）。在本节，我们将讨论framework是如何决定transitioning view的集合以及如何使用transition groups自定义它。</p>
<p>在transition开始之前，framework通过递归遍历Activity（或者Fragment）的Window中的View树来决定transitioning view的集合。整个搜索过程开始在根view中调用ViewGroup的captureTransitioningView方法，captureTransitioningView的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void captureTransitioningViews(List&lt;View&gt; transitioningViews) &#123;</div><div class="line">    if (getVisibility() != View.VISIBLE) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (isTransitionGroup()) &#123;</div><div class="line">        transitioningViews.add(this);</div><div class="line">    &#125; else &#123;</div><div class="line">        int count = getChildCount();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            child.captureTransitioningViews(transitioningViews);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个递归的过程比较简单粗暴：framework跟踪不同级别的view树直到它找到一个VISIBLE的叶子view或者是一个transition group。transition group允许我们将整个ViewGroup作为一个整体来变换。如果一个ViewGroup的isTransitionGroup()方法返回true，则它的所有孩子都将被视为一个整体一起播放动画。否则将会继续递归该ViewGroup，其子view也会在动画的时候被单独对待。遍历的最后结果是一个完整的transitioning view的集合将在content transition的时候播放动画。</p>
<blockquote>
<p>注：默认情况下，isTransitionGroup()将在ViewGroup有背景或者有transition name的时候返回true（参见documentation 中对该方法的声明）。</p>
</blockquote>
<p>以下图为例，在整个过程中，用户的头像先是作为一个单独的元素渐渐的进入到下一个界面，而在返回的时候他又是和其他元素一起作为一个整体被动画。google play Games 中貌似用的是transition group来实现将屏幕分成两半的效果。</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150116/1421395183295370.gif" alt=""><br>有时候transition groups被用来修改一些Activity切换是出现的莫名其妙的bug。还是以上图为例，calling Activity 显示了封面图片的相册界面，而被调用activity则显示了一个header的背景图片，共享的封面图片，一个webview。这个app使用了类似与Google Play Games的transition：从中间成两半，各自滑倒上下边缘。但是，仔细观察你会发现只有上部分有滑动的动画效果，Webview没有。</p>
<p>那么问题来了，到底是哪里没对？上面的结果证明WebView虽然是一个ViewGroup但是没有被系统认为是transition view。因此content transition没有在它上面运行。幸运的是我们可以在return transition之前的某个地方调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webView.setTransitionGroup(true)</div></pre></td></tr></table></figure>
<p>来解决这个问题。</p>
<p>###总结<br>总的来说，本文涉及到了三个重要的方面：</p>
<p>1.content transition决定非共享元素（即transitioning view）在Activity切换的时候是如何变换的。</p>
<p>2.Content transition的触发是通过改变transitioning view的visibility来实现的。</p>
<p>3.Transition group让我们可以将ViewGroup作为一个整体来变换。</p>
<p>##深入理解共享元素变换（Shared Element Transition）-上</p>
<p>###什么是共享元素变换？<br>元素共享式变换（shared element transition）决定了共享的view元素从一个Activity/Fragment 到另一个Activity/Fragment t的切换中是如何动画变化的。共享元素在被调用Activity进入和返回时播放动画，共享元素在进入和返回时的变换效果通过window和Fragment的如下方法来设置：</p>
<p>进入：</p>
<p>setSharedElementEnterTransition()</p>
<p>设置在B进入时播放的动画，共享元素以A中的位置作为起始，B中的位置为结束来播放动画。</p>
<p>返回：</p>
<p>setSharedElementReturnTransition()</p>
<p>设置在B返回A时的动画，共享元素以B中的位置作为起始，A中的位置为结束来播放动画。</p>
<blockquote>
<p>注意，Activity Transition API 也可以使用 setSharedElementExitTransition() 和setSharedElementReenterTransition()方法分别设置共享元素的exit 和reenter 变换。但是一般来讲这是不必要的。如果你想看先关的例子，可以查看这篇博客<a href="https://halfthought.wordpress.com/2014/12/08/what-are-all-these-dang-transitions/" target="_blank" rel="external">this blog post</a>.至于为什么Fragment中没有共享元素的exit 和reenter 变换，请查看George Mount在stackoverflow上的回答:<a href="http://stackoverflow.com/q/27346020/844882" target="_blank" rel="external">this StackOverflow post</a>。</p>
</blockquote>
<p><img src="http://www.jcodecraeer.com/uploads/20150201/1422779465610233.gif" alt=""><br>上图演示了google play music应用中的共享元素变换效果。变换包含了两个共享的view元素：一个ImageView以及他的父亲CardView。ImageView在两个activity之间无缝的动画切换，而CardView则是渐渐的扩展到界面上。</p>
<p>在第一章中我们简单的介绍了这个话题，这篇文章则是更深入的去分析共享元素变换（shared element transition）。共享元素变换的原理是什么？有哪些共享元素变换效果可用？共享元素变换动画是如何绘制的，又是在哪里绘制的？接下来的小节中我们将一一回答。</p>
<p>###共享元素变换揭秘<br>从前两篇文章中我们知道，一个变换（Transition ）主要有两方面的职责：</p>
<p>捕获view开始和结束状态以及创建一能在两个状态间渐变的动画。共享元素变换没有什么不同。在共享元素变换开始之前，必须首先捕获每个共享元素的开始和结束状态（调用activity以及被调用activity中的位置、大小、外观），有了这些信息才能决定每个共享元素的入场动画。</p>
<p>和深入理解Content Transition 中类似，framework的共享元素变换是通过运行时改变其属性实现的，当Activity A 调用 Activity B ，发生的事件流如下：</p>
<p>1.Activity A调用startActivity()， Activity B被创建，测量，同时初始化为半透明的窗口和透明的背景颜色。</p>
<p>2.framework重新分配每个共享元素在B中的位置与大小，使其跟A中一模一样。之后，B的进入变换（enter transition）捕获到共享元素在B中的初始状态。</p>
<p>3.framework重新分配每个共享元素在B中的位置与大小，使其跟B中的最终状态一致。之后，B的进入变换（enter transition）捕获到共享元素在B中的结束状态。</p>
<p>4.B的进入变换（enter transition）比较共享元素的初始和结束状态，同时基于前后状态的区别创建一个Animator(属性动画对象)。</p>
<p>5.framework 命令A隐藏其共享元素，动画开始运行。随着动画的进行，framework 逐渐将B的activity窗口显示出来，当动画完成，B的窗口才完全可见。</p>
<p>与内容变换（content transition）取决于view的可见性不同（visibility），共享元素变换取决于每个共享元素的位置、大小以及外观。在api 21中，框架层提供了几个Transition 的实现，可以用于定义共享元素在场景中的切换效果。</p>
<p>ChangeBounds -捕获共享元素的layout bound，然后播放layout bound变化动画。ChangeBounds 是共享元素变换中用的最多的，因为前后两个activity中共享元素的大小和位置一般都是不同的。</p>
<p>ChangeTransform -  捕获共享元素的缩放（scale）与旋转（rotation）属性 ，然后播放缩放（scale）与旋转（rotation）属性变化动画。</p>
<p>ChangeClipBounds -  捕获共享元素clip bounds，然后播放clip bounds变化动画。</p>
<p>ChangeImageTransform -  捕获共享元素（ImageView）的transform matrices 属性，然后播放ImageViewtransform matrices 属性变化动画。与ChangeBounds相结合，这个变换可以让ImageView在动画中高效实现大小，形状或者ImageView.ScaleType 属性平滑过度。</p>
<p>@android:transition/move -  将上述所有变换同时进行的一个TransitionSet 。就如在第一章中所讲的一样，如果共享元素的进入和返回变换没有特别声明，框架将使用它作为默认的变换。</p>
<p>我们可以看到，共享元素变换并不是真正实现了两个activity或者Fragment之间元素的共享，实际上我们看到的几乎所有变换效果中（不管是B进入还是B返回A）,共享元素都是在B中绘制出来的。Framework没有真正试图将A中的某个元素传递给B，而是采用了不同的方法来达到相同的视觉效果。A传递给B的是共享元素的状态信息。B利用这些信息来初始化共享View元素，让它们的位置、大小、外观与在A中的时候完全一致。当变换开始的时候，B中除了共享元素之外，所有的其他元素都是不可见的。随着动画的进行，framework 逐渐将B的activity窗口显示出来，当动画完成，B的窗口才完全可见。</p>
<p>###使用共享元素的 Overlay<br>最后，我们需要讨论一下shared element overlay这个概念才算是对共享元素变换的绘制过程有了一个完整的了解。</p>
<p>虽然不是非常明显的可以看到，共享元素默认其实是绘制在整个view树结构的最上层，在一个叫ViewOverlay的东西上面。你可能没听说过ViewOverlay，他是4.3之后才有的一个新类，它是view的最上面的一个透明的层，添加到ViewOverlay上面的Drawable和view可以被绘制到任何东西的上面，甚至是ViewGroup的子元素。这似乎可以解释为什么framework 会选择ViewOverlay来作为共享元素变换的绘制空间了。<br>-关于ViewOverlay，除了官方解释还可以看看这篇文章：<a href="http://jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0130/2384.html" target="_blank" rel="external">ViewOverlay与animation介绍 </a><br>虽然共享元素默认是绘制在ViewOverlay上面，但是framework 还是提供了关闭这个选项的功能，调用Window的setSharedElementsUseOverlay(false) 方法。这样主要是为了防止万一有这样的开发需要。如果你选择了关闭overlay，那么请注意这是有一定副作用的。<br><img src="http://www.jcodecraeer.com/uploads/20150201/1422779979139164.gif" alt=""></p>
<p>在上图的效果中，我们运行了两次不同方式的动画，第二次便是关闭overlay之后的效果，我们可以明显的看到这导致了一个问题。</p>
<p>总之除非有一万个理由，否则不要关闭shared element overlay。</p>
<p>###总结<br>这篇文章涵盖了如下几个要点：</p>
<p>1.元素共享式变换（shared element transition）决定了共享的view元素从一个Activity/Fragment 到另一个Activity/Fragment t的切换中是如何动画变化的。</p>
<p>2.共享元素变换取决于每个共享元素的位置、大小以及外观。</p>
<p>3.共享元素默认其实是绘制在整个view树结构的最上层，在一个叫ViewOverlay的东西上面。</p>
<p>4.共享元素变换并不是真正实现了两个activity或者Fragment之间元素的共享，Framework采用了不同的方法来达到相同的视觉效果。</p>
<p>##Postponed Shared Element Transitions (part 3b)<br>这里还有一篇，并没有翻译，看了一遍，写贴上，有时间我去翻译一下 <a href="http://www.androiddesignpatterns.com/2015/03/activity-postponed-shared-element-transitions-part3b.html" target="_blank" rel="external">地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###扯淡&lt;br&gt;之所以写这篇是因为看到别人写的APP都很酷炫，了解到之后发现5.0之后的动画丰富了那么多，特别是共享元素和圆形展开那个(不知道是不是这么叫的)特别酷，就去了解了一下。再加上我最近才上的5.0，终于有真机可以进行调试了，看到动画在自己手机上运行，还是挺有成就感的😂。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in Java</title>
    <link href="http://yoursite.com/2016/07/09/Java/"/>
    <id>http://yoursite.com/2016/07/09/Java/</id>
    <published>2016-07-09T15:37:53.000Z</published>
    <updated>2017-07-28T13:59:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>写一些看书的笔记</p>
<h3 id="第二章-一切都是对象"><a href="#第二章-一切都是对象" class="headerlink" title="第二章 一切都是对象"></a>第二章 一切都是对象</h3><h4 id="JAVA堆栈和堆"><a href="#JAVA堆栈和堆" class="headerlink" title="JAVA堆栈和堆"></a>JAVA堆栈和堆</h4><p>&emsp;&emsp;堆栈就是平时所说的栈，位于通用的ROM中，从堆栈指针从处理器那里获得直接支持。堆栈的指针向下移动，分配新的内存，向上移动，释放内存。在创建程序时，系统必须知道存储在盾战中所有的项目的确切生命周期，以便赏析移动堆栈的指针。这一约束限制了程序的灵活性，所以虽然某些JAVA数据存储在堆栈中–特别是对象引用，但是JAVA对象并不存储其中（<del>然而我并不怎么理解</del>。。）。<br>&emsp;&emsp;堆是一种通用的内存池，也是位于RAM中，用于存放所有的JAVA对象。堆对于栈的好处就是：编译器不需要知道存储的数据在堆里存货多长时间。当需要一个对象时，只需要去new，当执行这个代码会自动在堆内进行储存分配。但是用堆进行存储分配和清理可能比用栈分配需要更多的时间。<br><a id="more"></a></p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>基本类型是存储在堆里，不用new来创建变量，而是创建一个并非是引用的”自动”变量（<del>看不懂…555</del>）。基本类型具有包装器类，使得可以在堆中创建一个非基本类型，用来表示对应的基本类型。<br>可以这么用<code>int i = 5</code>也可以<code>Integer i = new Integer(5)</code>。在JAVA se5之后的自动包装功能能自动的将基本类型转换为包装器类型：<code>Character ch = &#39;x&#39;</code></p>
<h4 id="基本成员默认值"><a href="#基本成员默认值" class="headerlink" title="基本成员默认值"></a>基本成员默认值</h4><p>若类的某个成员是基本数据类型，即使没有初始化，JAVA也会确保它获得一个默认值。但是局部变量不会初始化。</p>
<h3 id="第三章-操作符"><a href="#第三章-操作符" class="headerlink" title="第三章 操作符"></a>第三章 操作符</h3><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>赋值操作的是一个对象的引用，看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span></span>&#123;</div><div class="line"><span class="keyword">int</span> level;</div><div class="line">   &#125;</div><div class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Assignment</span></span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">	Tank t1 = <span class="keyword">new</span> Tank();</div><div class="line">	Tank t2 = <span class="keyword">new</span> Tank();</div><div class="line"></div><div class="line">	t1.level = <span class="number">9</span>;</div><div class="line">	t2.level = <span class="number">21</span>;</div><div class="line"></div><div class="line">	System.out.println(<span class="string">"原本的t1:"</span>+t1.level+<span class="string">"  原本的t2:"</span>+t2.level);</div><div class="line"></div><div class="line">	t1 = t2;</div><div class="line"></div><div class="line">	System.out.println(<span class="string">"现在的t1:"</span>+t1.level+<span class="string">"  现在的t2:"</span>+t2.level);</div><div class="line"></div><div class="line">	t1.level = <span class="number">40</span>;</div><div class="line">	</div><div class="line">	System.out.println(<span class="string">"后来的t1:"</span>+t1.level+<span class="string">"  后来的t2:"</span>+t2.level);</div><div class="line"></div><div class="line">&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>看输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">原本的t1:<span class="number">9</span>  原本的t2:<span class="number">21</span></div><div class="line">现在的t1:<span class="number">21</span>  现在的t2:<span class="number">21</span></div><div class="line">后来的t1:<span class="number">40</span>  后来的t2:<span class="number">40</span></div></pre></td></tr></table></figure>
<p>正确的给t1赋值应该这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t1.level = t2.level</div></pre></td></tr></table></figure></p>
<h4 id="自动递增和递减"><a href="#自动递增和递减" class="headerlink" title="自动递增和递减"></a>自动递增和递减</h4><p>&emsp;&emsp;这个是我一直搞混的东西，总是弄混前缀和后缀的区别，现在写一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">System.out.println(<span class="string">"i:"</span>+i);</div><div class="line">System.out.println(<span class="string">"i++ :"</span>+ i++);<span class="comment">//1</span></div><div class="line">System.out.println(<span class="string">"++i :"</span> + ++i);<span class="comment">//3</span></div></pre></td></tr></table></figure>
<p> i++是先生成值后计算，也就是说在<code>i++</code>这里面的i是上一个状态的i,结果要在下一个状态才可以获取。前缀写法是先执行计算然后生成值，所以这里的i就等于三。</p>
<h4 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h4><p>&emsp;&emsp;关系操作符==和!=比较的是对象的引用，这个和在使用=进行对象赋值时一样，都是对象的引用而不是内部值。例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Integer n1 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</div><div class="line">Integer n2 = <span class="keyword">new</span> Integer(<span class="number">1</span>);</div><div class="line">System.out.println(n1 == n2);<span class="comment">//false</span></div><div class="line">System.out.println(n1 !=n2);<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>要是想比较实际内容，可以使用所有对象都适用的方法<code>equals()</code> 。但是这个方法不适用于基本类型，基本类型直接使用<code>==</code>和<code>!=</code>即可。但是在自己创建的类中，还要注意<code>euqals()</code>的坑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span></span>&#123;</div><div class="line">			<span class="keyword">int</span> i;</div><div class="line">		&#125;</div><div class="line">		Value v1 = <span class="keyword">new</span> Value();</div><div class="line">		Value v2 = <span class="keyword">new</span> Value();</div><div class="line">		System.out.println(v1.equals(v2));<span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>这是为啥？因为JAVA的设计者把对关系比较的权利完全给了类的设计者，因为<code>equasl()</code>方法对所有的对象都可以使用，所以他直接是卸载<code>Object</code>类里面。要想实现我们希望的功能，就要在自己的类中覆盖这个方法。这个方法的默认是返回对引用的比较。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总结就是：想比较实际内容，用<code>equals()</code>，想比较引用，使用<code>==</code>。（<del>感觉一般也很少直接进行对象的比较吧</del>）。</p>
<h4 id="指数计数法"><a href="#指数计数法" class="headerlink" title="指数计数法"></a>指数计数法</h4><p>在JAVA中，看到1.39e^{-43}f这样的表达式，真正的意义是1.39*10^{-43}，这个历史原因我也懒得管，要使用e有现成的公式调用（<del>我还没在开发中用过e..</del>）。</p>
<h4 id="截尾和舍入"><a href="#截尾和舍入" class="headerlink" title="截尾和舍入"></a>截尾和舍入</h4><p>在将<code>float</code>和<code>double</code>转化为<code>int</code>的时候，默认是对该数字进行<strong>截尾</strong>，就是直接舍弃小数点后面的内容。要想得到舍入的结果，可以使用<code>Math.round()</code>方法；</p>
<h3 id="第五章-初始化与清理"><a href="#第五章-初始化与清理" class="headerlink" title="第五章 初始化与清理"></a>第五章 初始化与清理</h3><h4 id="区别重载方法"><a href="#区别重载方法" class="headerlink" title="区别重载方法"></a>区别重载方法</h4><p>区别重载方法是靠方法的参数列表的不同来区分，甚至参数的顺序不同也可以区分，但是不建议这么做，太特么混乱了。</p>
<h4 id="清理-终结处理和垃圾回收"><a href="#清理-终结处理和垃圾回收" class="headerlink" title="清理:终结处理和垃圾回收"></a>清理:终结处理和垃圾回收</h4><p>JAVA主要要gc进行自动的垃圾回收，但是如果使用的对象不是new出来的，他获得了一块”特殊的”内存区域，由于垃圾回收器只知道回收那些由new分配的内存，所以它不知道如何去释放这块内存。为了对付这样的场景，JAVA允许在类中定义一个<code>finalize()</code>的方法，但是又不是像c++中的析构函数。（<del>特么编不下去了，我不懂啊，不写这玩意了</del>）。书上有三个要点还是写一下吧：</p>
<ol>
<li>对象可能不被垃圾回收</li>
<li>垃圾回收不等于析构</li>
<li>垃圾回收只与内存有关</li>
</ol>
<p>ps:书上还有很多关于如何使用<code>finalize()</code>和JAVA是如何进行垃圾回收的的东西，我对gc没点了解，暂时不看了。。</p>
<p>###构造器初始化<br>可以使用构造器进行初始化。在运行时刻，可以调用方法或者进行某些动作来确定初值。但是：<strong>无法阻止自动初始化的进行，它将在构造器被调用之前发生</strong>。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        Counter()&#123;</div><div class="line">            i = <span class="number">7</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">``` </div><div class="line"></div><div class="line">这里的i先被置为<span class="number">0</span>，然后变成<span class="number">7</span>。</div><div class="line">在类的内部，定义变量的顺序决定了初始化的顺序，即使变量定义散步在方法之间，**它们仍然会在任何方法(包括构造器)被调用之前得到初始化**</div><div class="line"></div><div class="line">```java</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span></span>&#123;</div><div class="line">		 Window(<span class="keyword">int</span> i)&#123;</div><div class="line">			    System.out.println(<span class="string">"window:"</span>+i);</div><div class="line">			&#125;	</div><div class="line">		&#125;</div><div class="line">		   <span class="class"><span class="keyword">class</span> <span class="title">House</span></span>&#123;</div><div class="line">			Window w1 = <span class="keyword">new</span> Window(<span class="number">1</span>);</div><div class="line">			House()&#123;</div><div class="line">			System.out.println(<span class="string">"House()"</span>);</div><div class="line">			w3 = <span class="keyword">new</span> Window(<span class="number">33</span>);</div><div class="line">			&#125;</div><div class="line">			Window w2 = <span class="keyword">new</span> Window(<span class="number">2</span>);</div><div class="line">			<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"f()"</span>);&#125;</div><div class="line">			Window w3 = <span class="keyword">new</span> Window(<span class="number">3</span>);</div><div class="line">			&#125;</div><div class="line">	</div><div class="line">	House h= <span class="keyword">new</span> House();</div><div class="line">	h.f();</div><div class="line">		<span class="comment">//---------结果--------</span></div><div class="line">		window:<span class="number">1</span></div><div class="line">        window:<span class="number">2</span></div><div class="line">        window:<span class="number">3</span></div><div class="line">        House()</div><div class="line">        window:<span class="number">33</span></div><div class="line">        f()</div></pre></td></tr></table></figure>
<h3 id="第七章-复用类"><a href="#第七章-复用类" class="headerlink" title="第七章 复用类"></a>第七章 复用类</h3><h4 id="组合和继承"><a href="#组合和继承" class="headerlink" title="组合和继承"></a>组合和继承</h4><p>&emsp;&emsp;组合和继承都允许在新的类中放置子对象，组合是显示的这么做，继承是隐式的做。组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情形，即新类中嵌入某个对象，让其实现所需要的功能，但新类的用户看到的只是为新类所定义的接口，而非所嵌入对象的接口，让其实现所需要的功能，需要在新类中嵌入一个现有类的private对象。<br>&emsp;&emsp;判断应该使用继承还是组合，就是是否需要从新类向上转型。如果需要，继承是必须的。</p>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ol>
<li>final的数据<br>一个永不改变的编译时常量。<br>一个运行时被初始化的值，不希望被改变。</li>
</ol>
<p>final修饰的是基本类型时数值保持不变，但是final修饰的是一个对象时，是对引用保持不变，但是对象又是可以修改的，所以用final修饰对象作用不大。</p>
<p>&emsp;&emsp;空白final<br>空白final是指声明为final但是又没有给定初始值的域。这样当我们使用不同的构造函数创建不同的类时，就可以根据对象的不同有所不同，但是又保持不变。但是必须在每个域的定义处或者每个构造函数处对final赋值。</p>
<ol>
<li><p>final方法</p>
<p>把方法锁定，以防任何继承类修改它的含义<br>确保在继承中使方法的行为保持不变。（<del>子类对父类的方法只能看不能摸</del>）<br>类中的所有的private方法都隐式的指定为final</p>
</li>
</ol>
<h3 id="第八章-多态"><a href="#第八章-多态" class="headerlink" title="第八章 多态"></a>第八章 多态</h3><p>&emsp;&emsp;多态是继 数据抽象 和 继承 之后的第三种基本类型。”封装”通过合并特性和行为来创建新的数据类型。多态的作用消除<strong>类型</strong>之间的耦合关系。</p>
<h4 id="域和静态方法"><a href="#域和静态方法" class="headerlink" title="域和静态方法"></a>域和静态方法</h4><p>只有普通的方法的调用是多态的，成员变量没有多态。（通过get和set方法去调用，而不是直接访问成员）。<br>如果方法是静态的，也没有多态性。（一般的工具类中的静态方法，子类没法重写）。</p>
<h4 id="构造函数和方法"><a href="#构造函数和方法" class="headerlink" title="构造函数和方法"></a>构造函数和方法</h4><p>构造函数不具有多态性，实际上他们是隐式的static方法。<br>复杂对象的构造方法调用顺序：</p>
<ol>
<li>基类的构造函数（一直递归下去，直到子类）</li>
<li>按声明顺序调用成员的初始化方法。</li>
<li>调用子类的构造函数主体。</li>
</ol>
<h4 id="构造函数内部的多态方法的行为"><a href="#构造函数内部的多态方法的行为" class="headerlink" title="构造函数内部的多态方法的行为"></a>构造函数内部的多态方法的行为</h4><p>先看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">new</span> RoundGlyph(<span class="number">5</span>);</div><div class="line">	&#125;</div><div class="line">     &#125;</div><div class="line">     <span class="class"><span class="keyword">class</span> <span class="title">Glyph</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;System.out.println(<span class="string">"Glayph.draw"</span>);&#125;</div><div class="line"></div><div class="line">	Glyph()&#123;</div><div class="line">		System.out.println(<span class="string">"before draw"</span>);</div><div class="line">		draw();</div><div class="line">		System.out.println(<span class="string">"after draw"</span>);</div><div class="line">	&#125;</div><div class="line">     &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RoundGlyph</span> <span class="keyword">extends</span> <span class="title">Glyph</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</div><div class="line">	RoundGlyph(<span class="keyword">int</span> r)&#123;</div><div class="line">		<span class="keyword">this</span>.radius = r;</div><div class="line">		System.out.println(<span class="string">"RoundGlyph.RoundGlyph(): "</span>+radius);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"RoundGlyph.draw(): "</span>+radius);	</div><div class="line">	&#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">before draw</div><div class="line">RoundGlyph.draw(): <span class="number">0</span><span class="comment">//此时，还没有调用子类的构造方法，也就是还没有初始化，radius默认被赋值0</span></div><div class="line">after draw</div><div class="line">RoundGlyph.RoundGlyph(): <span class="number">5</span></div></pre></td></tr></table></figure></p>
<p>初始化的实际过程：</p>
<ol>
<li>在其他任何事物发生之前，将分配给对象的储存空间初始化为二进制的零。</li>
<li>调用父类的构造函数</li>
<li>按声明顺序调用成员的初始化方法</li>
<li>调用子类的构造函数</li>
</ol>
<p>因此要避免在构造函数内调用可能会重写的方法，安全的做法是调用final的方法。</p>
<h3 id="第九章-接口"><a href="#第九章-接口" class="headerlink" title="第九章 接口"></a>第九章 接口</h3><p>&emsp;&emsp;接口表示：所有实现了该特定接口的类看起来都像这样。接口被用来创建类与类之间的协议。接口不仅仅是一个极度抽象的类，因为他允许人们通过创建一个能够向上转型为多种基类的类型，来实现某种类似多重继承变种的特性。<br>&emsp;&emsp;如果接口不添加public修饰，那么他默认是包访问权限。<br>&emsp;&emsp;这里还有对策略模式和适配器模式的介绍，这里对会在设计模式系列里面介绍。<br>&emsp;&emsp;使用接口的核心原因：为了能够向上转型为多个基类型。第二：防止创建该类的对象，并确保这仅仅是建立一个接口。<br>&emsp;&emsp;可以通过对接口的继承来进行接口的拓展，而且接口可以多重继承。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Monster</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">menace</span><span class="params">()</span></span>;</div><div class="line">   &#125;</div><div class="line">   <span class="class"><span class="keyword">interface</span> <span class="title">DangerousMonster</span> <span class="keyword">extends</span> <span class="title">Monster</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>;</div><div class="line">   &#125;</div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Lethal</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span></span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="class"><span class="keyword">interface</span> <span class="title">Vampire</span> <span class="keyword">extends</span> <span class="title">Lethal</span>,<span class="title">DangerousMonster</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">drinkblood</span><span class="params">()</span></span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;接口最吸引人的地方是允许同一个接口具有多个不同的实现。一个类 可以实现多个接口就可以实现向上转型为多个基类型<br>&emsp;&emsp;有接口，肯定就会想到工厂模式，这也会在设计模式系列中写到（<del>但愿我不拖更555</del>）。</p>
<h4 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h4><p>（<del>不负责任总结</del>）<br>让抽象类去实现接口 不需要实现全部的方法 可以只实现一部分  然后剩下的子类去实现 子类必须实现抽象类中的抽象方法<br>感觉抽象类可以作为普通类的一个缓冲   接口是完全的抽象  当只需要具有接口的部分特性  可以使用抽象类<br>一个类实现了一个接口  就可以把这个类当做接口的实例穿进去</p>
<h3 id="第十章-内部类"><a href="#第十章-内部类" class="headerlink" title="第十章 内部类"></a>第十章 内部类</h3><ul>
<li>内部类就是将一个类的定义放在另一个类的内部。内部类和组合是不一样的概念。</li>
<li>内部类可以访问到外围对象的所有成员而不需要任何的特殊条件，此外，内部类还拥有外部类的所有元素的访问权。</li>
<li>在内部类中生成对外部类的引用，可以使用<code>Outside.this</code></li>
<li>创建内部类的对象 <code>Out.Inner in = out.new Inner();</code></li>
<li>在拥有外部类对象之前是不可能创建内部类的对象的，除非是嵌套类（静态内部类）</li>
<li>将内部类向上转型为基类型，尤其是转型为一个接口时候，内部类就很有用了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main3</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">			RelaMain main = <span class="keyword">new</span> RelaMain();</div><div class="line">			Contents c = main.contents();</div><div class="line">			Destination d = main.destination(<span class="string">"laal"</span>);</div><div class="line">			</div><div class="line">			RelaMain.PDestination pd = main.new PDestination(<span class="string">"hahah"</span>);</div><div class="line">			<span class="comment">//RelaMain.PContents pc = main.new PContents();访问不到  因为是private的</span></div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">RelaMain</span></span>&#123;</div><div class="line">		<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PContents</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</div><div class="line">			<span class="keyword">private</span> <span class="keyword">int</span> i  = <span class="number">1</span>;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> i;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">PDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</div><div class="line">			<span class="keyword">private</span> String label;</div><div class="line">			PDestination(String whereto)&#123;</div><div class="line">				<span class="keyword">this</span>.label = whereto;</div><div class="line">			&#125;</div><div class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> label;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(String label)</span></span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> PDestination(label);</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> PContents();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Destination</span></span>&#123;</div><div class="line">		<span class="function">String <span class="title">readLabel</span><span class="params">()</span></span>;</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Contents</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>可以在方法里面或者任意的作用域内定义内部类：<br>1：实现某类型的接口，于是可以创建并返回对其的引用；<br>2：创建一个类来辅助你的解决方案，又不希望这个类是公共可用的。</p>
</li>
<li><p>匿名内部类和工厂方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ServiceFactory</span></span>&#123;<span class="comment">//抽象工厂接口 用于返回工厂产品</span></div><div class="line">	<span class="function">Service <span class="title">getService</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation1</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Implementation1.method1"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Implementation1.method2"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory factory = <span class="keyword">new</span> ServiceFactory() &#123;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Implementation1();</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation2</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Implementation2.method1"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"Implementation2.method1"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> ServiceFactory factory = <span class="keyword">new</span> ServiceFactory() &#123;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> Service <span class="title">getService</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Implementation2();</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serviceConsumer</span><span class="params">(ServiceFactory factory)</span></span>&#123;</div><div class="line">		Service s = factory.getService();</div><div class="line">		s.method1();</div><div class="line">		s.method2();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">		serviceConsumer(Implementation1.factory);</div><div class="line">		serviceConsumer(Implementation2.factory);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><p>如果不需要内部类对象对其外围类对象之间的联系，那么可以将内部类声明为static，叫做嵌套类。</p>
<p> 1.要创建嵌套类的对象，并不需要其外围类的对象</p>
<p> 2.不能从嵌套类的对象中访问非静态的外围类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelDestination</span> <span class="keyword">implements</span> <span class="title">Destination</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> String label;</div><div class="line">	ParcelDestination(String whereto)&#123;</div><div class="line">		<span class="keyword">this</span>.label = whereto;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> label;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherLevel</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Destination <span class="title">destination</span><span class="params">(String s)</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ParcelDestination(s);</div><div class="line">&#125;</div><div class="line"><span class="comment">//in main</span></div><div class="line">Destination dd = destination(<span class="string">"lal"</span>);</div><div class="line">	dd.readLabel();</div><div class="line">	ParcelDestination.AnotherLevel.f();</div></pre></td></tr></table></figure>
<h4 id="接口中的内部类"><a href="#接口中的内部类" class="headerlink" title="接口中的内部类"></a>接口中的内部类</h4><p>如果想创建某些公用代码，使得他们可以被某个接口的所有不同实现所公用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在接口内可以定义类</div><div class="line"> * <span class="doctag">@author</span> Mr_Wrong</div><div class="line"> * </div><div class="line"> * 只有实现了这个接口的类  才能访问到这个内部类  所以可以被实现了这个接口的所以类所共用</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">howby</span><span class="params">()</span></span>;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">TestClassInInterface</span> <span class="keyword">implements</span> <span class="title">ClassInInterface</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howby</span><span class="params">()</span> </span>&#123;</div><div class="line">			System.out.println(<span class="string">"这是接口内部的类的howby方法"</span>);			</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">			<span class="keyword">new</span> TestClassInInterface().howby();</div><div class="line">			System.out.println(<span class="string">"这是共用的部分"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="为什么需要内部类"><a href="#为什么需要内部类" class="headerlink" title="为什么需要内部类"></a>为什么需要内部类</h4><p>一般来说，内部类继承自某个类或则实现某个接口，内部类的代码操作创建它的外围类对象，所以可以认为内部类提供了某种进入外围类的窗口。</p>
<p>每个内部类都能独立的继承自一个（接口）的实现，所以无论外围类是否已经继承了某个（接口）的实现，对于内部类都是没有影响的。（内部类也有种多重继承的感觉）</p>
<p>内部类的其他特征：</p>
<p>1.内部类可以有多个实例 ，每个实例都有自己的状态信息，并且与其外围类的信息相互独立。</p>
<p>2.在单个外围类中，可以让多个内部类以不同的方式实现一个接口，或者继承自同一个类。</p>
<p>3.创建内部类对象的时刻并不依赖外围类对象的创建。</p>
<p>4.内部类冰没有令人迷惑的”is-a”关系，它就是一个独立的实体。</p>
<h4 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h4><p>闭包是一个可调用的对象，它记录了一些信息，这些信息来自创建它的作用域。</p>
<p>这是一个外围类实现一个接口和内部类实现这个接口的区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">implements</span> <span class="title">TestInterface</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">dothings</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"hasdone"</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> TestInterface <span class="title">getinterface</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Test2();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test3</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">dothings</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"test3hasdone"</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">InTest3</span> <span class="keyword">implements</span> <span class="title">TestInterface</span></span>&#123;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">dothings</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="string">"InTest3hasdone"</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="function">TestInterface <span class="title">getinterface</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> InTest3();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		TestInterface interface1 = <span class="keyword">new</span> Test2();</div><div class="line">		System.out.println(interface1.dothings());</div><div class="line">		</div><div class="line">		</div><div class="line">		Test3 test3 = <span class="keyword">new</span> Test3();</div><div class="line">		System.out.println(test3.getinterface().dothings());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为在test3中有dothings这方法，我们又不想因为实现了接而覆盖掉它，这时候就可以定义一个内部类去代替它去实现这个接口，然后在通过一个方法暴露出去。这就是一个hook（勾子）</p>
<h4 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h4><p>内部类的继承有一些特殊的语法，还是直接上代码吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidthInner</span> </span>&#123;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WidthInner</span>.<span class="title">Inner</span></span>&#123;</div><div class="line"><span class="comment">//构造函数要传外围类</span></div><div class="line">	InheritInner(WidthInner wi)&#123;</div><div class="line">		wi.<span class="keyword">super</span>();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		WidthInner wi = <span class="keyword">new</span> WidthInner();</div><div class="line">		InheritInner hi = <span class="keyword">new</span> InheritInner(wi);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="第十一章-持有对象"><a href="#第十一章-持有对象" class="headerlink" title="第十一章 持有对象"></a>第十一章 持有对象</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>当使用Arrays.aslist时候应该注意类型问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		</div><div class="line">		List&lt;Snow&gt; snow1 = Arrays.asList(<span class="keyword">new</span> Crusty(),<span class="keyword">new</span> Powder(),<span class="keyword">new</span> Slush());</div><div class="line">		</div><div class="line">		<span class="comment">//List&lt;Snow&gt; snow2= Arrays.asList(new Light());//这样提示错误  下面两个可以</span></div><div class="line">		</div><div class="line">		List&lt;Snow&gt; snow3 = <span class="keyword">new</span> ArrayList&lt;Snow&gt;();</div><div class="line">		Collections.addAll(snow3, <span class="keyword">new</span> Light(),<span class="keyword">new</span> Heavy(),<span class="keyword">new</span> Slush());</div><div class="line">		</div><div class="line">		List&lt;Snow&gt; snow4 = Arrays.&lt;Snow&gt;asList(<span class="keyword">new</span> Light(),<span class="keyword">new</span> Slush());</div><div class="line">	   &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Snow</span></span>&#123;&#125;;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Powder</span> <span class="keyword">extends</span> <span class="title">Snow</span></span>&#123;&#125;;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Light</span> <span class="keyword">extends</span> <span class="title">Powder</span></span>&#123;&#125;;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Heavy</span> <span class="keyword">extends</span> <span class="title">Powder</span></span>&#123;&#125;;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Crusty</span> <span class="keyword">extends</span> <span class="title">Snow</span></span>&#123;&#125;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Slush</span> <span class="keyword">extends</span> <span class="title">Snow</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		</div><div class="line">		</div><div class="line">		List&lt;String&gt; strings = Arrays.asList(<span class="string">"hah"</span>,<span class="string">"lal"</span>,<span class="string">"en"</span>,<span class="string">"yes"</span>,<span class="string">"no"</span>);</div><div class="line"></div><div class="line">        <span class="comment">//可以这样  包装成真正的list</span></div><div class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"hah"</span>,<span class="string">"lal"</span>,<span class="string">"en"</span>,<span class="string">"yes"</span>,<span class="string">"no"</span>));</div><div class="line">		</div><div class="line">		Iterator&lt;String&gt; it  = strings.iterator();</div><div class="line"></div><div class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">			String string = (String) it.next();</div><div class="line">			System.out.println(string);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">for</span> (String string : strings) &#123;</div><div class="line">			System.out.println(string);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		it  = list.iterator();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">			it.next();</div><div class="line">			it.remove();<span class="comment">//这里不能进行对strings进行remove  是因为这个list仅仅是对数组的的包装   数组有确切的长度  不能进行remove操作</span></div><div class="line">			<span class="comment">//在使用迭代器的remove之前要先调用next</span></div><div class="line">		&#125;</div><div class="line">		System.out.println(list);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ListIterator是Iterator的一个子类，只能用于各种list类的访问，它可以双向移动：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ListIterator&lt;String&gt; listit = list.listIterator();</div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (listit.hasNext()) &#123;</div><div class="line">			String string = (String) listit.next();</div><div class="line">			System.out.println(string+<span class="string">","</span>+listit.nextIndex()+<span class="string">","</span>+listit.previousIndex());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">while</span> (listit.hasPrevious()) &#123;</div><div class="line">			System.out.println(listit.previousIndex());</div><div class="line">			listit.set(<span class="string">""</span>);</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</div><div class="line">		<span class="keyword">for</span> (String s : <span class="string">"my dog is dog ha ha ha"</span>.split(<span class="string">" "</span>)) &#123;</div><div class="line">			stack.push(s);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">while</span>(!stack.empty())&#123;</div><div class="line">			System.out.println(stack.pop());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">	<span class="keyword">private</span> LinkedList&lt;T&gt; storage = <span class="keyword">new</span> LinkedList&lt;T&gt;();</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T v)</span></span>&#123;storage.addFirst(v);&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> storage.getFirst();&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> storage.removeFirst();&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> storage.isEmpty();&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">tosString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> storage.toString();&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//输出</span></div><div class="line">ha</div><div class="line">ha</div><div class="line">ha</div><div class="line">dog</div><div class="line">is</div><div class="line">dog</div><div class="line">my</div></pre></td></tr></table></figure>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>set不保存重复的元素，查找就是set中最重要的操作。通常使用一个hashset，它专门为快速查找进行了优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Random rand = <span class="keyword">new</span> Random();</div><div class="line">	Set&lt;Integer&gt; intset = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">		intset.add(rand.nextInt(<span class="number">10</span>));</div><div class="line">	&#125;</div><div class="line">	System.out.println(intset);</div><div class="line">	<span class="comment">//输出</span></div><div class="line">	[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</div></pre></td></tr></table></figure>
<p>其实hashset的输出是没有顺序的，要想有顺序可以使用treeset，但是这里为什么是有顺序的呢，这也算是一个巧合吧，具体的可以看这里  知乎上的解释<a href="http://www.zhihu.com/question/28414001" target="_blank" rel="external">Java遍历HashSet为什么输出是有序的？</a></p>
<p>treeset将元素储存在红黑树数据结构中，而HashSet使用的是散列函数。LinkedList因为查询速度的原因也使用了散列，但是看起来它使用了链表来维护元素的插入顺序。</p>
<p>使用treeset可以指定排序方式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//按字母表排序</span></div><div class="line">Set&lt;String&gt; words = <span class="keyword">new</span> TreeSet&lt;String&gt;(String.CASE_INSENSITIVE_ORDER);</div></pre></td></tr></table></figure></p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>队列是一个典型的先进先出的容器。</p>
<p>LinkedList提供了方法以支持队列的行为，并且它实现了queue接口，因此linkedklist可以作为queue的一种实现。</p>
<p>一些queue的常用方法：</p>
<p>offer()将一个元素插入到队尾或者返回false;<br>peek()和element()都在不移除的情况下返回队头，但是peek()方法在队列为空时返回Null，element()会抛出NoSuchElementException异常。<br>Poll()和remove()移除并返回队头，当队列为空时，同上。</p>
<h4 id="Collection和Iterator"><a href="#Collection和Iterator" class="headerlink" title="Collection和Iterator"></a>Collection和Iterator</h4><p>Collection是描述所有序列容器的共性根接口。<br>要实现Collection就意味着需要提供iterator()方法。</p>
<h4 id="Foreach与迭代器"><a href="#Foreach与迭代器" class="headerlink" title="Foreach与迭代器"></a>Foreach与迭代器</h4><p>如果你创建了任何实现了Iterable的类，都可以将它用于foreach语句中。</p>
<p>尝试把数组当做一个Iterable参数传递会导致失败。这说明不存在任何从数组到Iterable的自动转换，必须手动执行这种转换。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>数组将数字与对象联系起来，但是数组一旦生成，其容量就不能改变。</li>
<li>Collection保存单一的元素，Map保存相关联的键值对。容器不能持有基本类型，但是自动包装机制会执行双向转换。</li>
<li>进行大量随机的访问，使用ArrayList。经常从表中间插入或者删除元素，使用LinkedList.</li>
<li>各种Queue以及栈的行为，由linkedlist提供支持。</li>
</ol>
<p><img src="http://img.my.csdn.net/uploads/201012/10/0_129197029221PZ.gif" alt=""></p>
<h3 id="第十二章-通过异常处理错误"><a href="#第十二章-通过异常处理错误" class="headerlink" title="第十二章 通过异常处理错误"></a>第十二章 通过异常处理错误</h3><p>这章暂时先不看了，处理异常的内容我觉得先暂时了解了一些，在写Android用处没那么多，以后要用的时候再来从头看。</p>
<h3 id="第十三章-字符串"><a href="#第十三章-字符串" class="headerlink" title="第十三章 字符串"></a>第十三章 字符串</h3><ul>
<li>String对象是不可变的</li>
<li>在使用”+”进行String的拼接的时候，隐式的调用了StringBuilder来进行处理。这不意味着可以随便的使用”+”。显式的调用效率会更高，使用<code>stringbuilder.append(string)</code>来进行拼接。同时StringBuilder还提供了丰富的处理字符串的方法。</li>
<li>当想打印对象的内存地址的时候，或许会考虑使用this。比如</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"InfiniteRecursion address :"</span>+<span class="keyword">this</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>这时候会出现一大堆的异常信息。这是因为发生了无意识的递归。在使用”+”this的时候，编译器尝试把this转换为一个字符串，就又去调用了tostring方法。所以正确的方法是调用<code>super.tostring()</code></p>
<h4 id="String对象有一下基本的方法，"><a href="#String对象有一下基本的方法，" class="headerlink" title="String对象有一下基本的方法，"></a>String对象有一下基本的方法，</h4><ul>
<li><code>equalsIgnoreCase()</code>  忽略大小写</li>
<li><code>startswith(),endswith()</code>  起始和结束的string</li>
</ul>
<h4 id="String的格式化输出"><a href="#String的格式化输出" class="headerlink" title="String的格式化输出"></a>String的格式化输出</h4><p>Formatter类，可以看做是一个翻译器，它将你的格式化字符串与数据翻译成需要的结果。<br>格式化说明符：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    %[argument_index$][flags][width][.precision]conversion</div><div class="line">``` </div><div class="line">width是指定一个域的最小尺寸，Formatter对象通过添加空格来保证最小尺寸。默认是右对齐，可以使用-来进行左对齐。precision的来指定最大的尺寸，可以用于浮点数取位。无法用于整数，会引发异常。例如：</div><div class="line">```java</div><div class="line">s=String.format(<span class="string">"%-10.2f %-5s"</span>, <span class="number">1.2334</span>,<span class="string">"后面的"</span>);</div><div class="line">System.out.println(s);</div><div class="line"><span class="comment">//结果</span></div><div class="line"><span class="number">1.23</span>       后面的</div></pre></td></tr></table></figure></p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ul>
<li>？表示可能有</li>
<li>\d 表示一个数字</li>
<li><ul>
<li>表示有一个或多个</li>
</ul>
</li>
<li>\w 表示分隔单词<br>这个我也只是看了点简单的，后面复杂的也没去了解，一则因为目前开发中还用不到那么复杂的正则表达式，一般就是处理一下字符串。二则网上有很多在线生成表达式的网站。暂时先放着吧。</li>
</ul>
<h3 id="第十四章-类型信息"><a href="#第十四章-类型信息" class="headerlink" title="第十四章 类型信息"></a>第十四章 类型信息</h3><ul>
<li>运行时类型信息使得你可以在程序运行时发现和使用类型信息。</li>
<li>RTTI（Run-Time Type Identification）：就是在运行时识别一个对象的类型。<h4 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h4></li>
<li>类型信息在运行时的表达是由称作Class对象的特殊对象完成的。所有的类都是在对其第一次使用时，动态加载带JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类，这也说明了构造函数是类的静态方法。</li>
<li><code>Class.forName(&quot;&quot;)</code>这个方法是class类（所有class对象都属于这个类）的一个static成员。这个是获取class对象的引用的一种方式。如果类没有被加载就去加载它。</li>
<li><code>Class</code>的<code>newInstance()</code>方法是实现”虚拟构造器”的一种途径，”我不知道你的具体类型，但是无论如何要正确的创建自己”。<h4 id="类字面常量"><a href="#类字面常量" class="headerlink" title="类字面常量"></a>类字面常量</h4></li>
<li>也是用来生成对class对象的引用，<code>Toy.class</code>。这个不仅简单，而且更安全，编译期就会收到检查。但是他不会自动初始化该class对象。<h4 id="泛化的class引用"><a href="#泛化的class引用" class="headerlink" title="泛化的class引用"></a>泛化的class引用</h4></li>
<li><p>类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; intclass = <span class="keyword">int</span>.class</div></pre></td></tr></table></figure>
<p>向class引用添加泛型语法的原因仅仅是为了提供编译期类型检查。</p>
</li>
</ul>
<h4 id="类型转换前先做检查"><a href="#类型转换前先做检查" class="headerlink" title="类型转换前先做检查"></a>类型转换前先做检查</h4><p>已知的RTTI形式包括</p>
<ol>
<li>传统的类型转换。</li>
<li>代表对象的类型的class对象。</li>
<li>还有就是使用<code>instanceof</code>，告诉我们对象是不是某个特定类型的实例。</li>
</ol>
<h4 id="反射：运行时的类信息"><a href="#反射：运行时的类信息" class="headerlink" title="反射：运行时的类信息"></a>反射：运行时的类信息</h4><p>这个关于反射的后面写了一篇专门的，<a href="http://70kg.info/2015/09/14/java%E5%8F%8D%E5%B0%84/" target="_blank" rel="external">java反射</a></p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>之前也过代理模式，去那里看吧。<a href="http://70kg.info/2015/08/04/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">代理模式</a></p>
<h4 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h4><p>这个不知道怎么写了。。</p>
<h4 id="接口和类型信息"><a href="#接口和类型信息" class="headerlink" title="接口和类型信息"></a>接口和类型信息</h4><p>这个怎么说呢，还是在讲反射的应用，还有接口，类转型的问题。</p>
<h3 id="第十五章-泛型"><a href="#第十五章-泛型" class="headerlink" title="第十五章 泛型"></a>第十五章 泛型</h3><ul>
<li>一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。所以可以使用泛型，这个意思就是适用于许许多多的类型。<br>###简单泛型<br>引入泛型的最引人注目的原因就是创造容器类。<br>这是一个简答的泛型例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">private</span> T a;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T a)</span></span>&#123;<span class="keyword">this</span>.a = a;&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T a)</span></span>&#123;<span class="keyword">this</span>.a = a;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Holder&lt;Mobile&gt; holder = <span class="keyword">new</span> Holder&lt;Mobile&gt;(<span class="keyword">new</span> Mobile());</div><div class="line">		holder.get();</div><div class="line">		holder.set(<span class="keyword">new</span> Mobile());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mobile</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><ul>
<li>return语句只能返回一个对象，当我们需要返回多个对象的时候，可以创建一个对象，让他来持有想要返回的多个对象，这就是元组的概念。我们可以使用泛型来优化使用。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">final</span> A first;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">final</span> B second;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">(A a,B b )</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.first = a;</div><div class="line">		<span class="keyword">this</span>.second= b;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> first+<span class="string">","</span>+second;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在上面的程序中，<code>first</code>和<code>second</code>都是public，理论上应该是private的，然后通过get和set方法去访问他们的值，但是这里使用了final。这样就只允许外界去读取而不允许去改变值。同时我们还可以使用继承去拓展元组，让它去支持更多的参数。<br>要使用元组也是很方便：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> Tuple&lt;String,Integer&gt; <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Tuple&lt;String, Integer&gt;(<span class="string">"hahah"</span>, <span class="number">12</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	System.out.println(f());</div></pre></td></tr></table></figure></p>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><ul>
<li>泛型可以应用于接口，例如生成器，这样一种专门负责创建对象的类，实现上实际是工厂方法设计模式的一种应用。例如<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="function">T <span class="title">next</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>下面演示一下如何使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">Coffee</span>&gt;,<span class="title">Iterable</span>&lt;<span class="title">Coffee</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Class[] types = &#123;Mocha.class,Coffee.class,Mocha.class&#125;;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">47</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CoffeeGenerator</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CoffeeGenerator</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;<span class="keyword">this</span>.size= size;&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> Iterator&lt;Coffee&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> CoffeeIterator();</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Coffee&gt; action)</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Spliterator&lt;Coffee&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">return</span> (Coffee) types[random.nextInt(types.length)].newInstance();</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">CoffeeIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Coffee</span>&gt;</span>&#123;</div><div class="line">		<span class="keyword">int</span> count = size;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> count&gt;<span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> Coffee <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">			count--;</div><div class="line">			<span class="keyword">return</span> CoffeeGenerator.<span class="keyword">this</span>.next();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Coffee&gt; action)</span> </span>&#123;</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		CoffeeGenerator gen = <span class="keyword">new</span> CoffeeGenerator();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">			System.out.println(gen.next());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(Coffee c:<span class="keyword">new</span> CoffeeGenerator(<span class="number">5</span>))&#123;</div><div class="line">			System.out.println(c);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><ul>
<li>泛型方法使得方法可以独立于类而产生变化：无论何时，只要你能做到，就应该尽量使用泛型方法。例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneircMethods</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T x)</span></span>&#123;</div><div class="line">		System.out.println(x.getClass().getSimpleName());</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		GeneircMethods m = <span class="keyword">new</span> GeneircMethods();</div><div class="line">		m.f(<span class="string">""</span>);</div><div class="line">		m.f(<span class="number">1</span>);</div><div class="line">		m.f(<span class="number">1.0</span>);</div><div class="line">		m.f(m);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出</span></div><div class="line">String</div><div class="line">Integer</div><div class="line">Double</div><div class="line">GeneircMethods</div></pre></td></tr></table></figure>
</li>
</ul>
<p>泛型是不支持基本类型作为类型参数的 ，但是由于JAVA的自动打包机制，我们并不需要太多担心。</p>
<ul>
<li>可变参数和泛型方法可以很好的共存：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makelist</span><span class="params">(T...args)</span></span>&#123;</div><div class="line">		List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;T&gt;();</div><div class="line">		<span class="keyword">for</span>(T item: args)&#123;</div><div class="line">			result.add(item);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="用于Generator的泛型方法"><a href="#用于Generator的泛型方法" class="headerlink" title="用于Generator的泛型方法"></a>用于Generator的泛型方法</h4><ul>
<li>使用生成器，可以很方便的填充一个Collection。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generators</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">fill</span><span class="params">(Collection&lt;T&gt; coll,Generator&lt;T&gt; gen,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">			coll.add(gen.next());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> coll;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Collection&lt;Coffee&gt; coffee= fill(<span class="keyword">new</span> ArrayList&lt;Coffee&gt;(), <span class="keyword">new</span> CoffeeGenerator(), <span class="number">4</span>);</div><div class="line">		<span class="keyword">for</span>(Coffee c:coffee)&#123;</div><div class="line">			System.out.println(c);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="一个通用的Generator"><a href="#一个通用的Generator" class="headerlink" title="一个通用的Generator"></a>一个通用的Generator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">	<span class="keyword">private</span> Class&lt;T&gt; type;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BaseGenerator</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;<span class="keyword">this</span>.type = type;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">return</span> type.newInstance();</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</div><div class="line">		&#125; </div><div class="line">	&#125;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Generator&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BaseGenerator&lt;T&gt;(type);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要使用这个生成器，这个类必须声明为public和必须有默认的构造函数。例如使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountedObject</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> count = <span class="number">0</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id = count++;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">id</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> id;&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">"CountedObject"</span>+id;&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//---</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseGeneratorDome</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Generator&lt;CountedObject&gt; gen = BaseGenerator.create(CountedObject.class);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">			System.out.println(gen.next());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同时我又改造了一下，使他可以支持有参构造函数😁：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">	<span class="keyword">private</span> Class&lt;T&gt; type;</div><div class="line">	<span class="keyword">private</span> Object[] a;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BaseGenerator</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;<span class="keyword">this</span>.type = type;&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BaseGenerator</span><span class="params">(Class&lt;T&gt; type,Object[] a)</span></span>&#123;<span class="keyword">this</span>.type = type;<span class="keyword">this</span>.a= a;;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">return</span> type.newInstance();</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</div><div class="line">		&#125; </div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">(Class&lt;?&gt;... agrs)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Constructor c = type.getDeclaredConstructor(agrs);</div><div class="line">			c.setAccessible(<span class="keyword">true</span>); </div><div class="line">			<span class="keyword">return</span> (T) c.newInstance(a);</div><div class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</div><div class="line">		&#125; </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Generator&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BaseGenerator&lt;T&gt;(type);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Generator&lt;T&gt; <span class="title">create</span><span class="params">(Class&lt;T&gt; type,Object[] a)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BaseGenerator&lt;T&gt;(type,a);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//---使用---</span></div><div class="line">Generator&lt;CountedObject&gt; gen1 = BaseGenerator.create(CountedObject.class,<span class="keyword">new</span> Object[]&#123;<span class="number">5</span>,<span class="number">6</span>&#125;);</div><div class="line">		gen1.next(<span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class,<span class="keyword">int</span>.class&#125;);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写一些看书的笔记&lt;/p&gt;
&lt;h3 id=&quot;第二章-一切都是对象&quot;&gt;&lt;a href=&quot;#第二章-一切都是对象&quot; class=&quot;headerlink&quot; title=&quot;第二章 一切都是对象&quot;&gt;&lt;/a&gt;第二章 一切都是对象&lt;/h3&gt;&lt;h4 id=&quot;JAVA堆栈和堆&quot;&gt;&lt;a href=&quot;#JAVA堆栈和堆&quot; class=&quot;headerlink&quot; title=&quot;JAVA堆栈和堆&quot;&gt;&lt;/a&gt;JAVA堆栈和堆&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;堆栈就是平时所说的栈，位于通用的ROM中，从堆栈指针从处理器那里获得直接支持。堆栈的指针向下移动，分配新的内存，向上移动，释放内存。在创建程序时，系统必须知道存储在盾战中所有的项目的确切生命周期，以便赏析移动堆栈的指针。这一约束限制了程序的灵活性，所以虽然某些JAVA数据存储在堆栈中–特别是对象引用，但是JAVA对象并不存储其中（&lt;del&gt;然而我并不怎么理解&lt;/del&gt;。。）。&lt;br&gt;&amp;emsp;&amp;emsp;堆是一种通用的内存池，也是位于RAM中，用于存放所有的JAVA对象。堆对于栈的好处就是：编译器不需要知道存储的数据在堆里存货多长时间。当需要一个对象时，只需要去new，当执行这个代码会自动在堆内进行储存分配。但是用堆进行存储分配和清理可能比用栈分配需要更多的时间。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
