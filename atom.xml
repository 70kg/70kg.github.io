<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>70kg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-10T13:07:28.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>70kg</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReactNative是怎么在Android上跑起来的</title>
    <link href="http://yoursite.com/2017/09/08/ReactNative%E6%98%AF%E6%80%8E%E4%B9%88%E5%9C%A8Android%E4%B8%8A%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
    <id>http://yoursite.com/2017/09/08/ReactNative是怎么在Android上跑起来的/</id>
    <published>2017-09-08T15:56:12.000Z</published>
    <updated>2017-09-10T13:07:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>(源码版本：0.34，新版本(0.48)基本流程是不变的，建议跟着源码看看，哪个版本的倒影响不大)<br>这篇简单刨析一下<code>React Native</code>是怎么在<code>Android</code>上跑起来的，会从下面几个方面说说。<a id="more"></a></p>
<ul>
<li>启动流程</li>
<li>通信机制</li>
<li>事件驱动  </li>
<li>渲染原理 </li>
<li>脚本执行 </li>
</ul>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p><code>React Native</code>在<code>Android</code>上启动是从<code>ReactRootView.startReactApplication</code>触发的，而<code>ReactRootView</code>是继承<code>FrameLayout</code>的，所以<code>React Native</code>在<code>Android</code>的操作都是在这个<code>View</code>中进行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startReactApplication(ReactInstanceManager reactInstanceManager, String moduleName, <span class="meta">@Nullable</span> Bundle launchOptions)</div></pre></td></tr></table></figure>
<p>这个方法参数第一个<code>ReactInstanceManager</code>，实现是<code>XReactInstanceManagerImpl</code>，可以理解在应用层对<code>RN</code>的配置都是对这个类操作实现的。<code>moduleName</code>是要启动的<code>RN</code>的<code>Component</code>的<code>name</code>,是在<code>js</code>的<code>AppRegistry.registerComponent(&#39;xxx&#39;, () =&gt; App);</code>定义的。最后的<code>launchOptions</code>是传过去的参数，可以在<code>js</code>的<code>Component</code>的<code>props</code>中获取。</p>
<p>下一步到了<code>mReactInstanceManager.createReactContextInBackground();</code>是在后台线程中创建<code>RN</code>的<code>ReactContext</code>上下文对象，然后到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JavaScriptExecutor 默认就是jsc,如果的debug在chrome上时候，就是v8。</span></div><div class="line"><span class="comment">//JSBundleLoader 有AssetLoader FileLoader CachedBundleFromNetworkLoader RemoteDebuggerBundleLoader 从不同的地方加载bundle</span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recreateReactContextInBackground</span><span class="params">(</span></span></div><div class="line">      JavaScriptExecutor.Factory jsExecutorFactory,</div><div class="line">      JSBundleLoader jsBundleLoader) &#123;</div><div class="line">    UiThreadUtil.assertOnUiThread();</div><div class="line"></div><div class="line">    ReactContextInitParams initParams =</div><div class="line">        <span class="keyword">new</span> ReactContextInitParams(jsExecutorFactory, jsBundleLoader);</div><div class="line">    <span class="keyword">if</span> (mReactContextInitAsyncTask == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// No background task to create react context is currently running, create and execute one.</span></div><div class="line">      mReactContextInitAsyncTask = <span class="keyword">new</span> ReactContextInitAsyncTask();</div><div class="line">      mReactContextInitAsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, initParams);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// Background task is currently running, queue up most recent init params to recreate context</span></div><div class="line">      <span class="comment">// once task completes.</span></div><div class="line">      mPendingReactContextInitParams = initParams;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>主要的创建工作就转移到了<code>ReactContextInitAsyncTask</code>这个<code>AsyncTask</code>里面，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> Result&lt;ReactApplicationContext&gt; <span class="title">doInBackground</span><span class="params">(ReactContextInitParams... params)</span> </span>&#123;</div><div class="line">     ....</div><div class="line">      <span class="keyword">return</span> Result.of(createReactContext(jsExecutor, params[<span class="number">0</span>].getJsBundleLoader()));</div><div class="line">     ....</div><div class="line">   &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> ReactApplicationContext <span class="title">createReactContext</span><span class="params">(</span></span></div><div class="line">     JavaScriptExecutor jsExecutor,</div><div class="line">     JSBundleLoader jsBundleLoader) &#123;</div><div class="line">   ...</div><div class="line">    NativeModuleRegistry.Builder nativeRegistryBuilder = <span class="keyword">new</span> NativeModuleRegistry.Builder();<span class="comment">//NativeModule的注册表</span></div><div class="line">   JavaScriptModuleRegistry.Builder jsModulesBuilder = <span class="keyword">new</span> JavaScriptModuleRegistry.Builder();<span class="comment">//jsModules的注册表</span></div><div class="line">   ...打包定义的各种modules到上面的注册表...</div><div class="line">   </div><div class="line">       <span class="comment">//创建关键的CatalystInstanceImpl</span></div><div class="line">       CatalystInstanceImpl.Builder catalystInstanceBuilder = <span class="keyword">new</span> CatalystInstanceImpl.Builder()</div><div class="line">       ...</div><div class="line">       catalystInstance = catalystInstanceBuilder.build();</div><div class="line">   ....</div><div class="line">   <span class="comment">//扔到js线程中加载js脚本</span></div><div class="line">   catalystInstance.getReactQueueConfiguration().getJSQueueThread().callOnQueue(</div><div class="line">       <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">           <span class="comment">//让reactContext持有catalystInstance</span></div><div class="line">           reactContext.initializeWithInstance(catalystInstance);</div><div class="line">           ...</div><div class="line">           catalystInstance.runJSBundle();</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">         &#125;</div><div class="line">       &#125;).get();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在<code>CatalystInstanceImpl</code>的构造函数中有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">//native C++方法，用来初始化JNI相关状态然后返回mHybridData。具体在 OnLoad.cpp 的 JSCJavaScriptExecutorHolder 类中</span></div><div class="line">mHybridData = initHybrid();</div><div class="line">...</div><div class="line"><span class="comment">//初始化线程环境，包括和主线程绑定，JS线程，Native线程创建。</span></div><div class="line">mReactQueueConfiguration = ReactQueueConfigurationImpl.create(</div><div class="line">        ReactQueueConfigurationSpec,</div><div class="line">        <span class="keyword">new</span> NativeExceptionHandler());</div><div class="line">...</div><div class="line">initializeBridge(</div><div class="line">      <span class="keyword">new</span> BridgeCallback(<span class="keyword">this</span>),<span class="comment">//CatalystInstanceImpl内部类，用于native对java的一些回调</span></div><div class="line">      jsExecutor,<span class="comment">//jsc</span></div><div class="line">      mReactQueueConfiguration.getJSQueueThread(),<span class="comment">//js线程队列</span></div><div class="line">      mReactQueueConfiguration.getNativeModulesQueueThread(),<span class="comment">//native线程队列</span></div><div class="line">      mJavaRegistry.getModuleRegistryHolder(<span class="keyword">this</span>));<span class="comment">//nativemodules注册表</span></div><div class="line">    mMainExecutorToken = getMainExecutorToken();<span class="comment">//貌似是用于切换jsExecutor的标记，后面版本删掉了。</span></div></pre></td></tr></table></figure>
<p>然后就进入到了<code>cpp</code>层的<code>CatalystInstanceImpl.cpp</code>的<code>initializeBridge</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> CatalystInstanceImpl::initializeBridge(</div><div class="line">    jni::alias_ref&lt;ReactCallback::javaobject&gt; callback,</div><div class="line">    <span class="comment">// This executor is actually a factory holder.</span></div><div class="line">    JavaScriptExecutorHolder* jseh,</div><div class="line">    jni::alias_ref&lt;JavaMessageQueueThread::javaobject&gt; jsQueue,</div><div class="line">    jni::alias_ref&lt;JavaMessageQueueThread::javaobject&gt; moduleQueue,</div><div class="line">    ModuleRegistryHolder* mrh) &#123;</div><div class="line">    </div><div class="line">  instance_-&gt;initializeBridge(folly::make_unique&lt;JInstanceCallback&gt;(callback),</div><div class="line">                              jseh-&gt;getExecutorFactory(),</div><div class="line">                              folly::make_unique&lt;JMessageQueueThread&gt;(jsQueue),</div><div class="line">                              folly::make_unique&lt;JMessageQueueThread&gt;(moduleQueue),</div><div class="line">                              mrh-&gt;getModuleRegistry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后有委托给了<code>Instance.cpp</code>的<code>initializeBridge</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Instance::initializeBridge(</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;InstanceCallback&gt; callback,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;JSExecutorFactory&gt; jsef,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MessageQueueThread&gt; jsQueue,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MessageQueueThread&gt; nativeQueue,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ModuleRegistry&gt; moduleRegistry) &#123;</div><div class="line">  callback_ = <span class="built_in">std</span>::move(callback);</div><div class="line"></div><div class="line">  <span class="comment">//在js线程中包装nativeQueue和创建nativeToJsBridge_，后者在双向bridge起作用，不要仅仅看名字，内部还有一个JsToNativeBridge</span></div><div class="line">  jsQueue-&gt;runOnQueueSync(</div><div class="line">    [<span class="keyword">this</span>, &amp;jsef, moduleRegistry, jsQueue,</div><div class="line">     nativeQueue=folly::makeMoveWrapper(<span class="built_in">std</span>::move(nativeQueue))] () <span class="keyword">mutable</span> &#123;</div><div class="line">      nativeToJsBridge_ = folly::make_unique&lt;NativeToJsBridge&gt;(</div><div class="line">          jsef.get(), moduleRegistry, jsQueue, nativeQueue.move(), callback_);</div><div class="line">    &#125;);</div><div class="line">  CHECK(nativeToJsBridge_);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这就看没了，再回到上面的<code>catalystInstance.runJSBundle();</code>以<code>FileLoader</code>为例，最终走到<code>native void loadScriptFromFile(String fileName, String sourceURL);</code>进入<code>CatalystInstanceImpl.cpp</code>进而委托给<code>Instance.cpp</code>。预警。。下面是一大片的<code>cpp</code>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">void Instance::loadScriptFromFile(const std::string&amp; filename,</div><div class="line">                                  const std::string&amp; sourceURL) &#123;</div><div class="line">  ...检测文件合法性等...</div><div class="line">  loadScriptFromString(std::move(buf), sourceURL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Instance::loadScriptFromString(std::unique_ptr&lt;const JSBigString&gt; string,</div><div class="line">                                    std::string sourceURL) &#123;</div><div class="line">  callback_-&gt;incrementPendingJSCalls();//这个callback就是java层的CatalystInstanceImpl的BridgeCallback这个内部类。</div><div class="line">  ...</div><div class="line">  nativeToJsBridge_-&gt;loadApplicationScript(std::move(string), std::move(sourceURL));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void NativeToJsBridge::loadApplicationScript(std::unique_ptr&lt;const JSBigString&gt; script,</div><div class="line">                                             std::string sourceURL) &#123;</div><div class="line">  m_mainExecutor-&gt;loadApplicationScript(std::move(script), std::move(sourceURL));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void JSCExecutor::loadApplicationScript(std::unique_ptr&lt;const JSBigString&gt; script, std::string sourceURL) throw(JSException) &#123;</div><div class="line">    ...</div><div class="line">     //使用webkit JSC去真正解释执行Javascript了！</div><div class="line">     evaluateScript(m_context, jsScript, jsSourceURL);</div><div class="line">     //绑定桥，核心是通过getGlobalObject将JS与C++通过webkit JSC bind</div><div class="line">     bindBridge(); </div><div class="line">     flush();//这里算是通知java,加载完js脚本</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">void JSCExecutor::bindBridge() throw(JSException) &#123;</div><div class="line">  ...下面都是通过jsc 获取js的一下属性，方法等...</div><div class="line">  auto global = Object::getGlobalObject(m_context);</div><div class="line">  auto batchedBridgeValue = global.getProperty(&quot;__fbBatchedBridge&quot;);</div><div class="line">...</div><div class="line">  auto batchedBridge = batchedBridgeValue.asObject();</div><div class="line">  m_callFunctionReturnFlushedQueueJS = batchedBridge.getProperty(&quot;callFunctionReturnFlushedQueue&quot;).asObject();</div><div class="line">  m_invokeCallbackAndReturnFlushedQueueJS = batchedBridge.getProperty(&quot;invokeCallbackAndReturnFlushedQueue&quot;).asObject();</div><div class="line">  //这个比较重要 获取MessageQueue.js的flushedQueue 下面就用到</div><div class="line">  m_flushedQueueJS = batchedBridge.getProperty(&quot;flushedQueue&quot;).asObject();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//这个下面js-&gt;native的时候还会提到</div><div class="line">void JSCExecutor::flush() &#123;</div><div class="line">  ...真的烦，绕来绕去  m_flushedQueueJS看上面</div><div class="line">  callNativeModules(m_flushedQueueJS-&gt;callAsFunction(&#123;&#125;));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void JSCExecutor::callNativeModules(Value&amp;&amp; value) &#123;</div><div class="line">    ...</div><div class="line">  try &#123;</div><div class="line">    auto calls = value.toJSONString();</div><div class="line">    //class JsToNativeBridge : public react::ExecutorDelegate</div><div class="line">    m_delegate-&gt;callNativeModules(*this, std::move(calls), true);</div><div class="line">  &#125; catch (...) &#123;</div><div class="line">   ...</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">  void callNativeModules(</div><div class="line">      JSExecutor&amp; executor, std::string callJSON, bool isEndOfBatch) override &#123;</div><div class="line">    ExecutorToken token = m_nativeToJs-&gt;getTokenForExecutor(executor);</div><div class="line">    m_nativeQueue-&gt;runOnQueue([this, token, callJSON=std::move(callJSON), isEndOfBatch] &#123;</div><div class="line">      for (auto&amp; call : react::parseMethodCalls(callJSON)) &#123;</div><div class="line">        //快完了  这个是ModuleRegistry.cpp 是在initializeBridge间接创建包装nativemodule的</div><div class="line">        m_registry-&gt;callNativeMethod(</div><div class="line">          token, call.moduleId, call.methodId, std::move(call.arguments), call.callId);</div><div class="line">      &#125;</div><div class="line">      if (isEndOfBatch) &#123;</div><div class="line">        //又见到了这个callback</div><div class="line">        m_callback-&gt;onBatchComplete();</div><div class="line">        m_callback-&gt;decrementPendingJSCalls();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">void ModuleRegistry::callNativeMethod(ExecutorToken token, unsigned int moduleId, unsigned int methodId,</div><div class="line">                                      folly::dynamic&amp;&amp; params, int callId) &#123;</div><div class="line"> ...</div><div class="line"></div><div class="line">  modules_[moduleId]-&gt;invoke(token, methodId, std::move(params));</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到最后一句就是要去调用<code>nativeModule</code>里面的方法了，具体在<code>ModuleRegistryHolder.cpp</code>的<code>JavaNativeModule</code>类和<code>NewJavaNativeModule</code>类，对应<code>Java</code>的<code>JavaModuleWrapper.java</code>，就是<code>jni</code>调用。</p>
<p>说到这里，现在只完成了<code>bridge</code>环境的初步搭建，把<code>jsbundle</code>扔到<code>jsc</code>里面，还没真正拉起<code>React Native</code>应用。还是回到上面那个<code>AsyncTask</code>的<code>onPostExecute</code>方法。看看执行完这么一大堆准备代码之后，是怎么拉起来整个应用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Result&lt;ReactApplicationContext&gt; result)</span> </span>&#123;</div><div class="line">      ....</div><div class="line">       setupReactContext(result.get());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupReactContext</span><span class="params">(ReactApplicationContext reactContext)</span> </span>&#123;</div><div class="line">    ...各种listener回调，通知birdge就绪，reactContext创建完成</div><div class="line">    <span class="keyword">for</span> (ReactRootView rootView : mAttachedRootViews) &#123;</div><div class="line">      attachMeasuredRootViewToInstance(rootView, catalystInstance);</div><div class="line">    &#125;</div><div class="line">    ...各种listener回调，通知birdge就绪，reactContext创建完成</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attachMeasuredRootViewToInstance</span><span class="params">(ReactRootView rootView,CatalystInstance catalystInstance)</span> </span>&#123;</div><div class="line">   ....</div><div class="line">    UIManagerModule uiManagerModule = catalystInstance.getNativeModule(UIManagerModule.class);</div><div class="line">    <span class="keyword">int</span> rootTag = uiManagerModule.addMeasuredRootView(rootView);</div><div class="line">    rootView.setRootViewTag(rootTag);</div><div class="line">    <span class="meta">@Nullable</span> Bundle launchOptions = rootView.getLaunchOptions();</div><div class="line">    WritableMap initialProps = Arguments.makeNativeMap(launchOptions);</div><div class="line">    String jsAppModuleName = rootView.getJSModuleName();</div><div class="line"></div><div class="line">    WritableNativeMap appParams = <span class="keyword">new</span> WritableNativeMap();</div><div class="line">    appParams.putDouble(<span class="string">"rootTag"</span>, rootTag);</div><div class="line">    appParams.putMap(<span class="string">"initialProps"</span>, initialProps);</div><div class="line">    <span class="comment">//真正拉起react native 的地方</span></div><div class="line">    catalystInstance.getJSModule(AppRegistry.class).runApplication(jsAppModuleName, appParams);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>再来详细说一下最后一句，（大量代码预警）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> &lt;T extends JavaScriptModule&gt; <span class="function">T <span class="title">getJSModule</span><span class="params">(ExecutorToken executorToken, Class&lt;T&gt; jsInterface)</span> </span>&#123;</div><div class="line">    <span class="comment">//进入JSModuleRegistry中</span></div><div class="line">    <span class="keyword">return</span> Assertions.assertNotNull(mJSModuleRegistry)</div><div class="line">        .getJavaScriptModule(<span class="keyword">this</span>, executorToken, jsInterface);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//JavaScriptModuleRegistry.java</span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T extends JavaScriptModule&gt; <span class="function">T <span class="title">getJavaScriptModule</span><span class="params">(</span></span></div><div class="line">    CatalystInstance instance,</div><div class="line">    ExecutorToken executorToken,</div><div class="line">    Class&lt;T&gt; moduleInterface) &#123;</div><div class="line">    HashMap&lt;Class&lt;? extends JavaScriptModule&gt;, JavaScriptModule&gt; instancesForContext =</div><div class="line">        mModuleInstances.get(executorToken);</div><div class="line">    <span class="keyword">if</span> (instancesForContext == <span class="keyword">null</span>) &#123;</div><div class="line">      instancesForContext = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">      <span class="comment">//缓存一下 方便后面再使用</span></div><div class="line">      mModuleInstances.put(executorToken, instancesForContext);</div><div class="line">    &#125;</div><div class="line">    JavaScriptModule <span class="keyword">module</span> = instancesForContext.get(moduleInterface);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">//命中缓存  直接返回</span></div><div class="line">      <span class="keyword">return</span> (T) <span class="keyword">module</span>;</div><div class="line">    &#125;</div><div class="line">    JavaScriptModuleRegistration registration =</div><div class="line">      ...</div><div class="line">      <span class="comment">//很明显 动态代理 重点关注JavaScriptModuleInvocationHandler的invoke方法</span></div><div class="line">    JavaScriptModule interfaceProxy = (JavaScriptModule) Proxy.newProxyInstance(</div><div class="line">        moduleInterface.getClassLoader(),</div><div class="line">        <span class="keyword">new</span> Class[]&#123;moduleInterface&#125;,</div><div class="line">        <span class="keyword">new</span> JavaScriptModuleInvocationHandler(executorToken, instance, registration));</div><div class="line">    instancesForContext.put(moduleInterface, interfaceProxy);</div><div class="line">    <span class="keyword">return</span> (T) interfaceProxy;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">      ....</div><div class="line">      <span class="comment">//又跑到了CatalystInstanceImpl.java中。。。然后又桥接到了CatalystInstanceImpl.cpp中，同样会调用instance的对应方法，直接看吧</span></div><div class="line">      mCatalystInstance.callFunction(</div><div class="line">        executorToken,</div><div class="line">        mModuleRegistration.getName(),</div><div class="line">        method.getName(),</div><div class="line">        jsArgs</div><div class="line">      );</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line"><span class="keyword">void</span> Instance::callJSFunction(ExecutorToken token, std::string&amp;&amp; <span class="keyword">module</span>, std::string&amp;&amp; method,</div><div class="line">                              folly::dynamic&amp;&amp; params) &#123;</div><div class="line">  callback_-&gt;incrementPendingJSCalls();<span class="comment">//这个回调不多说</span></div><div class="line">  <span class="comment">//....接着跟吧</span></div><div class="line">  nativeToJsBridge_-&gt;callFunction(token, std::move(<span class="keyword">module</span>), std::move(method), std::move(params));</div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">//又会进入executor-&gt;callFunction(module, method, arguments);</span></div><div class="line"><span class="keyword">void</span> JSCExecutor::callFunction(<span class="keyword">const</span> std::string&amp; moduleId, <span class="keyword">const</span> std::string&amp; methodId, <span class="keyword">const</span> folly::dynamic&amp; arguments) &#123;</div><div class="line">    ....</div><div class="line">  auto result = [&amp;] &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//被桥接到MessageQueue.js的callFunctionReturnFlushedQueue方法</span></div><div class="line">      <span class="keyword">return</span> m_callFunctionReturnFlushedQueueJS-&gt;callAsFunction(&#123;</div><div class="line">        Value(m_context, String::createExpectingAscii(moduleId)),</div><div class="line">        Value(m_context, String::createExpectingAscii(methodId)),</div><div class="line">        Value::fromDynamic(m_context, std::move(arguments))</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</div><div class="line">      std::throw_with_nested(</div><div class="line">        std::runtime_error(<span class="string">"Error calling function: "</span> + moduleId + <span class="string">":"</span> + methodId));</div><div class="line">    &#125;</div><div class="line">  &#125;();</div><div class="line">  <span class="comment">//顺便还会调用一下native的 这个会在后面再说一下</span></div><div class="line">  callNativeModules(std::move(result));</div><div class="line">&#125;</div><div class="line"></div><div class="line"> callFunctionReturnFlushedQueue(<span class="keyword">module</span>, method, args) &#123;</div><div class="line">        guard(() =&gt; &#123;</div><div class="line">            <span class="comment">//执行js的function</span></div><div class="line">            <span class="keyword">this</span>.__callFunction(<span class="keyword">module</span>, method, args);</div><div class="line">            <span class="keyword">this</span>.__callImmediates();</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//取出积攒在queue中的action返回给上面的，最终在java中执行</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.flushedQueue();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">__callFunction(<span class="keyword">module</span>: string, method: string, args: any) &#123;</div><div class="line">       ...</div><div class="line">       <span class="comment">//根据module名，方法名和参数执行js方法</span></div><div class="line">        <span class="keyword">const</span> result = moduleMethods[method].apply(moduleMethods, args);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//那什么时候把js的module注册到moduleMethods中呢</span></div><div class="line"><span class="comment">//AppRegistry.js</span></div><div class="line">BatchedBridge.registerCallableModule(</div><div class="line">  <span class="string">'AppRegistry'</span>,</div><div class="line">  AppRegistry</div><div class="line">);</div><div class="line"><span class="comment">//BatchedBridge是啥？</span></div><div class="line"><span class="keyword">const</span> BatchedBridge = <span class="keyword">new</span> MessageQueue(</div><div class="line">  () =&gt; global.__fbBatchedBridgeConfig,</div><div class="line">  serializeNativeParams</div><div class="line">);</div><div class="line">registerCallableModule(name, methods) &#123;</div><div class="line">        <span class="keyword">this</span>._callableModules[name] = methods;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里就执行了<code>AppRegistry.js</code>的的<code>runApplication</code>方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> runApplication: <span class="function"><span class="keyword">function</span>(<span class="params">appKey: string, appParameters: any</span>): <span class="title">void</span> </span>&#123;</div><div class="line">  ...</div><div class="line">   runnables[appKey].run(appParameters);</div><div class="line"> &#125;,</div><div class="line"> <span class="comment">//而runnables是在什么时候被添加的？？下面</span></div><div class="line"> </div><div class="line"> registerComponent: <span class="function"><span class="keyword">function</span>(<span class="params">appKey: string, getComponentFunc: ComponentProvider</span>): <span class="title">string</span> </span>&#123;</div><div class="line">   runnables[appKey] = &#123;</div><div class="line">     <span class="attr">run</span>: <span class="function">(<span class="params">appParameters</span>) =&gt;</span></div><div class="line">       renderApplication(getComponentFunc(), appParameters.initialProps, appParameters.rootTag)</div><div class="line">   &#125;;</div><div class="line">   <span class="keyword">return</span> appKey;</div><div class="line"> &#125;,</div><div class="line"><span class="comment">//而registerComponent什么时候被调用的就不用说了吧</span></div></pre></td></tr></table></figure></p>
<p>到此真正执行到了<code>js</code>脚本，开始执行<code>Component</code>的逻辑渲染，最终映射到<code>Native</code>的<code>View</code>上。后面会再详细说渲染的原理。同时会发现在 <code>JSCExecutor</code> 中每次 <code>Java</code> 调用 <code>JS</code> 之后会进行 <code>Java</code> 端的一个回调（从 <code>JS</code> 层的 <code>MessageQueue.js</code> 中获得累积的 <code>JS Call</code>）。</p>
<h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h3><p>上面关于<code>java</code>-&gt;<code>js</code>已经体现的差不多了，实质就是 <code>Java</code> 与 <code>JS</code> 端都准备好一个 <code>Module</code> 映射表，然后当 <code>Java</code> 端调用 <code>JS</code> 代码时 <code>Java</code> 端通过查表动态代理创建一个与 JS 对应的 <code>Module</code> 对象，当调用这个 <code>Module</code> 的方法时 Java 端通过动态代理的 <code>invoke</code> 方法触发 <code>C++</code> 层，层层调用后通过 <code>JSCExecutor</code> 执行 <code>JS</code> 端队列中的映射查表找到 <code>JS</code> 端方法进行调用；<code>js</code>-&gt;<code>java</code>的调用会在渲染原理里面提到。</p>
<p>简单画了个图<br><img src="/images/init.png" alt="init"></p>
<p>btw:看完js-&gt;java原理之后，会发现其实所谓的双向通信，其实基本上(除了那个直接调用的java之外)都是<code>java</code>调用。这也体现了消息机制的两种实现方式，推和拉。推方式就是直接调用对应的方法，也可以理解为经典的观察者模式。而RN通信更像拉这种模式。双边的通信都是靠<code>java</code>端去拉队列中的<code>action</code>。拉比推有一个优势，就是可以解决背压的问题，不必去解决或者协调生产者生产事件的速度，而是根据消费者的速度去消费事件，而且这个消费的过程还是可以优化的，例如去压缩合并一些事件，一次执行。</p>
<h3 id="渲染原理"><a href="#渲染原理" class="headerlink" title="渲染原理"></a>渲染原理</h3><p>现在以一个<code>Image</code>如何渲染到<code>Native</code>为例，说一下简单的流程。<br>当执行<code>js</code>的脚本时候，是不知道<code>nativeModule</code>的注册表的，因为<code>nativeModule</code>的注册表只保存在<code>java</code>和<code>cpp</code>端，并没有直接传递到<code>js</code>端。所有当执行到</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    Image,</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div></pre></td></tr></table></figure>
<p>这时候<code>js</code>并不知道<code>Image</code>是什么，然后看一下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">const ReactNative = &#123;</div><div class="line">    ...</div><div class="line">    get Image() &#123; return require(&apos;Image&apos;); &#125;,</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">...</div><div class="line">module.exports = ReactNative;</div><div class="line"></div><div class="line">//Image.android.js</div><div class="line"></div><div class="line">var NativeModules = require(&apos;NativeModules&apos;);</div><div class="line"></div><div class="line">//NativeModules.js</div><div class="line"></div><div class="line">const NativeModules = &#123;&#125;;</div><div class="line">Object.keys(RemoteModules).forEach((moduleName) =&gt; &#123;</div><div class="line">  Object.defineProperty(NativeModules, moduleName, &#123;</div><div class="line">    configurable: true,</div><div class="line">    enumerable: true,</div><div class="line">    get: () =&gt; &#123;</div><div class="line">      let module = RemoteModules[moduleName];</div><div class="line">      if (module &amp;&amp; typeof module.moduleID === &apos;number&apos; &amp;&amp; global.nativeRequireModuleConfig) &#123;</div><div class="line">      //nativeRequireModuleConfig映射到JSCExecutor.cpp</div><div class="line">        const config = global.nativeRequireModuleConfig(moduleName);</div><div class="line">        module = config &amp;&amp; BatchedBridge.processModuleConfig(config, module.moduleID);</div><div class="line">        RemoteModules[moduleName] = module;</div><div class="line">      &#125;</div><div class="line">      Object.defineProperty(NativeModules, moduleName, &#123;</div><div class="line">        configurable: true,</div><div class="line">        enumerable: true,</div><div class="line">        value: module,</div><div class="line">      &#125;);</div><div class="line">      return module;</div><div class="line">    &#125;,</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = NativeModules;</div><div class="line"></div><div class="line">//cpp</div><div class="line">JSCExecutor::nativeRequireModuleConfig-&gt;JsToNativeBridge::getModuleConfig-&gt;ModuleRegistry::getConfig</div><div class="line"></div><div class="line">folly::dynamic ModuleRegistry::getConfig(const std::string&amp; name) &#123;</div><div class="line"></div><div class="line">...</div><div class="line">  NativeModule* module = modules_[it-&gt;second].get();</div><div class="line">...</div><div class="line">  //最终反射调用JavaModuleWrapper.java的getConstants</div><div class="line">  folly::dynamic constants = module-&gt;getConstants();</div><div class="line">...</div><div class="line">  //最终反射调用JavaModuleWrapper.java的getMethods</div><div class="line">  //返回对应module中所有@ReactMethod注解的方法</div><div class="line">  std::vector&lt;MethodDescriptor&gt; methods = module-&gt;getMethods();</div><div class="line">  </div><div class="line">//modules_在哪赋值？</div><div class="line">//ModuleRegistryHolder.cpp构造函数,这个类上面有提到，回去看看</div><div class="line">//registry_ = std::make_shared&lt;ModuleRegistry&gt;(std::move(modules));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后返回到<code>NativeModules.js</code>中，<code>BatchedBridge.processModuleConfig</code><br>-&gt;<code>_genModule</code>-&gt;<code>_genMethod</code>。进一步处理一下。所以到现在，<code>js</code>获取到了<code>Image</code>这个<code>module</code>中所有方法和属性。</p>
<p>然后当调用<code>Image</code>中相关方法时候，其实就是调用上面<code>_genMethod</code>中的方法，在这个方法中，分<code>promise</code>，<code>sync</code>，<code>其他</code>调用类型，最终都是调用了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">__nativeCall(module, method, params, onFail, onSucc) &#123;</div><div class="line">...</div><div class="line">        this._queue[MODULE_IDS].push(module);</div><div class="line">        this._queue[METHOD_IDS].push(method);</div><div class="line">        this._queue[PARAMS].push(preparedParams);</div><div class="line">...</div><div class="line">//如果5ms内有多个方法调用就先待在队列里防止过高频率，否则调用C++的nativeFlushQueueImmediate方法</div><div class="line"> if (global.nativeFlushQueueImmediate &amp;&amp;</div><div class="line">        now - this._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS) &#123;</div><div class="line">      global.nativeFlushQueueImmediate(this._queue);</div><div class="line">      this._queue = [[], [], [], this._callID];</div><div class="line">      this._lastFlush = now;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面把<code>MODULE_IDS</code>，<code>METHOD_IDS</code>，<code>PARAMS</code>放到<code>queue</code>中，等待<code>java</code>的调用，至于什么时候会触发<code>java</code>的调用和为什么要这么设计，会在下面的事件驱动解释。调用<code>JSCExecutor::flush()</code>。还有就是直接调用<code>cpp</code>的<code>nativeFlushQueueImmediate</code>，最终这两种方式都是调用了<code>callNativeModules</code>，这个上面也说了，不再赘述啦。</p>
<p>下面再说一下<code>Native</code>的<code>view</code>创建过程，这个过程中<code>View</code>的<code>tag</code>起标记<code>View</code>的作用，从<code>java</code>拉起<code>React Native</code>的<code>attachMeasuredRootViewToInstance</code>方法中可以看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">appParams.putDouble(<span class="string">"rootTag"</span>, rootTag);</div><div class="line">appParams.putMap(<span class="string">"initialProps"</span>, initialProps);</div></pre></td></tr></table></figure>
<p>把<code>rootTag</code>通过<code>bridge</code>带到了<code>js</code>端，<code>js</code>执行<code>React</code>逻辑后，要创建一个<code>Native</code>的<code>View</code>,同时也把这个<code>rootTag</code>带到<code>java</code>层，让<code>java</code>层知道，创建完一个<code>View</code>要添加到哪个根布局上。</p>
<p>这个<code>rootTag</code>的生成是有规则的，在<code>UIManagerModule.addMeasuredRootView</code>的时候会生成<code>RootViewTag</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> tag = mNextRootViewTag;<span class="comment">//默认是1</span></div><div class="line">mNextRootViewTag += ROOT_VIEW_TAG_INCREMENT;<span class="comment">//10</span></div></pre></td></tr></table></figure>
<p>也就是默认的<code>rootTag</code>是1，后面每多创建一个+10,也就是类似<code>1，11，21</code>这样都是根布局的<code>tag</code>。</p>
<p>再通过这个<code>rootTag</code>在<code>js</code>的传递简单说一下<code>React.js</code>的创建组件逻辑。从前面可以知道，拉起<code>js</code>后执行<code>AppRegistry.js ::runApplication</code>，进而执行到了<code>renderApplication(getComponentFunc(), appParameters.initialProps, appParameters.rootTag)</code>这个方法。这里可以看到从<code>java</code>传过来的两个参数，其中一个就是<code>rootTag</code>，这里默认就一个根布局，这里的<code>rootTag==1</code>，进而到了<code>renderApplication.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ReactNative.render(</div><div class="line">   &lt;AppContainer&gt;</div><div class="line">     &lt;RootComponent</div><div class="line">       &#123;...initialProps&#125;</div><div class="line">       rootTag=&#123;rootTag&#125;</div><div class="line">     /&gt;</div><div class="line">   &lt;/AppContainer&gt;,</div><div class="line">   rootTag</div><div class="line"> );</div></pre></td></tr></table></figure>
<p>这里的<code>AppContainer</code>也是一个组件，是包裹在根布局的外面，用于<code>debug</code>的红盒等工具布局。再到了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ReactNative.js</span></div><div class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params">element, mountInto, callback</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> ReactNativeMount.renderComponent(element, mountInto, callback);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里面的逻辑快到<code>React</code>的一些处理，这里不多赘述，其实还有很多关于<code>React Native</code>的处理，暂时忽略，分支太多太繁琐。简单说一下<code>React Native</code>组件可以分为两种</p>
<blockquote>
<p>元组件：框架内置的，可以直接使用的组件。例如：View、Image等。它在React Native中用ReactNativeBaseComponent来描述。<br>复合组件：用户封装的组件，一般可以通过React.createClass()来构建，提供render()方法来返回渲染目标。它在React Native中用ReactCompositeComponent来描述。</p>
</blockquote>
<p>具体组合的逻辑基本都在上面连个类里面。下面来到<code>ReactNativeBaseComponent.js</code>的<code>mountComponent</code>，根据上面的提示是可以跟到这里的。只挑简单的看，看这个方法里面的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var tag = ReactNativeTagHandles.allocateTag();<span class="comment">//给每个view生成一个唯一的tag</span></div><div class="line">...</div><div class="line">UIManager.createView(tag, <span class="keyword">this</span>.viewConfig.uiViewClassName, nativeTopRootTag, updatePayload);</div><div class="line"></div><div class="line"><span class="comment">//ReactNativeTagHandles.js</span></div><div class="line">allocateTag: function () &#123;</div><div class="line">    <span class="comment">//排除已经给分配给rootTag的  类似1，11，21</span></div><div class="line">    <span class="comment">//下面的就是简单的自增，初始化是1</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.reactTagIsNativeTopRootID(ReactNativeTagHandles.tagCount)) &#123;</div><div class="line">      ReactNativeTagHandles.tagCount++;</div><div class="line">    &#125;</div><div class="line">    var tag = ReactNativeTagHandles.tagCount;</div><div class="line">    ReactNativeTagHandles.tagCount++;</div><div class="line">    <span class="keyword">return</span> tag;</div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
<p>看名字也知道这里就到了创建<code>View</code>的地方，还有另外两个方法和这个差不多的，用来操作<code>View</code>,分别的<code>updateView</code>，<code>manageChildren</code>，<code>UIManager</code>通过<code>bridge</code>可以映射到<code>java</code>的<code>UIManagerModule.java</code>，可以在duiyiing这个类里面找到对应的用<code>@ReactMethod</code>注解的方法，这个注解是干啥的，看上面有提到。这里只看<code>createView</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ReactMethod</span></div><div class="line"> <span class="comment">//创建view的tag,对应native的组件类名，要加入的根布局tag,创建view需要的参数</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createView</span><span class="params">(<span class="keyword">int</span> tag, String className, <span class="keyword">int</span> rootViewTag, ReadableMap props)</span> </span>&#123;</div><div class="line">   mUIImplementation.createView(tag, className, rootViewTag, props);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在<code>UIImplementation.java</code>中把要创建的<code>view</code>包装成<code>CSSNode</code>，用于后面的在<code>CssLayout</code>中布局。然后会包装成一个<code>CreateViewOperation</code>加入到<code>UIViewOperationQueue.java</code>的<code>ArrayDeque&lt;UIOperation&gt; mNonBatchedOperations</code>这个队列中。最后还是通过<code>GuardedChoreographerFrameCallback</code>这个垂直同步的回调中出队，执行。关于事件驱动还是看下面。还有 <code>updateview</code> <code>setchilderen</code>就不说了，很复杂。</p>
<h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>在说<code>React Native</code>的事件驱动之前，先看一下这几篇<br><a href="http://www.jianshu.com/p/424918260fa9" target="_blank" rel="external">Android图形显示系统（一）</a><br><a href="http://www.jianshu.com/p/154c4fb85641" target="_blank" rel="external">React Native 分析（二）事件驱动</a><br><a href="http://www.jianshu.com/p/c046fcd125d2" target="_blank" rel="external">Android中的SurfaceFlinger和Choreographer</a><br>了解一下垂直同步和在<code>Android</code>上的<code>Choreographer</code>，正因为<code>React Native</code>使用了<code>Choreographer</code>这个类，而这个类是在4.1加入的，所以<code>RN-Android</code>的最低兼容是4.1，而<code>weex</code>是最低兼容到4.0，是在4.0使用了<code>handler</code>延时来模拟垂直同步的效果。当然这也是老版本<code>Android</code>的做法。这也是为啥总是吐槽<code>Android</code>显得很卡，当然在5.0又引入了<code>renderThread</code>就更上了一个台阶，还有<code>Android</code>的属性动画也是靠这个驱动的。</p>
<p>下面简单贴一下<code>Choreographer</code>的注释，看看为啥跨平台的框架都会用到这个类</p>
<blockquote>
<p>However, there are a few cases where you might want to use the functions of thechoreographer directly in your application.  Here are some examples.<br> <li>If your application does its rendering in a different thread, possibly using GL,or does not use the animation framework or view hierarchy at all and you want to ensure that it is appropriately synchronized with the display, then use<br> {@link Choreographer#postFrameCallback}.</li><br> <li>… and that’s about it.</li><br> Each {@link Looper} thread has its own choreographer.  Other threads can post callbacks to run on the choreographer but they will run on the {@link Looper}to which the choreographer belongs.</p>
</blockquote>
<p>再看一下<code>postFrameCallback</code>注释</p>
<blockquote>
<p>Posts a frame callback to run on the next frame.The callback runs once then is automatically removed.</p>
</blockquote>
<p>在<code>React Native</code>的使用主要在<code>EventDispatcher</code>的内部类<code>private class ScheduleDispatchFrameCallback implements Choreographer.FrameCallback</code>和<code>ReactChoreographer</code>与它的内部类<code>private class ReactChoreographerDispatcher implements Choreographer.FrameCallback</code>，还有用于<code>view</code>或者动画的就不说了。</p>
<p>现在举个例子，点击一下<code>view</code>，这个事件是怎么传递的，点击事件肯定发生在<code>java</code>端。在<code>ReactRootView</code>的<code>dispatchJSTouchEvent</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">  EventDispatcher eventDispatcher = reactContext.getNativeModule(UIManagerModule.class)</div><div class="line">      .getEventDispatcher();</div><div class="line">    mJSTouchDispatcher.handleTouchEvent(event, eventDispatcher);</div><div class="line">    </div><div class="line">//JSTouchDispatcher.java</div><div class="line">  public void handleTouchEvent(MotionEvent ev, EventDispatcher eventDispatcher) &#123;</div><div class="line">    //这里面分为down,up move 等事件类别</div><div class="line">    </div><div class="line">     mTargetTag = TouchTargetHelper.findTargetTagAndCoordinatesForTouch(</div><div class="line">        ev.getX(),</div><div class="line">        ev.getY(),</div><div class="line">        mRootViewGroup,</div><div class="line">        mTargetCoordinates,</div><div class="line">        null);</div><div class="line">      eventDispatcher.dispatchEvent(</div><div class="line">        TouchEvent.obtain(</div><div class="line">          mTargetTag,</div><div class="line">          TouchEventType.START,</div><div class="line">          ev,</div><div class="line">          mGestureStartTime,</div><div class="line">          mTargetCoordinates[0],</div><div class="line">          mTargetCoordinates[1],</div><div class="line">          mTouchEventCoalescingKeyHelper));</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终包装成一个<code>TouchEvent</code>调用<code>eventDispatcher.dispatchEvent</code>,这里面主要是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mEventStaging.add(event);<span class="comment">//ArrayList&lt;Event&gt;</span></div></pre></td></tr></table></figure>
<p>把事件添加到一个待发送的列表里面。那什么是去处发送？是在<code>ScheduleDispatchFrameCallback.doFrame</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">  ....</div><div class="line">    moveStagedEventsToDispatchQueue();</div><div class="line">  ...</div><div class="line">     mReactContext.runOnJSQueueThread(mDispatchEventsRunnable);</div><div class="line">  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用<code>moveStagedEventsToDispatchQueue</code>在这个方法里面会对<code>event</code>再做一些处理，例如压缩，合并事件等，然后又把处理完的事件放到<code>Event[] mEventsToDispatch = new Event[16];</code>中。而在<code>DispatchEventsRunnable</code>的<code>run</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> eventIdx = <span class="number">0</span>; eventIdx &lt; mEventsToDispatchSize; eventIdx++) &#123;</div><div class="line">            Event event = mEventsToDispatch[eventIdx];</div><div class="line">            ....</div><div class="line">            event.dispatch(mRCTEventEmitter);</div><div class="line">            event.dispose();</div><div class="line">            ...</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">-&gt;TouchEvent.dispatch-&gt;TouchesHelper.sendTouchEvent-&gt;rctEventEmitter.receiveTouches(</div><div class="line">        type.getJSEventName(),</div><div class="line">        pointers,</div><div class="line">        changedIndices);</div></pre></td></tr></table></figure>
<p>而<code>RCTEventEmitter extends JavaScriptModule</code>这个就是走上面的<code>java-&gt;js</code>的路子，动态代理-&gt;<code>cpp</code>-&gt;<code>flush()</code>-&gt;….</p>
<p>简单点就是<code>getJSModule</code>后对js的方法调用都会触发上面<code>MessageQueue.js</code>的出队</p>
<p><img src="/images/eventloop.png" alt="eventloop"></p>
<h2 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h2><p>这里简单说说<code>React Native</code>的<code>js引擎</code>选择，都是<code>webkit</code>的<code>JSC</code>,在<code>iOS</code>上是内置的，在<code>Android</code>上则是引入了一个完整的<code>JSC</code>，这也是为什么<code>Android</code>的<code>RN</code>会大这么多的很重要的原因，至于为什么要引入一个完整的<code>JSC</code>而不是使用内置的<code>js</code>引擎，<code>Android 4.4</code>之前的<code>android</code>系统浏览器内核是<code>WebKit</code>，<code>Android4.4</code>系统浏览器切换到了<code>Chromium</code>(内核是<code>Webkit</code>的分支<code>Blink</code>)。在<code>Android</code>平台已经启用V8作为JS引擎，<code>Android 4.0</code>以后只用到了<code>JavaScriptCore</code>中的WTF（Web Template Library）部分代码。</p>
<p>至于为啥不都使用<code>V8</code>,这个都是<code>iOS</code>的锅，看看<code>chrome</code>在<code>iOS</code>上就是个<code>WebView</code>套个壳。。。</p>
<p>还有其他的跨平台框架，例如<code>weex</code>,在<code>Android</code>上使用的是<code>V8</code>。现在网上也有对<code>RN</code>在<code>Android</code>上移植的<code>V8</code>版本。<br>[onesubone/react-native-android-v8][6]<br><a href="http://tsinstudio.github.io/media/React-Native-Meets-V8/" target="_blank" rel="external">React Native Android V8接入</a><br>这个是基于0.46的版本，还是可以跑起来的，但是<code>RN</code>的速度瓶颈貌似并不在<code>js引擎</code>。。</p>
<p>还有一点要吐槽就是每个<code>jsbundle</code>都包含了框架代码和业务代码，导致文件的有效利用率很低，看看隔壁的<code>weex</code>就做的很好，框架<code>js</code>代码直接包含在<code>sdk</code>中，只下发业务代码，这才是正常的做法。在<code>RN</code>这只能自己<code>hook</code>了。还有就是每个<code>RN</code>页面都是要重新初始化Bridge,但是这些bridge其实都是基本一样的，只需要把不同的<code>jsbundle</code>扔给<code>JSC</code>就好了，我测试了一下大概会快20%，但是因为缓存，也会造成一些内存泄露的问题(业务代码和具体页面过于绑定)。但是有时候甚至比重新初始化还慢，不知道为啥。。</p>
<p>最后再贴一下简单画的思维导图吧<br><a href="https://www.processon.com/view/link/599c14b8e4b0f2c6342a4f04" target="_blank" rel="external">思维导图在线地址</a><br><img src="/images/React Native启动.png" alt="React Native启动"></p>
<p>参考：</p>
<p><a href="https://github.com/facebook/react-native" target="_blank" rel="external">facebook/react-native</a><br><a href="http://blog.csdn.net/yanbober/article/details/53157456" target="_blank" rel="external"> React Native Android 源码框架浅析（主流程及 Java 与 JS 双边通信）</a><br><a href="https://github.com/guoxiaoxing/react-native" target="_blank" rel="external">ReactNative源码篇</a><br><a href="http://www.jianshu.com/u/640de10b6744" target="_blank" rel="external">吟游雪人</a></p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps:"></a>ps:</h2><p>因为本人能力实在有限，上面很多都是连蒙带猜，算是个笔记性质的流水账，有用就看看，没用就算了,欢迎指出错误。</p>
<h3 id="pps"><a href="#pps" class="headerlink" title="pps"></a>pps</h3><p>这篇本该在两星期之前完成的工作，一直拖到了现在。(<del>一是因为懒</del>)，二是因为不知道该怎么更好的表述出来，因为一直贴代码体验实在是不好。（<del>虽然现在还是这样的，但是源码分析的不贴代码怎么写</del>）。但是感觉再不写点出来，过段时间又忘了，索性写出来算了，也不管效果了。。。凑合看吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;(源码版本：0.34，新版本(0.48)基本流程是不变的，建议跟着源码看看，哪个版本的倒影响不大)&lt;br&gt;这篇简单刨析一下&lt;code&gt;React Native&lt;/code&gt;是怎么在&lt;code&gt;Android&lt;/code&gt;上跑起来的，会从下面几个方面说说。
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://yoursite.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>Fragment启动生命周期</title>
    <link href="http://yoursite.com/2017/09/08/Fragment%E5%90%AF%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2017/09/08/Fragment启动生命周期/</id>
    <published>2017-09-08T15:03:32.000Z</published>
    <updated>2017-09-10T03:40:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>源码版本：26.0.0-beta1</strong></p>
<p>Fragment 的生命周期是依赖Activity的，假设在Activity的onCreate中有如下代码，<a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SearchFragment searchFragment = <span class="keyword">new</span> SearchFragment();</div><div class="line">       getSupportFragmentManager().beginTransaction()</div><div class="line">               .replace(R.id.container, searchFragment)</div><div class="line">               .commitAllowingStateLoss();</div></pre></td></tr></table></figure></p>
<p>探究一下Fragment的生命周期是如何依附的。</p>
<p>思维导图</p>
<p><img src="/images/Fragment启动生命周期.png" alt="Fragment启动生命周期"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;源码版本：26.0.0-beta1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fragment 的生命周期是依赖Activity的，假设在Activity的onCreate中有如下代码，
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>LifecycleComponents问答</title>
    <link href="http://yoursite.com/2017/09/08/LifecycleComponents%E9%97%AE%E7%AD%94/"/>
    <id>http://yoursite.com/2017/09/08/LifecycleComponents问答/</id>
    <published>2017-09-08T15:00:06.000Z</published>
    <updated>2017-09-08T15:00:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么不直接使用ActivityLifecycleCallbacks而是使用一个non-UI-fragment-ReportFragment？"><a href="#为什么不直接使用ActivityLifecycleCallbacks而是使用一个non-UI-fragment-ReportFragment？" class="headerlink" title="为什么不直接使用ActivityLifecycleCallbacks而是使用一个non-UI fragment ReportFragment？"></a>为什么不直接使用<code>ActivityLifecycleCallbacks</code>而是使用一个<code>non-UI fragment ReportFragment</code>？<a id="more"></a></h4><p>因为在”创建”生命周期方法中(<code>onCreate</code>,<code>onStart</code>)，<code>ActivityLifecycleCallbacks</code>中方法调用是在<code>Activity</code>的生命周期方法之前。在”销毁”生命周期方法中(<code>onStop</code>,<code>onDestroy</code>),<code>ActivityLifecycleCallbacks</code>中方法调用是在<code>Activity</code>的生命周期方法之后。正常去订阅这里的生命周期，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_CREATE)</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ON_CREATE</span><span class="params">()</span> </span>&#123;</div><div class="line">                Log.e(MyObserver, <span class="string">"ON_CREATE"</span>);</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>更多的希望是在<code>Activity</code>的<code>onCreate</code>执行完成之后，而订阅<code>Lifecycle.Event.ON_DESTROY</code>则更希望在<code>Activity</code>的<code>onDestroy</code>之前。所有在<code>ActivityLifecycleCallbacks</code>中直接分发生命周期是不合适的。还要注意一下，在注册<code>ReportFragment</code>时候使用的是<code>manager.executePendingTransactions();</code>而不是常见的<code>commit</code>，是为了马上执行，更准确的去分发生命周期。通过这种方式，最终的生命周期类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建时</span></div><div class="line">ActivityLifecycleCallbacks.onActivityCreated-&gt;Activity.onCreate-&gt;ReportFragment.onActivityCreated-&gt;LifecycleObserver.ON_CREATE</div><div class="line"><span class="comment">//销毁时</span></div><div class="line">ReportFragment.onDestroy-&gt;LifecycleObserver.ON_DESTROY-&gt;Activity.onDestroy-&gt;ActivityLifecycleCallbacks.onActivityDestroyed</div></pre></td></tr></table></figure>
<p>上面是在<code>LifecycleActivity</code>中使用<code>getLifecycle().addObserver</code>的生命周期分发走向。<br>同理，在<code>LifecycleFragment</code>中<code>getLifecycle().addObserver</code>时， <code>FragmentCallback</code>和<code>DestructionReportFragment</code>也是完成类似上面<code>ActivityLifecycleCallbacks</code>和<code>ReportFragment</code>的工作。总结就是将<code>LifecycleObserver</code>的生命周期进一步限制在跟踪的<code>LifecycleRegistryOwner</code>生命周期范围之内。</p>
<h4 id="ProcessLifecycleOwner的作用？"><a href="#ProcessLifecycleOwner的作用？" class="headerlink" title="ProcessLifecycleOwner的作用？"></a><code>ProcessLifecycleOwner</code>的作用？</h4><p>在<code>LifecycleRuntimeTrojanProvider</code>中有两个类进行了初始化，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LifecycleDispatcher.init(getContext());</div><div class="line">ProcessLifecycleOwner.init(getContext());</div></pre></td></tr></table></figure>
<p>第一个是为每个组件进行生命周期分发，例如<code>Activity</code>,<code>Fragment</code>。<code>ProcessLifecycleOwner</code>则是为整个app进程的生命周期进行分发，例如使用<code>ProcessLifecycleOwner.get().getLifecycle().addObserver();</code>就可以监控整个进程的生命周期。注意一点，在销毁时，最多只会分发到<code>ON_STOP</code>，而没有<code>ON_DESTROY</code>事件。</p>
<p>更多分析可以看这篇 <a href="http://chaosleong.github.io/2017/05/27/How-Lifecycle-aware-Components-actually-works/" target="_blank" rel="external">Lifecycle-aware Components 源码分析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;为什么不直接使用ActivityLifecycleCallbacks而是使用一个non-UI-fragment-ReportFragment？&quot;&gt;&lt;a href=&quot;#为什么不直接使用ActivityLifecycleCallbacks而是使用一个non-UI-fragment-ReportFragment？&quot; class=&quot;headerlink&quot; title=&quot;为什么不直接使用ActivityLifecycleCallbacks而是使用一个non-UI fragment ReportFragment？&quot;&gt;&lt;/a&gt;为什么不直接使用&lt;code&gt;ActivityLifecycleCallbacks&lt;/code&gt;而是使用一个&lt;code&gt;non-UI fragment ReportFragment&lt;/code&gt;？
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Fragment Can not perform this action after onSaveInstanceState</title>
    <link href="http://yoursite.com/2017/09/08/onSaveInstanceState/"/>
    <id>http://yoursite.com/2017/09/08/onSaveInstanceState/</id>
    <published>2017-09-08T14:59:09.000Z</published>
    <updated>2017-09-10T13:16:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了这个异常，记录一下解决办法。<a id="more"></a></p>
<p>首先看一下这个异常是从哪里抛出来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//FragmentManager</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueAction</span><span class="params">(OpGenerator action, <span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!allowStateLoss) &#123;</div><div class="line">           checkStateLoss();</div><div class="line">       &#125;</div><div class="line">       ....</div><div class="line">   &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkStateLoss</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (mStateSaved) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                   <span class="string">"Can not perform this action after onSaveInstanceState"</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (mNoTransactionsBecause != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                   <span class="string">"Can not perform this action inside of "</span> + mNoTransactionsBecause);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>也就是在对fragment进行commit的时候，如果这时候<code>mStateSaved</code>那就会抛出这个异常，而<code>mStateSaved</code>是在<code>saveAllState</code>也就是<code>onSaveInstanceState</code>和<code>dispatchStop</code>也就是<code>Activity::onStop</code>中。也就是说如果在这两个生命周期方法之中或者之后对<code>Fragment</code>进行<code>Commit</code>就会出现这个异常。特别是<code>DialogFragment</code>，一般的<code>Fragment</code>还可以使用<code>commitAllowingStateLoss</code>来进行”丑陋的”避免，而<code>DialogFragment</code>的默认<code>show</code>方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(FragmentManager manager, String tag)</span> </span>&#123;</div><div class="line">        mDismissed = <span class="keyword">false</span>;</div><div class="line">        mShownByMe = <span class="keyword">true</span>;</div><div class="line">        FragmentTransaction ft = manager.beginTransaction();</div><div class="line">        ft.add(<span class="keyword">this</span>, tag);</div><div class="line">        ft.commit();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>根本不给机会。</p>
<p>上面说到抛出这个异常的原因，引申出什么情况下容易出现这种情况，就是异步回调的时候进行<code>commit</code>。因为这个时候你无法知道当前的状态，碰巧这个时候应用进入后台，执行了<code>onStop</code>或者被杀死<code>onSaveInstanceState</code>,就挂了。使用<code>Fragment</code>有好处，就是比<code>Activity</code>轻，跳转不用进行IPC。但是真的不怎么好用，到处的坑。再说这里，例如使用<code>MVP</code>，在<code>onDestroyView</code>对<code>View</code>进行清空，(这个是在<code>Activity</code>的<code>onDestroy</code>调用)，也就是在这之前对<code>View</code>操作都是安全的，但是<code>Fragment</code>在<code>onStop</code>之后就不能再进行<code>commit</code>了。使用<code>View==null</code>判断根本不行，真的防不胜防🤣🤣🤣。</p>
<p>解决办法：<br><a href="http://www.jianshu.com/p/d9143a92ad94" target="_blank" rel="external">Fragment全解析系列（一）：那些年踩过的坑</a>。至于为什么前面说<code>commitAllowingStateLoss</code>是个”丑陋”的解决办法，这里有更详细的说明<a href="http://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html" target="_blank" rel="external">Fragment Transactions &amp; Activity State Loss</a>，早在13年就提及这个问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到了这个异常，记录一下解决办法。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2线程切换流程</title>
    <link href="http://yoursite.com/2017/09/08/RxJava2%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/09/08/RxJava2线程切换流程/</id>
    <published>2017-09-08T14:57:26.000Z</published>
    <updated>2017-09-08T14:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下面代码为例：<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"HELLO WORLD"</span>)</div><div class="line">          .map(<span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(@NonNull String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                  s = s.toLowerCase();</div><div class="line">                  <span class="keyword">return</span> s;</div><div class="line">              &#125;</div><div class="line">          &#125;)</div><div class="line">          .subscribeOn(Schedulers.computation())</div><div class="line">          .map(<span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</div><div class="line"></div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                  s = s + <span class="string">"map"</span>;</div><div class="line">                  <span class="keyword">return</span> s;</div><div class="line">              &#125;</div><div class="line">          &#125;)</div><div class="line">          .observeOn(Schedulers.newThread())</div><div class="line">          .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(@NonNull String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                  System.out.println(s);</div><div class="line">              &#125;</div><div class="line">          &#125;);</div></pre></td></tr></table></figure>
<p>简单分析一下代码执行流程</p>
<ol>
<li>从上到下，建立上下依赖关系，初始化线程</li>
<li>从<code>.subscribe</code>为调用起点，自下向上开始准备调用，这个过程<code>subscribeOn</code>起作用，<code>observeOn</code>不起切换线程作用。</li>
<li>从上到下执行，类似<code>map</code>中的代码，这时候<code>observeOn</code>起切换线程作用。</li>
</ol>
<p>调用流程简化如下：<br><img src="http://static.zybuluo.com/70kg/hipkw6etxfxnmpr0mzu2mujc/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-05%20%E4%B8%8B%E5%8D%884.18.45.png" alt="屏幕快照 2017-09-05 下午4.18.45.png-163.6kB"></p>
<p> 涉及的相关类：<br> <img src="http://static.zybuluo.com/70kg/br63lmpohxuoccg3fxgoy0zz/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-05%20%E4%B8%8B%E5%8D%884.26.43.png" alt="屏幕快照 2017-09-05 下午4.26.43.png-100kB"></p>
<p> 这也是为什么<code>subscribeOn</code>只有第一次起作用，<code>observeOn</code>每次都起作用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下面代码为例：
    
    </summary>
    
    
      <category term="RxJava" scheme="http://yoursite.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Handler</title>
    <link href="http://yoursite.com/2017/07/07/Handler/"/>
    <id>http://yoursite.com/2017/07/07/Handler/</id>
    <published>2017-07-07T00:28:33.000Z</published>
    <updated>2017-07-08T06:59:13.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="sendMessage的message保存在哪？"><a href="#sendMessage的message保存在哪？" class="headerlink" title="sendMessage的message保存在哪？"></a><code>sendMessage</code>的<code>message</code>保存在哪？</h4><p>保存在<code>MessageQueue</code>的<code>Message mMessages</code>成员变量中，通过<code>message</code>中的<code>next</code>维护一个单向链表。<code>message</code>本身一直在java层，和<code>native</code>的message没有直接操作关系。<code>looper</code>分发的消息都是通过<code>messagequeue.mMessages</code>间接获取的。当<code>sendMessage</code>时，进入<code>messagequeue</code>的<code>enqueueMessage</code>方法，<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Message p = mMessages;</div><div class="line">           <span class="keyword">boolean</span> needWake;</div><div class="line">           <span class="comment">//代表MessageQueue没有消息，或者msg的触发时间是队列中最早的</span></div><div class="line">           <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">               <span class="comment">// New head, wake up the event queue if blocked.</span></div><div class="line">               msg.next = p;</div><div class="line">               mMessages = msg;</div><div class="line">               <span class="comment">//mBlocked在空消息为true</span></div><div class="line">               needWake = mBlocked;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake up the event queue unless there is a barrier at the head of the queue and the message is the earliest asynchronous message in the queue.</span></div><div class="line">               needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">               Message prev;</div><div class="line">               <span class="comment">//遍历mMessages  找到合适位置插入msg</span></div><div class="line">               <span class="keyword">for</span> (;;) &#123;</div><div class="line">                   prev = p;</div><div class="line">                   p = p.next;</div><div class="line">                   <span class="comment">//当p==null 说明是链表的最后一个的next 要将msg插入到链表的最后，当when &lt; p.when说明后面还有时间没到的在排队，插入到这些的前面</span></div><div class="line">                   <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                       needWake = <span class="keyword">false</span>;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">               prev.next = msg;</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<p>接受消息在<code>messagequeue.next()</code>中，<code>nativePollOnce(ptr, nextPollTimeoutMillis);</code>方法是陷入到<code>native</code>层，一般<code>nextPollTimeoutMillis</code>都为0，说明要马上处理<code>message</code>，就会执行下面的语句。当没有消息时，<code>nextPollTimeoutMillis</code>为-1，表示无限阻塞，直到mEpollFd所监控的文件描述符发生了要监控的IO事件后或者监控时间超时后，线程就从epoll_wait返回了，也就会执行下面的操作，说明有新的message可以处理了。也就是说没消息的阻塞是在<code>nativePollOnce</code>实现的（具体是在native looper ::pollInner），但是这个阻塞不是忙等待，而是闲等待，让出CPU时间。</p>
<blockquote>
<p>A. Android应用程序的消息处理机制由消息循环、消息发送和消息处理三个部分组成的。</p>
<p>B. Android应用程序的主线程在进入消息循环过程前，会在内部创建一个Linux管道（Pipe），这个管道的作用是使得Android应用程序主线程在消息队列为空时可以进入空闲等待状态，并且使得当应用程序的消息队列有消息需要处理时唤醒应用程序的主线程。</p>
<p>C. Android应用程序的主线程进入空闲等待状态的方式实际上就是在管道的读端等待管道中有新的内容可读，具体来说就是是通过Linux系统的Epoll机制中的epoll_wait函数进行的。</p>
<p>D. 当往Android应用程序的消息队列中加入新的消息时，会同时往管道中的写端写入内容，通过这种方式就可以唤醒正在等待消息到来的应用程序主线程。</p>
<p>E. 当应用程序主线程在进入空闲等待前，会认为当前线程处理空闲状态，于是就会调用那些已经注册了的IdleHandler接口，使得应用程序有机会在空闲的时候处理一些事情。<br>—-&gt;<a href="http://blog.csdn.net/luoshengyang/article/details/6817933" target="_blank" rel="external">Android应用程序消息处理机制（Looper、Handler）分析</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;sendMessage的message保存在哪？&quot;&gt;&lt;a href=&quot;#sendMessage的message保存在哪？&quot; class=&quot;headerlink&quot; title=&quot;sendMessage的message保存在哪？&quot;&gt;&lt;/a&gt;&lt;code&gt;sendMessage&lt;/code&gt;的&lt;code&gt;message&lt;/code&gt;保存在哪？&lt;/h4&gt;&lt;p&gt;保存在&lt;code&gt;MessageQueue&lt;/code&gt;的&lt;code&gt;Message mMessages&lt;/code&gt;成员变量中，通过&lt;code&gt;message&lt;/code&gt;中的&lt;code&gt;next&lt;/code&gt;维护一个单向链表。&lt;code&gt;message&lt;/code&gt;本身一直在java层，和&lt;code&gt;native&lt;/code&gt;的message没有直接操作关系。&lt;code&gt;looper&lt;/code&gt;分发的消息都是通过&lt;code&gt;messagequeue.mMessages&lt;/code&gt;间接获取的。当&lt;code&gt;sendMessage&lt;/code&gt;时，进入&lt;code&gt;messagequeue&lt;/code&gt;的&lt;code&gt;enqueueMessage&lt;/code&gt;方法，
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>部署阿里云</title>
    <link href="http://yoursite.com/2017/06/28/%E9%83%A8%E7%BD%B2%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    <id>http://yoursite.com/2017/06/28/部署阿里云/</id>
    <published>2017-06-28T12:54:10.000Z</published>
    <updated>2017-06-28T12:54:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近搞了台阿里云的服务器，倒腾了半天，现在写点折腾的坑吧。<a id="more"></a></p>
<p>我之前是没点部署运维的经验，绝大部分时间都是在不停的Google。。目前上面部署了一个<code>node.js</code>写的<code>RESTful</code> 服务，当然还有配套的<code>mongoDb</code>等,一个<code>python</code>写的微信机器人，用的是图灵机器人的接口，还有几个脚本，都可以通过微信指令去调用，也是挺方便的。还有就是把博客从<code>GitHub</code>迁移到阿里云上面去了，速度提升杠杠的，因为迁移到了国内，备案是肯定的，好在阿里云有个代办备案的系统，除了等的时间长了点也没什么毛病(<del>除了备案本身</del>)。还有就是上面部署了个<code>git</code>服务器，这样也算是有个私人仓库了。这里面最折腾人的算是<code>nginx</code>了，因为之前对反向代理没点认识，一点不知道这玩意是干嘛的，只是按照教程一步步来，实在是累。后面慢慢理解点了，其实坑都是自己挖的，也只能自己去填了。下面随便说几个还记得的几点吧。</p>
<p>阿里云默认是root用户，权限太大，太危险。首先要去新建用户，以后都在这个用户下面操作。</p>
<p>刚登录的时候，是<code>Ubuntu</code>裸机，先使用<code>sudo apt-get update</code>更新一下，不然后面很多软件都装不上。</p>
<p>阿里云默认是不开放80和443端口的，所以你再怎么折腾也是连不上的，要先去控制台的安全组里面添加端口，后来我索性把全部端口都开放了，以后也懒得再来修改添加。</p>
<p>使用Mac通过<code>ssh</code>连到服务器之后，有时候会遇到中文乱码，<a href="https://blog.fazero.me/2015/09/04/Mac-iTerm2--chinese/" target="_blank" rel="external">https://blog.fazero.me/2015/09/04/Mac-iTerm2--chinese/</a> 看这个解决吧，后面我装了zsh之后，好像也不再需要上面的步骤了。</p>
<p>遇到<code>nginx</code>老是启动不了，也停止不了，搜了半天也解决不了，还是直接尝试<code>pkill nginx &amp;&amp; service nginx restart</code>吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近搞了台阿里云的服务器，倒腾了半天，现在写点折腾的坑吧。
    
    </summary>
    
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP简单理解</title>
    <link href="http://yoursite.com/2017/06/26/TCP-IP%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/06/26/TCP-IP简单理解/</id>
    <published>2017-06-26T14:38:46.000Z</published>
    <updated>2017-06-26T14:40:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近把《计算机网络》大致翻了一遍，主要是看了网络层往上的部分，包括网络层，运输层，应用层的一些协议和实现，还有一些网络安全，流媒体服务，无线网络等的介绍。对于应用开发，再往下的数据链路层和物理层也没太大的意义去研究。<a id="more"></a></p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层向上提供无连接的，尽最大努力交付的数据报服务。<br>网络层负责端到端的。<br>网络层主要是围绕IP来进行的，与IP协议配套使用的包括ARP:地址解析协议,ICMP：网际控制报文协议，IGMP:网际组管理协议。<br>IP地址的编码方式主要有：分类的IP地址，子网划分(CIDR)，构成超网。<br>网络层通过ARP协议将IP转换为数据链路层使用的物理mac地址。<br>IP数据报的首部包括源地址，目的地址，总长度，生存时间等信息。<br>路由器选择协议主要有RIP和OSPF,前者是基于距离向量的选择协议，间隔具体时间和相邻路由器交换路由信息，信息包括当前路由表(最短距离)和下一跳地址。OSPF是分布式链路状态协议，只有链路状态改变才使用泛洪法发送与所有相邻路由器的链路状态信息，信息包括本路由器于哪些路由器相邻和连接的”代价”。</p>
<h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>运输层负责端口到端口的通信。<br>熟悉的TCP/UDP是运输层的重要协议。<br><strong>UDP</strong></p>
<ul>
<li>无连接</li>
<li>尽最大努力交付，不保证可靠交付</li>
<li>面向报文:应用层交给UDP多大的报文，保留边界发送，如果过长，IP层负责分片。</li>
<li>没有拥塞控制</li>
<li>支持一对多，多对一，一对一的交互通信</li>
<li>部首小(源端口，目的端口，长度，检验和)</li>
</ul>
<p><strong>TCP</strong></p>
<ul>
<li>面向连接(建立连接-通信-释放连接)</li>
<li>只能是点对点</li>
<li>提供可靠交付(无差错，不丢失，不重复，按序到达)</li>
<li>提供全双工通信</li>
<li>面向字节流</li>
</ul>
<p>为保证可靠传输，使用以下协议:</p>
<ul>
<li>停止等待协议(效率低)</li>
<li>连续ARQ和滑动窗口</li>
</ul>
<p>部首：</p>
<ul>
<li>源端口和目的端口</li>
<li>序号:面向字节流，每一个字节都按顺序编号</li>
<li>确认号：期望收到对方下一个报文段的第一个字节的序号</li>
<li>数据偏移：也就是首部长度</li>
<li>紧急URG：尽快发送</li>
<li>确认ACK</li>
<li>推送PSH</li>
<li>复位RST</li>
<li>同步SYN</li>
<li>终止FIN</li>
<li>窗口：接收方允许对方发送的数据量</li>
<li>校验和</li>
<li>紧急指针</li>
<li>选项<br>以字节为单位的滑动窗口，三个指针描述<br>拥塞控制：慢开始，拥塞避免，快重传。<br>TCP建立连接的三次握手，最后一次确认是为了防止已失效的连接建立请求。<br>释放连接的四次握手</li>
</ul>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>面向应用进程<br>DNS域名解析：递归查询，迭代查询<br>FTP文件传输协议<br>TELNET远程终端协议<br>HTTP协议<br>SMTP简单邮件传送协议<br>等</p>
<h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><p>被动攻击和主动攻击</p>
<p>对称密钥<br>DES，IDEA<br>公钥密码<br>数字签名：报文鉴别，报文完整性，不可否认<br>SSL/TLS连接建立</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近把《计算机网络》大致翻了一遍，主要是看了网络层往上的部分，包括网络层，运输层，应用层的一些协议和实现，还有一些网络安全，流媒体服务，无线网络等的介绍。对于应用开发，再往下的数据链路层和物理层也没太大的意义去研究。
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Tinker补丁构建走读</title>
    <link href="http://yoursite.com/2017/05/23/Tinker%E8%A1%A5%E4%B8%81%E6%9E%84%E5%BB%BA%E8%B5%B0%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/05/23/Tinker补丁构建走读/</id>
    <published>2017-05-23T00:18:44.000Z</published>
    <updated>2017-05-23T00:19:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tinker简单问答"><a href="#Tinker简单问答" class="headerlink" title="Tinker简单问答"></a>Tinker简单问答</h2><h4 id="为什么要替换-Application"><a href="#为什么要替换-Application" class="headerlink" title="为什么要替换 Application"></a>为什么要替换 Application</h4><p>看上一篇和 Instant Run 的对比，可能考虑不全</p>
<ul>
<li>确保 Multidex 开启</li>
<li>保证应用 Application 类可修复</li>
<li>7.0 混合编译的影响，要去替换掉原始 PathClassLoader 的加载功能<a id="more"></a></li>
</ul>
<h4 id="为什么还要在-dexElements-前面插入而不是直接替换？"><a href="#为什么还要在-dexElements-前面插入而不是直接替换？" class="headerlink" title="为什么还要在 dexElements 前面插入而不是直接替换？"></a>为什么还要在 dexElements 前面插入而不是直接替换？</h4><p>因为 Tinker 是全量合成 dex ，比如在补丁前dex顺序是这样的：oldDex1 -&gt; oldDex2 -&gt; oldDex3..，那么假如修改了dex1中的文件，那么补丁顺序是这样的newDex1 -&gt; oldDex1 -&gt; oldDex2… 那为什么不直接使用newDex1去替换调oldDex呢？我觉得:</p>
<ul>
<li>运行期去替换调正在使用的dex是有风险的(也是我瞎猜)</li>
<li>考虑到版本回退和以后的增量升级，在前面插入确实比替换更加方便安全</li>
</ul>
<h2 id="Tinker补丁构建走读"><a href="#Tinker补丁构建走读" class="headerlink" title="Tinker补丁构建走读"></a>Tinker补丁构建走读</h2><p>Tinker的补丁加载网上资料很多了，读起来也没太大难度，这里就不多说了。关于补丁构建的整个过程倒是不多，这里简单走读一下。</p>
<h4 id="TinkerPatchSchemaTask"><a href="#TinkerPatchSchemaTask" class="headerlink" title="TinkerPatchSchemaTask"></a>TinkerPatchSchemaTask</h4><p>关于代码的变动  dex的patch  资源的patch</p>
<p>这个 Task 主要是用于 oldApk和 newApk 的差分，生成patch，包括dex,res,so的差分，主要起作用的类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ManifestDecoder manifestDecoder;<span class="comment">//检测是否增加了四大组件  关于dexMode的检测提示</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UniqueDexDiffDecoder dexPatchDecoder;<span class="comment">//dex 的patch</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BsDiffDecoder soPatchDecoder;<span class="comment">//so 的patch</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResDiffDecoder resPatchDecoder;<span class="comment">//资源的patch</span></div></pre></td></tr></table></figure>
<p>这个 Task 也是最关键的，可以从 <code>ApkDecoder</code> 这个类开始，首先会先把两个apk解压到<code>build/outputs/tinkerPatch/{variant}/apkName</code>目录下，在打patch 过程中<code>tinkerPatch</code> 目录下会生成很多过程文件，类似最终的patch apk,用于查看资源合成结果的 <code>resources_out.zip</code>，还有一下log.txt。关键的patch从</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Files.walkFileTree(mNewApkDir.toPath(), <span class="keyword">new</span> ApkFilesVisitor(config, mNewApkDir.toPath(), mOldApkDir.toPath(), dexPatchDecoder, soPatchDecoder, resPatchDecoder));</div></pre></td></tr></table></figure>
<p>这里开始，遍历newApk解压后的目录，根据<code>Pattern</code>去匹配使用上面四个中哪个<code>Decoder</code>去处理这两个新旧文件。</p>
<ul>
<li>dex查分</li>
</ul>
<p>从<code>UniqueDexDiffDecoder dexPatchDecoder;</code>处理dex开始，这里假如我们oldApk只有一个classes.dex,来到<code>DexDiffDecoder.patch</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不是为了对比 是为了检查dex的一些规则</span></div><div class="line">           excludedClassModifiedChecker.checkIfExcludedClassWasModifiedInNewDex(oldFile, newFile);</div></pre></td></tr></table></figure>
<p>这里去检查一下第一个dex中的一些限制，例如tinker的一些loader类一定要在第一个dex中等限制。<br>如果新增了一个dex<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//new add file 在new apk中多了一个dex 直接复制</span></div><div class="line">        <span class="keyword">if</span> (oldFile == <span class="keyword">null</span> || !oldFile.exists() || oldFile.length() == <span class="number">0</span>) &#123;</div><div class="line">            hasDexChanged = <span class="keyword">true</span>;</div><div class="line">            copyNewDexAndLogToDexMeta(newFile, newMd5, dexDiffOut);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>然后正常的修改了dex</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Before starting real diff works, we collect added class descriptor</div><div class="line">     * and deleted class descriptor for further analysing in &#123;<span class="doctag">@code</span> checkCrossDexMovingClasses&#125;.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectAddedOrDeletedClasses</span><span class="params">(File oldFile, File newFile)</span></span></div></pre></td></tr></table></figure>
<p>把对应的dex保存在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// collect current old dex file and corresponding new dex file for further processing.</span></div><div class="line">       oldAndNewDexFilePairList.add(<span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(oldFile, newFile));</div></pre></td></tr></table></figure></p>
<p>然后走到<code>dexPatchDecoder.onAllPatchesEnd();//开始生成 保存patch文件</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (config.mIsProtectedApp) &#123;<span class="comment">//仅仅在加固的时候使用 只将变化的类合成补丁</span></div><div class="line">            generateChangedClassesDexFile();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            generatePatchInfoFile();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>然后来到这个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">            DexPatchGenerator dexPatchGen = <span class="keyword">new</span> DexPatchGenerator(oldDexFile, newDexFile);</div><div class="line">            dexPatchGen.setAdditionalRemovingClassPatterns(config.mDexLoaderPattern);<span class="comment">//查分时候排除dex.loader闭包中的类</span></div><div class="line"></div><div class="line">            logWriter.writeLineToInfoFile(</div><div class="line">                    String.format(</div><div class="line">                            <span class="string">"Start diff between [%s] as old and [%s] as new:"</span>,</div><div class="line">                            getRelativeStringBy(oldDexFile, config.mTempUnzipOldDir),</div><div class="line">                            getRelativeStringBy(newDexFile, config.mTempUnzipNewDir)</div><div class="line">                    )</div><div class="line">            );</div><div class="line"></div><div class="line">            dexPatchGen.executeAndSaveTo(dexDiffOut);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerPatchException(e);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>这里就是具体的dexDiff算法了，我也看不懂，就当个黑盒，反正会生产处一个查分dex保存，然后后面还会在合成一个全量dex用来查看，保存一下log日志之类的，大致的dex查分就完成了。</p>
<ul>
<li>res 查分<br>回到遍历newApk目录的地方，还是根据<code>Pattern</code>去匹配资源文件，在这个方法中进行查分</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//处理修改的资源</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dealWithModeFile</span><span class="params">(String name, String newMd5, File oldFile, File newFile, File outputFile)</span></span></div></pre></td></tr></table></figure>
<p>还是使用了BSD进行差分，输出log，修改的文件复制到tinker_result的目录下。然后到<code>onAllPatchesEnd</code>，和dex一样，还是会生成全量的<code>resources_out.zip</code>去查看合成结果，还有log输出。</p>
<ul>
<li>so查分<br>这个也是使用了BSD查分，没太多好说的。</li>
</ul>
<h4 id="TinkerManifestTask"><a href="#TinkerManifestTask" class="headerlink" title="TinkerManifestTask"></a>TinkerManifestTask</h4><p>自动添加/修改tinker_id，运行时检查补丁版本</p>
<h4 id="TinkerResourceIdTask"><a href="#TinkerResourceIdTask" class="headerlink" title="TinkerResourceIdTask"></a>TinkerResourceIdTask</h4><p>R.txt 的保存 ids.xml public.xml的处理，用于处理资源改变时ID变动问题，将基础包的R.txt处理成ids.xml，public.xml，保存到<code>intermediates/res/merged/{variant}/values/</code>下，用于打包时候的资源ID分配。保证资源ID的不变动。</p>
<h4 id="TinkerProguardConfigTask"><a href="#TinkerProguardConfigTask" class="headerlink" title="TinkerProguardConfigTask"></a>TinkerProguardConfigTask</h4><p>混淆的处理，主要的作用是将tinker中默认的混淆信息和基准包的mapping信息加入混淆列表。</p>
<h4 id="TinkerMultidexConfigTask"><a href="#TinkerMultidexConfigTask" class="headerlink" title="TinkerMultidexConfigTask"></a>TinkerMultidexConfigTask</h4><p>主要将dex.loader中配置的class也keep进main dex.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Tinker简单问答&quot;&gt;&lt;a href=&quot;#Tinker简单问答&quot; class=&quot;headerlink&quot; title=&quot;Tinker简单问答&quot;&gt;&lt;/a&gt;Tinker简单问答&lt;/h2&gt;&lt;h4 id=&quot;为什么要替换-Application&quot;&gt;&lt;a href=&quot;#为什么要替换-Application&quot; class=&quot;headerlink&quot; title=&quot;为什么要替换 Application&quot;&gt;&lt;/a&gt;为什么要替换 Application&lt;/h4&gt;&lt;p&gt;看上一篇和 Instant Run 的对比，可能考虑不全&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保 Multidex 开启&lt;/li&gt;
&lt;li&gt;保证应用 Application 类可修复&lt;/li&gt;
&lt;li&gt;7.0 混合编译的影响，要去替换掉原始 PathClassLoader 的加载功能
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>由View.post引发的问题</title>
    <link href="http://yoursite.com/2017/05/14/%E7%94%B1View-post%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/05/14/由View-post引发的问题/</id>
    <published>2017-05-14T12:31:42.000Z</published>
    <updated>2017-05-14T12:36:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到<a href="http://www.jianshu.com/p/571e9b4f4b89" target="_blank" rel="external">记一次错误的使用View.post(Runnable)</a>这篇的时候，自己去实验了一下，当时是在 Activity 的 onDestory 中做的，以为到了 onDestory View 肯定是 Detach 的，结果并不是这样的。。后来发现在 API 24的时候，关于 View.Post 这部分的代码有重写，所有就捋了捋关于这部分的东西，简单记录一下。<a id="more"></a></p>
<h4 id="View-Detach"><a href="#View-Detach" class="headerlink" title="View Detach"></a>View Detach</h4><p>View 什么时候才会 Detach ？当 View 中 mAttachInfo 这个变量置空的时候，就 Detach 了，是在 dispatchDetachedFromWindow 这个方法中置空的，这方法是在 ViewRootImpl.dispatchDetachedFromWindow() 中调用的，ViewRootImpl 可以看做是在 View 和 WindowManager 中间一个类 ，WMS 通过 IWindow 进行 ipc 通信控制通知客户端的 WindowManager， WindowManager 还要稍微使用 WindowManagerGlobal 中转处理一下，然后再去调用 ViewRootImpl 中的一些方法，而 ViewRootImpl 是持有 DecorView ，DecorView 中又有 WindowCallBack ，其实就是 Activity ,因为 Activity 实现了 WindowCallBack。这样再去调用 Activity 中关于 Window 相关的回调。回到问题，什么时候Detach？ 当然还是在 Activity 销毁的时候，简单说下情形，A 启动 B ,在 B 中调用 finish。B finish-&gt; B onPause-&gt;A onResume-&gt;B onStop-&gt;B onDestroy-&gt;B onDetachedFromWindow 。大致的流程是ActivityManagerNative通知AMS,AMS通过IApplicationThread调用ActivityThread.H去sendMessage，然后再去ActivityThread某个类似performPauseActivity，然后Instrumentation，然后就是activity生命周期。在最后调用handleDestroyActivity中，先调用ondestory 然后调用wm的removeViewImmediate，[ActivityThread.handleDestroyActivity() –&gt;<br>WindowManager.removeViewImmediate() –&gt;<br>WindowManagerGlobal.removeViewLocked()方法 —&gt;<br>ViewRootImpl.die() –&gt; doDie() –&gt;<br>ViewRootImpl.dispatchDetachedFromWindow()],这个时候view.attachInfo 置空，所以当回调 Activity 的 onDestory 的时候，还没去调用 dispatchDetachedFromWindow ，当然还没 Detach 。关于 View 什么时候 Attached ，是在 onResume 之后，具体就不说了，和上面差不多。</p>
<h4 id="View-post"><a href="#View-post" class="headerlink" title="View.post"></a>View.post</h4><p>说一下现象，当在 Attached 的时候，使用 View.post 就是走 handler 那一套，使用的 handelr 是 ViewRootImpl 中的 ViewRootHandler ，looper 就是 mainLooper ，这个没什么好分析的，这个时候怎么post都是有回调的。当在 Detach 的时候，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</div><div class="line">        <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> attachInfo.mHandler.post(action);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></div><div class="line">        <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></div><div class="line">        getRunQueue().post(action);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>走下面的 <code>getRunQueue().post(action);</code> 这个在24 以前 看开头那篇分析，是用 ThreadLocal 来进行的线程隔离，在 24 的时候，getRunQueue 变成了view的私有变量 mRunQueue:HandlerActionQueue ,当post 到这个里面去的时候，基本上是不会在调用了，因为它的 <code>mRunQueue.executeActions(info.mHandler);</code>是在 <code>dispatchAttachedToWindow</code> 中调用的。。一个activity生命周期只会调一次，也基本上用不到什么自行车了。。</p>
<h4 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h4><p>看下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.onDestroy();</div><div class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">              button.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                  <span class="meta">@Override</span></div><div class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                      Log.e(<span class="string">"ssssss"</span>, <span class="string">"onDestroy"</span>);</div><div class="line">                  &#125;</div><div class="line">              &#125;);</div><div class="line">          &#125;</div><div class="line">      &#125;).start();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里面的Log会不会调用？？说实话，看缘分。。。不信自己去试试</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到&lt;a href=&quot;http://www.jianshu.com/p/571e9b4f4b89&quot;&gt;记一次错误的使用View.post(Runnable)&lt;/a&gt;这篇的时候，自己去实验了一下，当时是在 Activity 的 onDestory 中做的，以为到了 onDestory View 肯定是 Detach 的，结果并不是这样的。。后来发现在 API 24的时候，关于 View.Post 这部分的代码有重写，所有就捋了捋关于这部分的东西，简单记录一下。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Instant-Run与Tinker中Application替换</title>
    <link href="http://yoursite.com/2017/05/08/Instant-Run%E4%B8%8ETinker%E4%B8%ADApplication%E6%9B%BF%E6%8D%A2/"/>
    <id>http://yoursite.com/2017/05/08/Instant-Run与Tinker中Application替换/</id>
    <published>2017-05-08T14:58:02.000Z</published>
    <updated>2017-05-16T01:02:21.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>为什么要替换application</li>
</ul>
<p>因为5.0以下开始只会去加载第一个dex,如果appliaction不在第一个dex,则无法启动。如果把自己的appliaction放在第一个dex中，而自己的application没有使用multidex,则只会去加载原始加载生成的dex,也是会报错。所以办法就是去代理掉原始的application，将app启动的application设置为这个代理的application，在这个代理的application中可以确保使用multidex功能。</p>
<p>还有因为补丁是在appliaction中加载，这样会导致无法对appliaction的修复，还有因为 Android N 的混合编译的影响 ，Tinker 使用了类似 Instant-run 中 IncrementalClassLoader （具体实现过程还是有差距），新建一个classLoader，去 “替换”掉原始的 PathClassLoader 去加载所有dex。这些都需要在appliaction中进行修改。<br><a id="more"></a></p>
<ul>
<li>替换操作的差异</li>
</ul>
<p>Instant run 是在attachBaseContext的时候再去反射创建原始的application，然后再反射替换掉Framework中已经初始化的application(这个时候还是代理的application),还原回去我们原始的application。接下来就是正常的流程，在app中去get application也不会有问题。</p>
<p>Tinker使用的是静态代理，使用代理方案代码会更复杂一些，因为要去模拟出一个applicationLike的接口，在tinker中，我们真正的application只需要实现这个接口，并不需要去继承Android中的application，因为会在代理的application中反射调用我们的application生命周期方法。也就是说tinker中只有一个真正的application。</p>
<ul>
<li>优缺点</li>
</ul>
<p>在instant run中application的替换的透明的，两个application都是真正的Android application。好处就是透明，坏处也是使用了反射替换运行期的application，兼容性不如静态代理好，类似tinker中反射插入dex就分了好多个版本实习，这个会更复杂。tinker更加稳定。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;为什么要替换application&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为5.0以下开始只会去加载第一个dex,如果appliaction不在第一个dex,则无法启动。如果把自己的appliaction放在第一个dex中，而自己的application没有使用multidex,则只会去加载原始加载生成的dex,也是会报错。所以办法就是去代理掉原始的application，将app启动的application设置为这个代理的application，在这个代理的application中可以确保使用multidex功能。&lt;/p&gt;
&lt;p&gt;还有因为补丁是在appliaction中加载，这样会导致无法对appliaction的修复，还有因为 Android N 的混合编译的影响 ，Tinker 使用了类似 Instant-run 中 IncrementalClassLoader （具体实现过程还是有差距），新建一个classLoader，去 “替换”掉原始的 PathClassLoader 去加载所有dex。这些都需要在appliaction中进行修改。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Express + React 搭建简易web微博</title>
    <link href="http://yoursite.com/2017/03/02/%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93web%E5%BE%AE%E5%8D%9A/"/>
    <id>http://yoursite.com/2017/03/02/搭建简易web微博/</id>
    <published>2017-03-02T00:47:52.000Z</published>
    <updated>2017-07-28T13:33:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近用 React 写了个简单的web微博，因为js的跨域问题，无法直接请求web Weibo的API，所以只能使用Node来中转一下，这样玩法也更丰富，随便处理数据。目前的功能只包括看微博和查看大图。<a id="more"></a></p>
<p>微博的自动登录使用的是<a href="https://github.com/ruansongsong/nodejs-weibo-login" target="_blank" rel="external">nodejs-weibo-login</a>,但是这个库是为了pc端微博设计的，最初还是可以兼容web版的微博登录，后来估计是新浪修改了规则，不再兼容了，所以目前只能手动传 cookie 了。<br>基本没用第三方的react类库，就是个很简单的东西。</p>
<p><a href="https://coding.net/u/70kg/p/express/git" target="_blank" rel="external">服务端代码</a><br><a href="https://coding.net/u/70kg/p/React/git" target="_blank" rel="external">Weibo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近用 React 写了个简单的web微博，因为js的跨域问题，无法直接请求web Weibo的API，所以只能使用Node来中转一下，这样玩法也更丰富，随便处理数据。目前的功能只包括看微博和查看大图。
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》笔记</title>
    <link href="http://yoursite.com/2016/12/31/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/12/31/《深入理解Java虚拟机》笔记/</id>
    <published>2016-12-31T08:54:38.000Z</published>
    <updated>2017-07-28T13:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自动内存管理机制"><a href="#自动内存管理机制" class="headerlink" title="自动内存管理机制"></a>自动内存管理机制</h2><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul>
<li>通过改变这个计数器的指决定执行的下一条指令</li>
<li>线程私有 每条线程独立</li>
<li>不会 oom <a id="more"></a><h4 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h4>存放基本类型和引用和   returnAddress类型(指向了一条字节码指令的地址）<br>描述 Java 方法执行的内存模型<h4 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h4></li>
<li>存放对象实例</li>
<li>线程共享，内存最大</li>
<li>GC 的主要区域</li>
<li>基于分代回收，大致分为新生代和老年代<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4></li>
<li>线程共享</li>
<li>类信息，常量，静态变量<h2 id="虚拟机对象"><a href="#虚拟机对象" class="headerlink" title="虚拟机对象"></a>虚拟机对象</h2><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4>new指令的参数是否能在常量池中定位到一个类的符号引用-&gt;是否已经加载，解析初始化-&gt;分配内存(指针碰撞，空闲列表)-&gt;初始化为零值-&gt;为对象进行必要设置-&gt;&lt; init &gt; 方法。(ps：new 关键字其实为new和init两个方法)</li>
</ul>
<h3 id="对象的内存分布"><a href="#对象的内存分布" class="headerlink" title="对象的内存分布"></a>对象的内存分布</h3><ul>
<li>对象头<br>1.分用于存储对象自身的运行时数据,e.g.哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时 间戳等<br>2.类型指针,对象指向它的类元数据的指针,虚拟机通过这个指 针来确定这个对象是哪个类的实例.</li>
<li>实例数据</li>
<li>对其填充</li>
</ul>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>使用栈上的引用去操作堆上的实例。</p>
<ol>
<li>句柄<br>在堆中有一块内存区域作为句柄池，栈中的引用存储的是对象的句柄地址，句柄中包括对象的实例数据(实例池)和类型数据(方法区)。<br>好处：GC 时只会改变句柄中实例指针，不会影响栈中的指向。<ol>
<li>直接指针<br>栈中的引用直接指向对象地址。<br>好处：速度快，省一次指针定向</li>
</ol>
</li>
</ol>
<p>ps: <code>String.intern</code>的问题 <a href="http://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="external">点这里</a></p>
<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p>先标记需要回收的对象，然后统一回收。缺点是效率不高，会产生内存碎片问题。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>1：1分割内存，只用一半，回收时把存活的复制到另一半，清除原来一半。<br>实际使用在新生代，适合回收频率高的。朝生夕死。每次清理都有大量对象死亡。<code>HotSpot</code>默认为8:1:1,浪费10%的内存空间，使用8和1，当回收时候，复制到另一个1中。空间不够时候，需要依赖老年代。</p>
<h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h3><p>先标记，把存活的移动到一端，清除。适合老年代</p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>通过使用一组<code>OopMap</code>的数据结构知道哪些地方存放对象引用。在类加载完成时，<code>HotSpot</code>就把对象内什么偏移量上是什么类型的数据计算出来，在<code>JIT</code>编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，这样GC扫描时就可以直接得知。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>上面特定的位置是安全点，只有在安全点处暂停。主要使用主动式中断让所有线程都跑到安全点再停顿。不直接对线程操作，设置一个标志，各个线程主动去轮训，发现中断标志true就自己中断挂起。</p>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全区域用来解决在程序没有CPU时间，例如线程sleep或者block的时候进入GC。安全区域是指在一段代码之后，引用关系不会发生变化，在这个区域任何地方GC都是安全的。当程序执行到安全区域，首先标识进入，然后GC可以随时进行。当程序要离开安全区域时，先去检查GC是否完成，是-&gt;继续执行，否-&gt;等待完成。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>最基本最久远的收集器，单线程,STW。没有线程切换的开销，简单。复制算法</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>Serial收集器的多线程版本。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>和ParNew收集器类似，关注吞吐量</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial收集器的的老年代版本。标记-整理</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Scavenge收集器的老年代版本，标记-整理。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）<br>1，3步骤STW。1只标记GC roots能直接关联对象，很快。并发标记阶段就是进行GC RootsTracing 的过程,而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变 动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远 比并发标记的时间短。整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作<img src="http://7xjlmz.com1.z0.glb.clouddn.com/Java%E8%99%9A%E6%8B%9F%E6%9C%BAcms.png" alt=""><br>优点：<br>并发收集，低停顿<br>缺点：<br>对CPU资源敏感，默认回收线程(cpu数量+3)/4<br>cms无法处理”浮动垃圾”（当并发收集同时产生的垃圾）<br>标记-清除算法内存碎片问题</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>特点：</p>
<ul>
<li>分代收集</li>
<li>并行与并发</li>
<li>空间整合</li>
<li>可预测的停顿<br>将整个Java堆划分 为多个大小相等的独立区域(Region)<br>大致过程：<ol>
<li>初始标记(Initial Marking)</li>
<li>并发标记(Concurrent Marking)</li>
<li>最终标记(Final Marking)</li>
<li>筛选回收(Live Data Counting and Evacuation)<br>4-&gt;筛选回收阶段首先对各个Region的回收价值和成本进行排序, 根据用户所期望的GC停顿时间来制定回收计划</li>
</ol>
</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下,对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时,虚拟 机将发起一次Minor GC</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对 象年龄(Age)计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活,并且能被 Survivor容纳的话,将被移动到Survivor空间中,并且对象年龄设为1。对象在Survivor区中 每“熬过”一次Minor GC,年龄就增加1岁,当它的年龄增加到一定程度(默认为15岁),就 将会被晋升到老年代中。</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>如果在Survivor空间中相同年龄所有对象大小的总 和大于Survivor空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代,无须等 到MaxTenuringThreshold中要求的年龄。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC之前,虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有 对象总空间,如果这个条件成立,那么Minor GC可以确保是安全的。如果不成立,则虚拟机 会查看HandlePromotionFailure设置值是否允许担保失败。如果允许,那么会继续检查老年代 最大可用的连续空间是否大于历次晋升到老年代对象的平均大小,如果大于,将尝试着进行 一次Minor GC,尽管这次Minor GC是有风险的;如果小于,或者HandlePromotionFailure设置 不允许冒险,那这时也要改为进行一次Full GC。</p>
<h1 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h1><p>略</p>
<h1 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h1><p>略</p>
<h1 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h1><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>Class文件格式采用一种类似C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表<br>无符号数属于基本类型，有u1,u2,u4,u8表示几个字节，可以用来描述数字，索引引用，数据值或者按照UTF-8编码的字符串<br>表是由多个无符号数或者其他表作为数据结构的复合数据结构，表习惯以_info结尾。<br>整个Class本质上就是一个表<br>Class文件格式：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt=""></p>
<h3 id="魔数-u4"><a href="#魔数-u4" class="headerlink" title="魔数 u4"></a>魔数 u4</h3><p><code>0xCAFFBABE</code></p>
<h3 id="次版本号-u2"><a href="#次版本号-u2" class="headerlink" title="次版本号 u2"></a>次版本号 u2</h3><h3 id="主版本号-u2"><a href="#主版本号-u2" class="headerlink" title="主版本号 u2"></a>主版本号 u2</h3><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>u2的常量池大小 index从1开始，第0项空出<br>常量池中主要存放两大类常亮：字面量和符号引用<br>字面量类似Java的常量<br>符号引用包括：</p>
<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ol>
<p>常量池中每一项都是一个表(都对应一个Class)。一共14种表，表开始的第一位u1代表当前这个常量属于哪种常量类型<br>具体如下：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%B1%BB%E5%9E%8B.jpg" alt=""></p>
<h3 id="访问标志-u2"><a href="#访问标志-u2" class="headerlink" title="访问标志 u2"></a>访问标志 u2</h3><p>用于标识一些类或者接口成次的访问信息<br>具体如下：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.jpg" alt=""></p>
<h3 id="类索引、父类索引与接口索引集合-u2-u2-List"><a href="#类索引、父类索引与接口索引集合-u2-u2-List" class="headerlink" title="类索引、父类索引与接口索引集合 u2,u2,List"></a>类索引、父类索引与接口索引集合 u2,u2,List<u2></u2></h3><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>用于描述接口或类中的变量<br>字段包括类级变量(static)和实例级变量 不包括方法内部的局部变量</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>对方法的描述</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>用于描述某些场景专用信息。下面的必备的9个属性:<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E5%B1%9E%E6%80%A7%E8%A1%A8.png" alt=""></p>
<h4 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h4><p>简单理解就是方法体,具体的结构如下：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class_code%E5%B1%9E%E6%80%A7.jpg" alt=""></p>
<p>Code属性是Class文件中最重要的属性，如果把Java程序中信息分为代码（Code）和元数据(类，字段，方法定有以及其他信息)两部分。Code属性属于描述代码，所有的其他数据项目都用于描述元数据</p>
<h2 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h2><h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><p>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输<br>Tload -&gt; 将一个局部变量加载到操作栈<br>Tstore -&gt; 将一个数值从操作数栈存储到局部变量表<br>Tipush -&gt; 将一个变量加载到操作数栈<br>wide -&gt; 扩充局部变量表的访问索引指令</p>
<h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><p>用于对两个操作数栈上的值进行某种特定的运算，并把结果重新存入到操作栈顶。<br>算术运算大致分为对整形数据进行运算的指令和对浮点数进行运算的指令</p>
<p>加法指令 ：Tadd<br>减法指令: Tsub<br>乘法指令： Tmul<br>除法指令：Tdiv<br>求余指令：Trem<br>取反指令：Tneg<br>位移指令：Tshl,Tshr,Tushr<br>按位或指令：Tor<br>按位与指令：Tand<br>按位异或指令：Txor<br>局部变量自增指令：Tinc<br>比较指令：Tcmpg,Rcmpl</p>
<h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><p>用于将两种不同的数值类型进行相互转换，一般用于实现用户代码中的显式类型转换或者用于处理字节码指令集中数据类型相关指令无法一一对应的问题<br>i2b,i2c…</p>
<h3 id="对象创建和访问指令"><a href="#对象创建和访问指令" class="headerlink" title="对象创建和访问指令"></a>对象创建和访问指令</h3><p>Java虚拟机对类实例和数组的创建于操作用了不同的字节码指令。<br>创建类实例 -&gt; new<br>创建数组 -&gt; newarray,anewarray,multianewarray<br>访问类字段和实例字段 -&gt; getfield,putfield,getstatic,putstatic<br>把一个数组元素加载到操作数栈 -&gt; Taload<br>将一个操作数栈的值存储到数组元素中 -&gt;Tastore<br>取数组长度 -&gt; arraylength<br>检查类实例类型 -&gt; instanceof,checkcast</p>
<h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><p>直接操作操作数栈的指令<br>将操作数栈的栈顶一个或两个元素出栈 -&gt;pop,pop2<br>复制栈顶两个数值并将双份复制值从新压入栈顶 -&gt; dup2,dup2_x1,dup2_x2<br>栈顶两个数值交换 -&gt; swap</p>
<h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><p>条件分支，复合条件分支，无条件分支<br>各种类型的比较最终都会转化成int类型的比较操作，所以Java虚拟机提供的int类型的条件分支指令是最丰富和强大的</p>
<h3 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h3><p>invokevirtual -&gt;调用实例方法，最常见的<br>invokeinterface -&gt;调用接口方法，会在运行时搜索一个实现了这个接口方法的对象，找到合适的方法进行调用<br>invokespecial -&gt; 调用一些需要特殊处理的实例方法，包括实例初始化方法，私有方法和父类方法<br>invokestatic -&gt; 调用类方法<br>invokedynamic -&gt; 在运行时动态解析出调用点限定符所引用的方法，并执行该方法？？？？</p>
<p>方法调用指令与数据类型无关，返回指令是根据返回值的类型区分的.Treturn</p>
<h3 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h3><p>显示抛出异常(throw)都是由athrow指令实现。<br>处理异常不是由字节码指令实现的，采用异常表完成。</p>
<h3 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h3><p>支持方法级同步和方法内部一段指令序列的同步，是使用管程(Monitor)支持。</p>
<p>方法级的同步是隐式的,即无须通过字节码指令来控制,它实现在方法调用和返回操作 之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个 方法是否声明为同步方法。当方法调用时,调用指令将会检查方法的ACC_SYNCHRONIZED 访问标志是否被设置,如果设置了,执行线程就要求先成功持有管程,然后才能执行方法, 最后当方法完成(无论是正常完成还是非正常完成)时释放管程。在方法执行期间,执行线 程持有了管程,其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出 了异常,并且在方法内部无法处理此异常,那么这个同步方法所持有的管程将在异常抛到同 步方法之外时自动释放。</p>
<p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的,Java虚拟机的 指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义,正确实现 synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自动内存管理机制&quot;&gt;&lt;a href=&quot;#自动内存管理机制&quot; class=&quot;headerlink&quot; title=&quot;自动内存管理机制&quot;&gt;&lt;/a&gt;自动内存管理机制&lt;/h2&gt;&lt;h4 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;通过改变这个计数器的指决定执行的下一条指令&lt;/li&gt;
&lt;li&gt;线程私有 每条线程独立&lt;/li&gt;
&lt;li&gt;不会 oom
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从零撸一个Redux</title>
    <link href="http://yoursite.com/2016/12/25/Redux-2/"/>
    <id>http://yoursite.com/2016/12/25/Redux-2/</id>
    <published>2016-12-25T13:53:53.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="扯一扯"><a href="#扯一扯" class="headerlink" title="扯一扯"></a>扯一扯</h4><p>这段时间在看 <code>Redux</code> 的东西，稍微梳理一下整个框架的流程。其实整个 <code>Redux</code> 的代码很少，现在我也不能理解很多它的思想，反正先撸出个简单的 <code>Redux</code> 吧。目标是照着它的流程写一个最简单的，也要支持异步 <code>Action</code>。也算是个笔记性的东西。<a id="more"></a></p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a><code>Action</code></h4><p>这里把 <code>Action</code> 放到了 <code>Store</code> 中，这样在 <code>Component</code> 中使用的时候只要导入 <code>store</code> 就可以，不用导入很多的 <code>Action</code>, <del>就是懒</del>。当然也可以使用 <code>React-Redux</code> 之类的进行绑定，但是这个库主要不是干这个的。。这个后面会提到一些。因为 <code>Actions</code> 都是提前定义的，所有写在了一个 <code>StoreConfig</code> 中，在创建 <code>Store</code> 的时候就可以把 <code>actions</code> 注入到 <code>Store</code> 中了。当然你也可以不这么做。先贴一下完整的代码吧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> createStore <span class="keyword">from</span> <span class="string">'./createStore'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> store = createStore(&#123;</div><div class="line">    <span class="comment">//把所有的action都放在了store中</span></div><div class="line">    actions: &#123;</div><div class="line">        <span class="comment">//同步的action</span></div><div class="line">        <span class="string">'printText'</span>: createRequest(<span class="function">(<span class="params">text</span>)=&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> &#123;<span class="attr">text</span>: text + <span class="string">"我想修改"</span>&#125;;</div><div class="line">        &#125;),</div><div class="line">        <span class="comment">//异步的action，async await可以看上一篇</span></div><div class="line">        <span class="string">'testAsync'</span>: createRequest(<span class="keyword">async</span>()=&gt; &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">await</span> Longtime();</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">initState</span>: &#123;&#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">//测试的代码不用说吧</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Longtime</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            resolve(&#123;<span class="attr">text</span>: <span class="string">'success'</span>&#125;);</div><div class="line">            <span class="comment">// reject('error');</span></div><div class="line">        &#125;, <span class="number">2000</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//这个是个actionCreater 之前有写过在项目中的使用 这里也不多说</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRequest</span>(<span class="params">actionCreator</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> finalActionCreator = <span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span></div><div class="line">        ? actionCreator</div><div class="line">        : <span class="function">(<span class="params">t</span>) =&gt;</span> t;</div><div class="line">    <span class="keyword">const</span> actionHandler = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">const</span> action = &#123;</div><div class="line">            <span class="attr">type</span>: actionHandler.toString()</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//真正的action都放在payload中，同步则是数据，异步是Promise。</span></div><div class="line">        <span class="keyword">const</span> payload = finalActionCreator(...args);</div><div class="line">        <span class="keyword">if</span> (!(payload === <span class="literal">null</span> || payload === <span class="literal">undefined</span>)) &#123;</div><div class="line">            action.payload = payload;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (action.payload <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</div><div class="line">            action.error = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> action;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> actionHandler;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</div></pre></td></tr></table></figure>
<h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a><code>Reducer</code></h4><p>这里的 <code>Reducer</code> 只创建了一个，就是直接把成功的数据更新到 <code>Store</code> 中，也没什么好看的，关于异步的 <code>Promise</code> 会在结果返回之后再去通知 <code>Reducer</code>去更新 <code>Store</code>，当然这就不是这个 <code>Reducer</code> 的工作了。代码很简单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">acceptSuccessActionReducer</span>(<span class="params">state, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!action.error &amp;&amp; action.payload) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, action.payload);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a><code>Store</code></h4><p>我觉得 <code>Redux</code> 的最重要的东西就是 <code>Store</code> 了。所有的 <code>Action</code> 都要经过 <code>Store</code> 分发，当结果返回之后也要通知 <code>Store</code> 去更新，<code>Component</code> 的数据也是从 <code>Store</code> 中获取。先贴一下 <code>CreateStore</code> 代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;handleActions&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</div><div class="line"><span class="keyword">import</span> &#123;applyMiddleware&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> promiseMiddleware <span class="keyword">from</span> <span class="string">'redux-promise'</span>;</div><div class="line"><span class="keyword">import</span> acceptSuccessActionReducer <span class="keyword">from</span> <span class="string">'../reducers/SuccessReducer'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> actions = config.actions;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> initState = config.initState;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> reducersDict = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="built_in">Object</span>.keys(actions).forEach(<span class="function"><span class="params">key</span>=&gt;</span> &#123;</div><div class="line">        <span class="keyword">var</span> action = actions[key];</div><div class="line">        action.toString = <span class="function"><span class="params">()</span>=&gt;</span>key;</div><div class="line">        reducersDict[key] = acceptSuccessActionReducer;<span class="comment">//将action与reducer绑定</span></div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//这个reducers应该是个类似arrays.reduce的function   果然--&gt; @see 'reduce-reducers'   what's means??</span></div><div class="line">    <span class="keyword">var</span> reducers = handleActions(reducersDict, initState);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> store = generateStore(reducers, applyMiddleware(promiseMiddleware));</div><div class="line"></div><div class="line">    store.actions = &#123;&#125;;</div><div class="line">    <span class="built_in">Object</span>.assign(store.actions, actions);</div><div class="line"></div><div class="line">    store.subscribe(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'这是修改后的===&gt;'</span>, store.getState());</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> store;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</div><div class="line">        enhancer = preloadedState;</div><div class="line">        preloadedState = <span class="literal">undefined</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> enhancer(generateStore)(reducer, preloadedState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> currentState = preloadedState;</div><div class="line">    <span class="keyword">let</span> currentReducer = reducer;</div><div class="line">    <span class="keyword">let</span> listeners = [];</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        getState() &#123;</div><div class="line">            <span class="keyword">return</span> currentState;<span class="comment">//返回当前 state</span></div><div class="line">        &#125;,</div><div class="line">        subscribe(listener) &#123;</div><div class="line">            <span class="keyword">let</span> index = listeners.length;</div><div class="line">            listeners.push(listener); <span class="comment">//缓存 listener</span></div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> listeners.splice(index, <span class="number">1</span>); <span class="comment">//返回删除该 listener 的函数</span></div><div class="line">        &#125;,</div><div class="line">        dispatch(action) &#123;</div><div class="line">            currentState = currentReducer(currentState, action);</div><div class="line">            listeners.slice().forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener());</div><div class="line">            <span class="keyword">return</span> action;<span class="comment">//返回 action 对象</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里偷懒用了一些库，但是仅仅是很简单的几个方法，例如 <code>import {handleActions} from &#39;redux-actions&#39;;</code> 这个里面的代码我没看的懂，但是知道返回一个类似<code>arrays.reduce</code>的<code>function</code>，这个可以理解返回一个 <code>rootReducer</code> ，也就是会迭代累加调用所有的 <code>Reducer</code> 。<code>generateStore</code> 也是抄了一部分的源码，大致的原理应该差不多。从这个也会发现一个问题，每当 <code>dispatch</code> 一个 <code>action</code> 都会去遍历所有的 <code>listeners</code> ，我们一般都是在 <code>listener</code> 中去做更新 <code>UI</code> 的工作，这样就会造成很多次无用的刷新。这个就可以使用上面提到过的 <code>React-Redux</code> 的 <code>mapStateToProps</code> 在某个 <code>Component</code> 中只去接受自己感兴趣的 <code>State</code> 的更新，然后再使用类似 <code>Immutable</code> 的库进去比较就可以很好的控制更新。当然这里不会多去说这个，因为我也没具体去理解过，以后可以多去学习学习。<br>这里还偷懒直接用了 <code>redux</code> 中的 <code>applyMiddleware</code>。我觉得这是我学习 <code>Redux</code> 中看到的最精彩的代码，贴一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, middlewares = <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) &#123;</div><div class="line">    middlewares[_key] = <span class="built_in">arguments</span>[_key];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);</div><div class="line">      <span class="keyword">var</span> _dispatch = store.dispatch;</div><div class="line">      <span class="keyword">var</span> chain = [];</div><div class="line"></div><div class="line">      <span class="keyword">var</span> middlewareAPI = &#123;</div><div class="line">        <span class="attr">getState</span>: store.getState,</div><div class="line">        <span class="attr">dispatch</span>: <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> _dispatch(action);</div><div class="line">        &#125;</div><div class="line">      &#125;;</div><div class="line">      chain = middlewares.map(<span class="function"><span class="keyword">function</span> (<span class="params">middleware</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> middleware(middlewareAPI);</div><div class="line">      &#125;);</div><div class="line">      _dispatch = _compose2[<span class="string">'default'</span>].apply(<span class="literal">undefined</span>, chain)(store.dispatch);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> _extends(&#123;&#125;, store, &#123;</div><div class="line">        <span class="attr">dispatch</span>: _dispatch</div><div class="line">      &#125;);</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过和上面的 <code>generateStore</code> 一起看，特别是 <code>applyMiddleware</code> 返回的匿名<code>Function</code>，真是精彩的代码。再去试想一下如果使用 <code>Java</code> 这样的强类型语言去实现得是多麻烦的事情。还有就是 <code>Function</code> 的一等公民地位的体现。真的值得多去读一读，很赞。不得不去佩服写这段代码的人。甚至有点自举的感觉。在还没创建 <code>store</code> 的时候就可以去使用 <code>Store.dispatch</code>，(这句话是有问题的，意会即可)。还有就是 <code>applyMiddleware</code> 的整个过程其实没有完全的弄明白，这里也不班门弄斧，等明白了会再来更新的。</p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>最后就是使用了，没什么好说的<code>store.dispatch(store.actions.testAsync());</code>就可以了。使用手动的 <code>subscribe</code> 或者 <code>React-redux</code> 的 <code>connect</code> 都能实现 <code>UI</code> 的更新，当然更推荐后者。后面还会去学习一个 <code>React-Redux</code> 这个东西，毕竟又使用 <code>React</code> 又使用 <code>Redux</code> 肯定也少不了这个东西。<br>先说到这吧，有什么想说的再来补一补。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;扯一扯&quot;&gt;&lt;a href=&quot;#扯一扯&quot; class=&quot;headerlink&quot; title=&quot;扯一扯&quot;&gt;&lt;/a&gt;扯一扯&lt;/h4&gt;&lt;p&gt;这段时间在看 &lt;code&gt;Redux&lt;/code&gt; 的东西，稍微梳理一下整个框架的流程。其实整个 &lt;code&gt;Redux&lt;/code&gt; 的代码很少，现在我也不能理解很多它的思想，反正先撸出个简单的 &lt;code&gt;Redux&lt;/code&gt; 吧。目标是照着它的流程写一个最简单的，也要支持异步 &lt;code&gt;Action&lt;/code&gt;。也算是个笔记性的东西。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Asncy await Promise的使用</title>
    <link href="http://yoursite.com/2016/12/15/Promise%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/12/15/Promise的使用/</id>
    <published>2016-12-15T03:53:56.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fetch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="comment">// resolve('success');</span></div><div class="line">            reject(<span class="string">'error'</span>);</div><div class="line">        &#125;, <span class="number">2000</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> testAsync = <span class="keyword">async</span>() =&gt; &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">await</span> fetch();</div><div class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">testAsync().then(<span class="function">(<span class="params">result</span>)=&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'这是成功的---&gt;'</span> + result);</div><div class="line">&#125;).catch(<span class="function">(<span class="params">error</span>)=&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'这是失败的---&gt;'</span> + error);</div><div class="line">&#125;);;</div></pre></td></tr></table></figure>
<p><code>async</code>函数返回的一个 <code>Promise</code>， 调用耗时函数前面加 <code>await</code> 关键字，返回成功的值，可以使用 <code>try..catch</code> 来进行捕获错误。上面的代码可以模拟一次请求的过程，最基本用法差不多都包括了<a id="more"></a></p>
<p><a href="http://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=true&amp;presets=latest,react,stage-2&amp;code=const%20fetch%20=%20%28%29%20=%3E%20%7B%0A%20%20%20%20return%20new%20Promise%28%28resolve,%20reject%29%20=%3E%20%7B%0A%20%20%20%20%20%20%20%20setTimeout%28%28%29%20=%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20//%20resolve%28%27success%27%29;%0A%20%20%20%20%20%20%20%20%20%20%20%20reject%28%27error%27%29;%0A%20%20%20%20%20%20%20%20%7D,%202000%29;%0A%20%20%20%20%7D%29;%0A%7D;%0A%0Aconst%20testAsync%20=%20async%28%29%20=%3E%20%7B%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%20%20%20return%20await%20fetch%28%29;%0A%20%20%20%20%7D%20catch%20%28error%29%20%7B%0A%20%20%20%20%20%20%20%20return%20Promise.reject%28error%29;%0A%20%20%20%20%7D%0A%7D;%0A%0AtestAsync%28%29.then%28%28result%29=%3E%20%7B%0A%20%20%20%20console.log%28%27%E8%BF%99%E6%98%AF%E6%88%90%E5%8A%9F%E7%9A%84---%3E%27%20%2b%20result%29;%0A%7D%29.catch%28%28error%29=%3E%20%7B%0A%20%20%20%20console.log%28%27%E8%BF%99%E6%98%AF%E5%A4%B1%E8%B4%A5%E7%9A%84---%3E%27%20%2b%20error%29;%0A%7D%29;;&amp;experimental=false&amp;loose=false&amp;spec=false&amp;playground=true" target="_blank" rel="external">点我运行</a></p>
<h4 id="Promise-then是异步的"><a href="#Promise-then是异步的" class="headerlink" title="Promise.then是异步的"></a><code>Promise.then</code>是异步的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(function (resolve)&#123;</div><div class="line">    console.log(&quot;inner promise&quot;); // 1</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div><div class="line">promise.then(function(value)&#123;</div><div class="line">    console.log(value); // 3</div><div class="line">&#125;);</div><div class="line">console.log(&quot;outer promise&quot;); // 2</div><div class="line"></div><div class="line"></div><div class="line">----------</div><div class="line">inner promise // 1</div><div class="line">outer promise // 2</div><div class="line">42            // 3</div></pre></td></tr></table></figure>
<p><a href="https://wohugb.gitbooks.io/promise/content/usage/async.html" target="_blank" rel="external">为啥这样</a></p>
<p>更多的关于 <code>Promise</code> 看下面的这本电子书，就不扯了，啦啦啦。</p>
<p>参考:<br><a href="https://wohugb.gitbooks.io/promise/content/index.html" target="_blank" rel="external">JavaScript Promise迷你书（中文版）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fetch = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// resolve(&#39;success&#39;);&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            reject(&lt;span class=&quot;string&quot;&gt;&#39;error&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;, &lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; testAsync = &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt;() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; fetch();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (error) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.reject(error);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;testAsync().then(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;result&lt;/span&gt;)=&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;这是成功的---&amp;gt;&#39;&lt;/span&gt; + result);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;).catch(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;error&lt;/span&gt;)=&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;这是失败的---&amp;gt;&#39;&lt;/span&gt; + error);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;函数返回的一个 &lt;code&gt;Promise&lt;/code&gt;， 调用耗时函数前面加 &lt;code&gt;await&lt;/code&gt; 关键字，返回成功的值，可以使用 &lt;code&gt;try..catch&lt;/code&gt; 来进行捕获错误。上面的代码可以模拟一次请求的过程，最基本用法差不多都包括了
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>简单谈谈Redux在项目中的使用</title>
    <link href="http://yoursite.com/2016/12/05/Redux-1/"/>
    <id>http://yoursite.com/2016/12/05/Redux-1/</id>
    <published>2016-12-05T10:54:46.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h1><p><code>Reducer</code> :为了描述 <code>action</code> 如何改变 <code>state tree</code>。 输入 <code>action</code> 和 <code>state</code>，一般根据 <code>action</code> 的 <code>type</code> 进行区分，然后处理，改变 <code>state tree</code>。<a id="more"></a></p>
<p><code>Reducer</code> 是纯函数，纯函数就是输入一个值，会输出一个确定的值，也就是 <code>Reducer</code> 里面不应该有 <code>getDate()</code>, 调用 <code>API</code> 等等之类不确定的操作。</p>
<p>e.g :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">const</span> store = configStore(reducers)</div><div class="line"></div><div class="line">    KeyboardReducer</div><div class="line">    </div><div class="line">    <span class="keyword">export</span> <span class="keyword">const</span> setKeyboardHeight = createRequest(<span class="string">'setKeyboardHeight'</span>, (keyboardHeight) =&gt; &#123;</div><div class="line">    <span class="keyword">var</span> oldKeyboarHeight = store.getState()[<span class="string">'keyboardHeight'</span>];</div><div class="line">    <span class="keyword">if</span> (oldKeyboarHeight == keyboardHeight) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;keyboardHeight&#125;;</div><div class="line">&#125;</div><div class="line">    <span class="keyword">export</span> <span class="keyword">default</span> KeyboardReducer = handleActions(&#123;</div><div class="line">        [setKeyboardHeight]: acceptSuccessActionReducer,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">keyboardHeight</span>: <span class="number">0</span>,</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里有个 <code>KeyboardReducer</code> 的一个自定义的 <code>Reducer</code> ,用来处理键盘高度的事件，先不看实现，这个 <code>Reducer</code> 接受一个 <code>type</code>  为 <code>setKeyboardHeight</code> 的 <code>action</code> ，然后获取原 <code>store</code> 中的 <code>oldState</code> 中的 <code>keyboardHeight</code> ，然后对比，改变 <code>state tree</code> 中的 <code>keyboardHeight</code> 这个 <code>state</code>。 同时可以发现，在创建给某个模块使用的 <code>store</code> 的时候，这个 <code>reducer</code> 已经对 <code>state tree</code> 做了一些改变，设置了 <code>keyboardHeight : 0</code> 这个默认值,举例这个我们可以在cs模块的 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = configStore(reducers);</div><div class="line">store.dispatch(getQuestions());</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</div></pre></td></tr></table></figure>
<p>在处理模块自己的 <code>action</code> 之前，断点可以看到</p>
<pre><code>store.getState()[&apos;keyboardHeight&apos;] ：0
</code></pre><p>也就印证了我们的猜想。</p>
<h4 id="拆分-Reducer"><a href="#拆分-Reducer" class="headerlink" title="拆分 Reducer"></a>拆分 <code>Reducer</code></h4><p><code>Reducer</code>接受一个 <code>state</code> 和 <code>action</code> ，返回一个新的 <code>State</code>,如果项目很大，对应的 <code>state</code> 也会很大，如果使用一个 <code>Reducer</code> 进行整个的 <code>state</code> 的处理就会非常的臃肿。这个时候就可以进行拆分 <code>Reducer</code> ,每个 <code>Reducer</code> 去处理自己职责范围内的 <code>state</code> ，类似上面的  <code>KeyboardReducer</code> 就只对 <code>store.getState()[&#39;keyboardHeight&#39;];</code> 这个 <code>stage</code> 感兴趣。 因为 <code>store</code> 只有一个，当分成多个 <code>Reducer</code> 的时候，那就需要一个 <code>Reducer</code> 去管理这些 <code>Reducers</code> 。可以使用 <code>combineReducers</code> 进行 <code>Reducer</code> 的合成，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">state = &#123;&#125;,action</span>)</span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type)&#123;</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,........);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">state = &#123;&#125;,action</span>)</span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type)&#123;</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,........);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> App = combineReducers(&#123;</div><div class="line">    foo,</div><div class="line">    foo1</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在项目中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> reducers = handleActions(&#123;</div><div class="line">    [setBrandId]: acceptSuccessActionReducer,</div><div class="line">    [getBrandCatalogs]: acceptSuccessActionReducer,</div><div class="line">    [getBrandInfo]: acceptSuccessActionReducer,</div><div class="line">    [setOrderByAndDirect]: acceptSuccessActionReducer,</div><div class="line">    [getFilterInfo]: acceptSuccessActionReducer,</div><div class="line">    [setFilter]: acceptSuccessActionReducer,</div><div class="line">    [followBrand]: acceptSuccessActionReducer,</div><div class="line">    [setPriceSelect]: acceptSuccessActionReducer,</div><div class="line">    [getCampaign]: acceptSuccessActionReducer,</div><div class="line">    [resetgetCampaigned]: acceptSuccessActionReducer,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里每个请求都对于同样的 <code>acceptSuccessActionReducer</code> 这个 <code>Reducer</code>，代码很简单就不贴了，最终这些 <code>reducer</code> 的统一处理是在 <code>createStore</code> 的时候，下面会说到</p>
<p>项目中管理这些 <code>Reducers</code> 是使用了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">reduceReducers(actionStateReducers, KeyboardReducer, reducer)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">reduceReducers</span>(<span class="params">...reducers</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</div><div class="line">        <span class="comment">//框架的安全检查类型，可暂时忽略。。</span></div><div class="line">        <span class="comment">// if (action.type === ActionTypes.INIT) &#123;</span></div><div class="line">        <span class="keyword">if</span> (action.type === <span class="string">'@@redux/INIT'</span>) &#123;</div><div class="line">            <span class="keyword">var</span> state = &#123;&#125;;</div><div class="line">            <span class="comment">// collect all init state.</span></div><div class="line">            reducers.forEach(<span class="function"><span class="params">reduce</span> =&gt;</span> &#123;</div><div class="line">                state = <span class="built_in">Object</span>.assign(state, reduce(<span class="literal">undefined</span>, action));</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> reducers.reduce(</div><div class="line">                <span class="comment">//迭代累加调用reducer</span></div><div class="line">                (state, reduce) =&gt; reduce(state, action),</div><div class="line">                state</div><div class="line">            );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a><code>Action</code></h1><p><code>Action</code>可以理解为一个动作或者事件。它的作用是将信息传递给某个 <code>Reducer</code> 进而去影响 <code>State tree</code>,而使用这些 <code>Action</code> 只有一种方法就是 <code>store.dispatch(action)</code>, 在项目中可以手动去调用，也可以使用 <code>react-redux</code> 的 <code>bindActionCreators</code>方法自动将多个 <code>Action</code> 绑定到 <code>Dispatch()</code> 方法上。这个肯定也是调用了 <code>store.dispatch(action)</code> ,一般的 <code>Action</code> 的结构类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    type: &quot;action-type&quot;</div><div class="line">    value: &quot;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>action</code>的定义十分灵活，一般只有 <code>type</code>是固定的，其他随便。但是在异步的 <code>action</code> 中，通过 <code>actionCreater</code>创建的一般都是 <code>function</code>，返回值才是起作用的 <code>action</code>。</p>
<h1 id="Store"><a href="#Store" class="headerlink" title="Store"></a><code>Store</code></h1><p>每个 <code>Redux</code>应用只有一个 <code>store</code>，如果觉得数据很多很臃肿，应该去使用组合 <code>Reducer</code> 的方法而不是去创建多个 <code>store</code> 解决。 <code>store</code>  有下面几个重要方法：</p>
<ul>
<li><code>store.getState</code> 对当前 <code>store</code> 进行快照，获取当前 <code>store</code> 对应的 <code>state</code>.</li>
<li><code>dispatch(action)</code> 分发 <code>action</code> 给 <code>reducer</code>。</li>
<li><code>subscribe(listener)</code> 注册监听器，当 <code>store</code> 改变时回调监听器。</li>
</ul>
<p>e.g.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">//当进入品牌详情页面，设置brandId导致store的改变，进而回调这里，去请求网络。</span></div><div class="line">    <span class="keyword">var</span> brandId = store.getState()[<span class="string">'brandId'</span>];</div><div class="line">    <span class="keyword">if</span>(brandId &amp;&amp; brandId !== lastBrandId) &#123;</div><div class="line">        lastBrandId = brandId;</div><div class="line">        store.dispatch(getBrandInfo());</div><div class="line">        store.dispatch(getFilterInfo());</div><div class="line">        store.dispatch(getBrandCatalogs(<span class="literal">true</span>));</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a><code>Middleware</code></h1><p>对于中间件，看这个就够了，我也说不了比它更好：</p>
<p><a href="http://cn.redux.js.org/docs/advanced/Middleware.html" target="_blank" rel="external">点击了解Middleware</a></p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><p>来简单的看一下项目中的一个请求 <code>action</code> 是如果经过一步步到最终 UI 上面展示的。先从创建 <code>Store</code> 开始，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//参数reducer是我们在模块中自己定义 一般一个请求对应一个reducer 参考actions目录</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configStore</span>(<span class="params">reducer</span>) </span>&#123;</div><div class="line">    <span class="comment">//createStore 第一个参数是reducer</span></div><div class="line">    <span class="keyword">const</span> store = createStore(</div><div class="line">        <span class="comment">//array.reducer类似一个迭代累加的效果 这里就是迭代去调用各种reducer,累加对store的影响</span></div><div class="line">        <span class="comment">//actionStateReducers:主要是为了异步的action 自动多了ACTION_WILL_START,ACTION_WILL_END这两个action</span></div><div class="line">        <span class="comment">//KeyboardReducer :处理键盘的</span></div><div class="line">        <span class="comment">//我们在模块中自己定义的各个reducer 详情见模块下的actions/index.js 中的export const reducers = handleActions。。。。。</span></div><div class="line">        <span class="comment">//类似注册的作用 预先创建各个 Reducers 到使用的时候一般由下面的中间件中调用。</span></div><div class="line">        reduceReducers(actionStateReducers, KeyboardReducer, reducer),</div><div class="line">        </div><div class="line">        <span class="comment">//Middleware作用在action创建之后,到达reducer之前的阶段</span></div><div class="line">        <span class="comment">//actionStateMiddleware:对应上面的actionStateReducers,处理多出来的两个action</span></div><div class="line">        <span class="comment">//会去调用上面注册的东西</span></div><div class="line">        applyMiddleware(actionStateMiddleware, errorHandlerMiddleware, promiseMiddleware, createLogger(&#123;</div><div class="line">            <span class="attr">predicate</span>: <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (action.type === <span class="string">'ACTION_WILL_START'</span> || action.type === <span class="string">'ACTION_WILL_END'</span> || action.type === <span class="string">'CONCURRENT_EXECUTION_ERROR'</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;,</div><div class="line">        &#125;))</div><div class="line">    );</div><div class="line"></div><div class="line">    global.store = store;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> store;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们去创建一个请求，都是使用 <code>createRequest</code> ，其实也就是创建了一个 <code>action</code> ，但是这个 <code>action</code> 是个 <code>function</code>，这个 <code>function</code>的返回值是真正的 <code>action</code>， 这个先不管，但是起作用的 <code>action</code> 结构类似 ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//同步 &#123;</span></div><div class="line">        <span class="comment">//   type:setBrandId</span></div><div class="line">        <span class="comment">//   payload:object</span></div><div class="line">        <span class="comment">// &#125;</span></div><div class="line"><span class="comment">//异步&#123;</span></div><div class="line">        <span class="comment">//   type:getBrand</span></div><div class="line">        <span class="comment">//   payload:promise</span></div><div class="line">        <span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>对于最常用的异步 <code>action</code> ,对应与 <code>actionStateReducers</code> 这个 <code>reducer</code> ，详情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//每个action都会多创建这两个action，在原始action开始和结束的时候分发。</span></div><div class="line"><span class="keyword">const</span> actionWillStart = createAction(<span class="string">'ACTION_WILL_START'</span>);</div><div class="line"><span class="keyword">const</span> actionDidEnd = createAction(<span class="string">'ACTION_WILL_END'</span>);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> actionStateReducers = handleActions(&#123;</div><div class="line">    [actionWillStart]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">var</span> actionName = action.payload;<span class="comment">//请求回来的数据会在action.payload中 进而去改变store action type也就是请求名</span></div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'调用处理开始的action的地方,action--&gt;'</span>, action);</div><div class="line"></div><div class="line">        <span class="comment">//state中包含actionstate和我们自己定义的各种state</span></div><div class="line">        <span class="keyword">var</span> actionState = state[<span class="string">'actionState'</span>];</div><div class="line">        <span class="comment">//actionstate的结构类似这样:</span></div><div class="line">        <span class="comment">//&#123;</span></div><div class="line">        <span class="comment">// getLiveShow:1   //是action的名称 和 数量 这个数量暂时还不知道是干什么用的  一般就是0或者1</span></div><div class="line">        <span class="comment">// &#125;</span></div><div class="line">        <span class="keyword">var</span> count = actionState[actionName];</div><div class="line">        <span class="keyword">if</span> (count) &#123;</div><div class="line">            count += <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            count = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        actionState[actionName] = count;</div><div class="line">        <span class="comment">//如果是ACTION_WILL_START这个action  就把对应的action中的actionstate +1 表明创建了这个一个action??</span></div><div class="line">        <span class="comment">//然后应用修改的state</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;actionState&#125;);</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//这个是ACTION_WILL_END 同上</span></div><div class="line">    [actionDidEnd]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;<span class="comment">//在数据回来的时候调用</span></div><div class="line">        <span class="keyword">var</span> actionName = action.payload;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> actionState = state[<span class="string">'actionState'</span>];</div><div class="line">        <span class="keyword">var</span> count = actionState[actionName];</div><div class="line">        --count;</div><div class="line">        actionState[actionName] = count;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'调用处理结束的action的地方,action--&gt;'</span>, action);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;actionState&#125;);</div><div class="line">    &#125;,</div><div class="line">&#125;, &#123;</div><div class="line">    <span class="attr">actionState</span>: &#123;&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> 上面的代码主要是帮我们多创建了两个 <code>action</code>，而何时去调用，调用的顺序是在下面的 <code>actionStateMiddleware</code> 中定义的，详情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">actionStateMiddleware</span>(<span class="params">&#123;dispatch, getState&#125;</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</div><div class="line">            <span class="comment">// action throttling</span></div><div class="line">            <span class="keyword">if</span> (isPromise(action.payload)) &#123;</div><div class="line">                <span class="keyword">if</span> (action.type == <span class="string">'CONCURRENT_EXECUTION_ERROR'</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> next(action);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'进来中间件,action--&gt;'</span>, action);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (action.type !== actionWillStart.toString() &amp;&amp;</div><div class="line">                    action.type !== actionDidEnd.toString()) &#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">'分发开始的action,action--&gt;'</span>, action);</div><div class="line">                    dispatch(actionWillStart(action.type));<span class="comment">//不是那两种 action, 分发actionWillStart:&#123;type:action.type&#125;</span></div><div class="line">                &#125;</div><div class="line">                <span class="comment">//这里的payload是个promise</span></div><div class="line">                action.payload.then(</div><div class="line">                    <span class="function"><span class="params">result</span> =&gt;</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (action.type !== actionWillStart.toString() &amp;&amp;</div><div class="line">                            action.type !== actionDidEnd.toString()) &#123;</div><div class="line">                            <span class="built_in">console</span>.log(<span class="string">'分发结束的action,action--&gt;'</span>, action);</div><div class="line">                            dispatch(actionDidEnd(action.type));<span class="comment">//数据回来的时候 调用这个</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;,</div><div class="line">                    error =&gt; &#123;</div><div class="line">                        <span class="keyword">if</span> (action.type !== actionWillStart.toString() &amp;&amp;</div><div class="line">                            action.type !== actionDidEnd.toString()) &#123;</div><div class="line">                            dispatch(actionDidEnd(action.type));</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                );</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isFSA(action) &amp;&amp; !action.error &amp;&amp; !action.payload) &#123;</div><div class="line">                <span class="comment">// return action directly, and the payload will not be reduced into store.</span></div><div class="line">                <span class="keyword">return</span> action;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> next(action);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而处理原始的 <code>action</code> 则是在 <code>acceptSuccessActionReducer</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">acceptSuccessActionReducer</span>(<span class="params">state, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!action.error &amp;&amp; action.payload) &#123;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'调用处理原始的action的地方,action--&gt;'</span>, action);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, action.payload);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>何时去调用则是在 <code>promiseMiddleware</code> 这个中间件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">....略</div><div class="line"> return isPromise(action.payload) ? action.payload.then(function (result) &#123;</div><div class="line">        return dispatch(_extends(&#123;&#125;, action, &#123; payload: result &#125;));</div><div class="line">....</div></pre></td></tr></table></figure>
<p>最后以品牌详情切换排序方式为例，看一下完整的 <code>action</code> 到 UI 改变的过程。</p>
<p><img src="http://7xjlmz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-04%20%E4%B8%8B%E5%8D%888.54.40.png" alt=""> </p>
<p>无论是开始还是结束的action，都会触发 <code>state</code> 中的 <code>actionState</code> 的改变，进而触发 <code>store</code> 的改变，进而触发页面中 <code>state</code> 的更新。所以会出现多次更新 UI的情况。</p>
<p>createRequest<br>-&gt;dispatch(action)<br>-&gt;actionStateMiddleware<br>-&gt;dispatch(actionWillStart(action.type))<br>-&gt;reduceReducers<br>-&gt;迭代执行reducers(1:包括start,end的actionStateReducers，2：KeyboardReducer，3：模块中定义的reducers：handactions(…..))<br>-&gt;调用handleActions中start action对应的reducer逻辑<br>-&gt;修改start action 对应的actionstate<br>-&gt;请求结果返回<br>-&gt;调用handleActions中end action对应的reducer逻辑<br>-&gt;修改end action 对应的actionstate<br>-&gt;调用promiseMiddleware中的promise响应<br>-&gt;修改store<br>-&gt;调用组件中mapStateToProps<br>-&gt;调用componentWillReceiveProps。</p>
<h2 id="Why-Redux"><a href="#Why-Redux" class="headerlink" title="Why Redux"></a><code>Why Redux</code></h2><p>扯了半天，为什么要用 <code>Redux</code>? 它的定义是 :<strong>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</strong> 为什么说是可预测的状态，因为一个确定的 <code>state</code> 就对应一个确定的 <code>view</code>，使用 <code>Redux</code> 能感受到它的数据的单向流动性，用户触发某个动作，发出一个 <code>action</code> ，经过 <code>Reducer</code>,改变 <code>store</code> 的数据，进而去控制 UI的效果，仅仅有这一种方式，单向数据流也保证了可预测的状态。如果不这样做，我们的 <code>View</code> 可以被各种各样的 <code>event</code>,<code>Model</code>甚至其他的 <code>View</code>控制，一个 <code>View</code> 的状态无法预测，当改变因素很多的时候就无法控制。这只是我浅显的理解。<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/WechatIMG4.jpeg" alt=""></p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>好大老师改了原 <code>actions/index.js</code>和 <code>store/index.js</code>，结合了这两个，看完了上面的这些东西，再去看改动应该就没什么压力了，也更理解为什么这么改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Reducer&quot;&gt;&lt;a href=&quot;#Reducer&quot; class=&quot;headerlink&quot; title=&quot;Reducer&quot;&gt;&lt;/a&gt;Reducer&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Reducer&lt;/code&gt; :为了描述 &lt;code&gt;action&lt;/code&gt; 如何改变 &lt;code&gt;state tree&lt;/code&gt;。 输入 &lt;code&gt;action&lt;/code&gt; 和 &lt;code&gt;state&lt;/code&gt;，一般根据 &lt;code&gt;action&lt;/code&gt; 的 &lt;code&gt;type&lt;/code&gt; 进行区分，然后处理，改变 &lt;code&gt;state tree&lt;/code&gt;。
    
    </summary>
    
    
      <category term="Redux" scheme="http://yoursite.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Router设计</title>
    <link href="http://yoursite.com/2016/11/16/Router%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2016/11/16/Router设计/</id>
    <published>2016-11-16T11:20:57.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近公司的项目要进行页面间跳转的重构，首先项目是单 <code>Activity</code> + 多 <code>Fragment</code> 的结构，因为是电商的项目，所以涉及到很多 H5 , <code>Native</code> 和 <code>React Native</code> 页面之间的交互与跳转，这篇不是介绍两者之间是如何进行通信的，而是当 H5 或者外部分享的链接打开后传递过来 <code>Uri</code> 要解析跳转到 <code>Native</code> 的页面的处理。当然各个页面的 <code>Host</code>  是提前统一定义好的，具体的做法这里也不说了，也没什么难点。原来的写法是都放到一个 <code>Util</code> 类里面，各种 <code>Switch</code> <code>Case</code> 来进行分支判断，当项目越来越大维护起来十分的困难，而且本身 <code>Native</code> 的页面之间还有一套跳转的逻辑，同时维护两套的代价是很大的，所有希望将项目重构一下，统一两端的处理逻辑，就产生了下面的这个路由结构。<a id="more"></a></p>
<p>&emsp;&emsp;在开始重构之前，也是去搜索了一下网上的一些开源例子，绝大多数都是基于 <code>Activity</code> 的跳转，写的功能虽然很多，但是对于我们的项目却是很冗余并且也不怎么合适，所以要去定制一套适合自己的路由，目标就是统一 H5 , <code>Native</code> 和 <code>React Native</code> 这三端之间的跳转逻辑，同时做到简单易用，容易维护和容易拓展。去写人人都能很容易看的懂的代码，而不是写那么花里胡哨的各种”炫技”的代码。</p>
<p>&emsp;&emsp;先放一下这个项目的类图，不怎么熟悉 <code>UML</code>,里面有些关系表示的不正确，大概的意思还是可以表达出来的。首先要去统一两端的逻辑，肯定需要在跳转直接转换成统一的 <code>Uri</code> 进行跳转，从 H5 过来的就很简单就是个 <code>Uri</code>,而 <code>Native</code> 的跳转则要去进行处理拼接，然后通过统一的路由进行处理，最后跳转到具体的页面。</p>
<p><img src="http://7xjlmz.com1.z0.glb.clouddn.com/Class%20Diagram%20%282%29.png" alt=""></p>
<p>&emsp;&emsp;先说一下设计的思想，一个页面对应一个 <code>Uri</code>,并且使用不同的 <code>Host</code> 或者 <code>Path</code> 进行区分和信息的传递，这里先建立了一个全局的”路由表”,让 <code>Url</code> 和一个具体页面的切换器进行对应，当路由获取到一个 <code>Uri</code> 的时候，在路由表中找到对应的切换器，切换到具体的页面。当然在切换之前还需要一些其他的处理，这里加入了拦截器的机制，默认实现了两种拦截器，<code>LoginInterceptor</code> 和 <code>LogInterceptor</code> 分别进行需要登录页面的 <code>Uri</code> 的拦截使其跳转到登录页面和打印 <code>Uri</code> 和其他跳转参数。当然也可以去实现其他的拦截器，这样就使得整个路由十分的灵活。</p>
<p>&emsp;&emsp;说一下怎么使用，首先在 <code>Application</code> 中初始化路由表，这个路由表是个 <code>pageMap : Map&lt;String, Switcher&gt;</code> ，这里的 <code>Key</code> 就是每个页面对应的 <code>Host</code> ,<code>Value</code> 的 <code>Switcher</code> 就是处理每个页面切换逻辑的地方，类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pageMap.put(REACT_NATIVE, new RnSwitcher());</div><div class="line">pageMap.put(SCHEMA_HTTP, new H5Switcher());</div><div class="line">pageMap.put(HOST_CATALOG, new CatalogDetailSwitcher());</div></pre></td></tr></table></figure>
<p>这样就初始化了全局的路由表。因为是单 <code>Activity</code> +多 <code>Fragment</code> 的结构，几乎所有的页面都是 <code>Fragment</code> ,不像切换 <code>Activity</code> 那么简单，这里要去处理相对复杂的 <code>Fragment</code> 的切换逻辑和维护回退栈的操作，所以封装了一个 <code>NavigationManager</code> 用来处理这些操作。看一下初始化的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Router.install(mNavigationManager)</div><div class="line">            .addInterceptor(new LoginInterceptor())</div><div class="line">            .addInterceptor(new LogInterceptor());</div></pre></td></tr></table></figure>
<p>因为要持有 <code>Activiry</code> 所以要在 <code>onDestroy</code> 的时候及时释放引用 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Router.unInstall();</div></pre></td></tr></table></figure>
<p>然后看一下具体的跳转：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Router.config().setUri(uri).start()</div></pre></td></tr></table></figure>
<p>这样就可以跳转到具体的页面了，当然只是简单的示例一下，实际使用的时候肯定还有其他的配置。因为使用者不可能记得每个页面的 <code>Uri</code> 是怎么拼接的，所以还可以在写个工具类来封装一下，这个就不说了。</p>
<p> &emsp;&emsp;说一下这个路由的优点：</p>
<ol>
<li>简单易懂，几乎人人都读得懂，基本不需要学习成本。更没有任何的注解反射之类的。</li>
<li>方便统一进行跳转管理，使用了拦截器，可以打印出跳转中的 <code>Uri</code> 和其他参数，调试十分方便。加入了登录拦截器，使得跳转可以无脑跳转，无需关心页面是否需要登录，路由帮你做好了判断和后续登录成功跳转到目标页面。</li>
<li>容易拓展，无论是新增页面还是修改维护旧页面。将每个页面切换逻辑封装到对应的 <code>Switcher</code> 里面，快速定位。</li>
<li>统一 <code>H5</code> , <code>Native</code> 和 <code>React Native</code> 三端的跳转，更加方便维护。</li>
<li>啦啦啦啦。。。</li>
</ol>
<p>&emsp;&emsp;以后甚至可以将路由表让服务端去控制，无论是灵活性还是稳定性都大大提高，只是目前还没有这样的需求，但是改造起来将十分的简单。这个路由从设计到项目的改造大概花了一周的时间，也算是独立设计开发的完整的重要模块，现在还处于比较初级的阶段，肯定有提升空间。目前用在 <a href="http://www.bolome.com/" target="_blank" rel="external">波罗蜜全球购</a> 的 <code>Android</code> 客户端中，欢迎大家支持。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;最近公司的项目要进行页面间跳转的重构，首先项目是单 &lt;code&gt;Activity&lt;/code&gt; + 多 &lt;code&gt;Fragment&lt;/code&gt; 的结构，因为是电商的项目，所以涉及到很多 H5 , &lt;code&gt;Native&lt;/code&gt; 和 &lt;code&gt;React Native&lt;/code&gt; 页面之间的交互与跳转，这篇不是介绍两者之间是如何进行通信的，而是当 H5 或者外部分享的链接打开后传递过来 &lt;code&gt;Uri&lt;/code&gt; 要解析跳转到 &lt;code&gt;Native&lt;/code&gt; 的页面的处理。当然各个页面的 &lt;code&gt;Host&lt;/code&gt;  是提前统一定义好的，具体的做法这里也不说了，也没什么难点。原来的写法是都放到一个 &lt;code&gt;Util&lt;/code&gt; 类里面，各种 &lt;code&gt;Switch&lt;/code&gt; &lt;code&gt;Case&lt;/code&gt; 来进行分支判断，当项目越来越大维护起来十分的困难，而且本身 &lt;code&gt;Native&lt;/code&gt; 的页面之间还有一套跳转的逻辑，同时维护两套的代价是很大的，所有希望将项目重构一下，统一两端的处理逻辑，就产生了下面的这个路由结构。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>React Native + Redux + React-Redux</title>
    <link href="http://yoursite.com/2016/09/30/Redux/"/>
    <id>http://yoursite.com/2016/09/30/Redux/</id>
    <published>2016-09-30T07:17:53.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>Component</code>中的<code>state</code>相当于组件内的本地变量，用于储存view的本地变化</p>
<p><code>props</code>中存储数据， <code>props</code>属于readOnly的常量dic<a id="more"></a></p>
<p>store相当于全集的数据状态仓库，只有一个，改变它的唯一方式就是store.dispatch(action)，可以通过store.getState对当前的store进行一次快照，store还有store.subscribe方法，也就是在store.dispatch触发了store的数据更新，回调这个subscribe方法。</p>
<p>使用了React-Redux这个库有两个重要的方法：<code>mapStateToProps</code>是用来把外部的state,也就是当前store的快照映射到UI组件的参数上(props),也就是输入数据。<code>mapDispatchToProps</code>是把对UI组件的操作映射成action，</p>
<p>当dispatch一个action后，reduce会自动生成一个当前store的快照 =&gt;state，调用mapStateToProps，将state映射到props,调用React native的生命周期方法<code>componentWillReceiveProps</code>,这里可以再处理一下数据，改变this.state的值。</p>
<p><code>mapStateToProps</code>会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;Component&lt;/code&gt;中的&lt;code&gt;state&lt;/code&gt;相当于组件内的本地变量，用于储存view的本地变化&lt;/p&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt;中存储数据， &lt;code&gt;props&lt;/code&gt;属于readOnly的常量dic
    
    </summary>
    
    
      <category term="React Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit源码浅析</title>
    <link href="http://yoursite.com/2016/08/17/Refrofit%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2016/08/17/Refrofit源码浅析/</id>
    <published>2016-08-16T16:49:43.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p> 这篇主要会走读一下<code>Retrofit</code>的源码，解析一下里面遇到的一些设计模式，网络请求的过程等。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>从创建<code>Retrofit</code>开始，看一下常见的创建<code>Retrofit</code>的实例的方式<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();</div><div class="line">        interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</div><div class="line">        OkHttpClient client = new OkHttpClient.Builder()</div><div class="line">                .addInterceptor(interceptor)</div><div class="line">                .retryOnConnectionFailure(true)</div><div class="line">                .connectTimeout(15, TimeUnit.SECONDS)</div><div class="line">                .addNetworkInterceptor(createHeaderInterceptor())</div><div class="line">                .build();</div><div class="line">                </div><div class="line">Retrofit retrofit = new Retrofit.Builder()</div><div class="line">                .baseUrl(BuildConfig.BASE_API_URL)</div><div class="line">                .client(client)</div><div class="line">                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div><div class="line">                .addConverterFactory(BolomeGsonConverterFactory.create())</div><div class="line">                .build();</div><div class="line">          Net net = retrofit.create(Net.class)</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出，<code>Retrofit</code>并没有去真正的执行网络请求，还是交给了<code>OkHttp</code>来进行实现，<code>Retrofit</code>可以看作的对<code>OkHttp</code>的一层非常棒的封装，<code>Retrofit</code>的关注点是在如何让你更快捷更灵活的去进行网络请求。如果你使用过<code>Retrofit</code>的话，你也会明白用<code>Retrofit</code>去实现一次网络请求是多方便的事情。</p>
<h3 id="retrofit-create"><a href="#retrofit-create" class="headerlink" title="retrofit.create"></a><code>retrofit.create</code></h3><p>从<code>Net net = retrofit.create(Net.class)</code>这里开始入手，用过<code>Retrofit</code>的几乎都知道<code>Retrofit</code>是用了动态代理，动态代理说简单点就是动态的去生成接口的实现类，也可以在原始的结果返回前对参数或者结果进行修改，这个特性也使得一些<code>Hook</code>框架大量使用了动态代理，比如很著名的360的<code>DroidPlugin</code>。有点扯远了，还是去源码里面去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</div><div class="line">  ...</div><div class="line">  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">      new InvocationHandler() &#123;</div><div class="line">        private final Platform platform = Platform.get();</div><div class="line"></div><div class="line">        @Override public Object invoke(Object proxy, Method method, Object... args)</div><div class="line">            throws Throwable &#123;</div><div class="line">          ...</div><div class="line">          ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">          OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">          return serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里省略了一下判断的逻辑，但是主要的就是最后的三行代码，从方法的签名来看，是传进来一个接口类，返回一个接口类型的实例，但是这个实例的具体实现类型是由<code>serviceMethod.callAdapter.adapt</code>方法动态决定了，而且这个接口里面的每一次方法调用，都会进入这个<code>invoke</code>方法，也就是由接口的实现类去完成功能。例如，<code>Retrofit</code>默认的请求方式是<code>Call&lt;T&gt;</code>,这里默认的实现类就是<code>ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt;</code>，而在这个类里面又是用代理类的方式去交给<code>Okhttp</code>的<code>call</code>去执行真正的请求，这个就是后面再说了。</p>
<h3 id="ServiceMethod"><a href="#ServiceMethod" class="headerlink" title="ServiceMethod"></a><code>ServiceMethod</code></h3><p>这个类主要是储存了请求的信息和<code>Retrofit</code>的配置信息以及对请求注解的解析生成正常的地址和请求。</p>
<h3 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a><code>OkHttpCall</code></h3><p>第二行<code>OkHttpCall</code>可以看成是<code>OkHttp</code>的<code>call</code>在<code>Retrofit</code>层面的一次封装。从上面一步看到，把请求参数和配置信息交给了这个<code>OkHttpCall</code>，然后让<code>OkHttp</code>去执行请求操作。</p>
<h3 id="callAdapter"><a href="#callAdapter" class="headerlink" title="callAdapter"></a><code>callAdapter</code></h3><p>不知道该怎么去具体描述这个类的意思，可以理解成将请求转换成不同的请求形式，例如默认的<code>call</code>或者常见的<code>Rxjava</code>的<code>Observable&lt;T&gt;</code>的形式亦或者是<code>Agera</code>的<code>Supplier&lt;Result&lt;T&gt;&gt;</code>的形式等等。以<code>@drakeet</code>的<a href="https://github.com/drakeet/retrofit-agera-call-adapter" target="_blank" rel="external">retrofit-agera-call-adapter</a>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">public final class AgeraCallAdapterFactory extends CallAdapter.Factory &#123;</div><div class="line"></div><div class="line">    public static AgeraCallAdapterFactory create() &#123;</div><div class="line">        return new AgeraCallAdapterFactory();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private AgeraCallAdapterFactory() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">        ...</div><div class="line">        支持Supplier&lt;Result&lt;T&gt;&gt;形式</div><div class="line">            return new BodyCallAdapter(innerTypeOfInnerType);</div><div class="line">        &#125;</div><div class="line">        ...支持Supplier&lt;Result&lt;Response&lt;T&gt;&gt;&gt;形式</div><div class="line">        return new ResponseCallAdapter(responseType);</div><div class="line">    &#125;</div><div class="line">    private static class BodyCallAdapter implements CallAdapter&lt;Supplier&lt;?&gt;&gt; &#123;</div><div class="line"></div><div class="line">        private final Type responseType;</div><div class="line"></div><div class="line"></div><div class="line">        BodyCallAdapter(Type responseType) &#123;</div><div class="line">            this.responseType = responseType;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        @Override public Type responseType() &#123;</div><div class="line">            return responseType;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        @Override</div><div class="line">        public &lt;T&gt; Supplier&lt;Result&lt;T&gt;&gt; adapt(Call&lt;T&gt; call) &#123;</div><div class="line">            return new CallSupplier(call);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class CallSupplier&lt;T&gt; implements Supplier&lt;Result&lt;T&gt;&gt; &#123;</div><div class="line"></div><div class="line">    private final Call&lt;T&gt; originalCall;</div><div class="line"></div><div class="line"></div><div class="line">    CallSupplier(@NonNull final Call&lt;T&gt; call) &#123;</div><div class="line">        this.originalCall = checkNotNull(call);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @NonNull @Override public Result&lt;T&gt; get() &#123;</div><div class="line">        Result&lt;T&gt; result;</div><div class="line">        try &#123;</div><div class="line">            Response&lt;T&gt; response = originalCall.clone().execute();</div><div class="line">            //将Response转换成Result&lt;T&gt;的形式 因为数据要从Result中取，而不像默认的call那样直接走回调</div><div class="line">            if (response.isSuccessful()) &#123;</div><div class="line">                result = Result.success(response.body());</div><div class="line">            &#125; else &#123;</div><div class="line">                result = Result.failure(new HttpException(response));</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            result = Result.failure(e);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码没太多难度，看看就明白了。也是非常棒的自定义<code>CallAdapter</code>教程。</p>
<h3 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a><code>enqueue</code></h3><p>异步请求的时候是这个样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mNet.getLiveShows(20, 1).enqueue(new Callback&lt;LiveBlock&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onResponse(Call&lt;LiveBlock&gt; call, Response&lt;LiveBlock&gt; response) &#123;</div><div class="line">               </div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onFailure(Call&lt;LiveBlock&gt; call, Throwable t) &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure>
<p>而<code>getLiveShows</code>返回的<code>call</code>其实是上面说的<code>ExecutorCallbackCall</code>，这个的<code>enqueue</code>是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">      if (callback == null) throw new NullPointerException(&quot;callback == null&quot;);</div><div class="line"></div><div class="line">      delegate.enqueue(new Callback&lt;T&gt;() &#123;</div><div class="line">        @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</div><div class="line">          callbackExecutor.execute(new Runnable() &#123;</div><div class="line">            @Override public void run() &#123;</div><div class="line">              if (delegate.isCanceled()) &#123;</div><div class="line">                // Emulate OkHttp&apos;s behavior of throwing/delivering an IOException on cancellation.</div><div class="line">                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">              &#125; else &#123;</div><div class="line">                callback.onResponse(ExecutorCallbackCall.this, response);</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</div><div class="line">          callbackExecutor.execute(new Runnable() &#123;</div><div class="line">            @Override public void run() &#123;</div><div class="line">              callback.onFailure(ExecutorCallbackCall.this, t);</div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用了<code>delegate.enqueue</code>这个<code>delegate</code>就是上面说到的<code>OkHttpCall</code>看这个里面的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">call.enqueue(new okhttp3.Callback() &#123;</div><div class="line">      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)</div><div class="line">          throws IOException &#123;</div><div class="line">        Response&lt;T&gt; response;</div><div class="line">        try &#123;</div><div class="line">          response = parseResponse(rawResponse);</div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">          callFailure(e);</div><div class="line">          return;</div><div class="line">        &#125;</div><div class="line">        callSuccess(response);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public void onFailure(okhttp3.Call call, IOException e) &#123;</div><div class="line">        try &#123;</div><div class="line">          callback.onFailure(OkHttpCall.this, e);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      private void callFailure(Throwable e) &#123;</div><div class="line">        try &#123;</div><div class="line">          callback.onFailure(OkHttpCall.this, e);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      private void callSuccess(Response&lt;T&gt; response) &#123;</div><div class="line">        try &#123;</div><div class="line">          callback.onResponse(OkHttpCall.this, response);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;</div><div class="line">    ResponseBody rawBody = rawResponse.body();</div><div class="line">   .....//使用responseConverter.convert(body)</div><div class="line">      T body = serviceMethod.toResponse(catchingBody);</div><div class="line">      return Response.success(body, rawResponse);</div><div class="line">    ....</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>注意的是这里几个<code>call</code>的区别和三个<code>enqueue</code>的区别和作用</p>
<p>###<code>Converter</code><br>这个是用来将<code>RequestBody</code>和<code>responseBody</code>转换成相应的类型，具体去看看官方的<code>GsonConverterFactory</code>就可以了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 这篇主要会走读一下&lt;code&gt;Retrofit&lt;/code&gt;的源码，解析一下里面遇到的一些设计模式，网络请求的过程等。&lt;/p&gt;
&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;从创建&lt;code&gt;Retrofit&lt;/code&gt;开始，看一下常见的创建&lt;code&gt;Retrofit&lt;/code&gt;的实例的方式&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>浅谈CoordinatorLayout</title>
    <link href="http://yoursite.com/2016/08/01/%E6%B5%85%E8%B0%88CoordinatorLayout/"/>
    <id>http://yoursite.com/2016/08/01/浅谈CoordinatorLayout/</id>
    <published>2016-08-01T14:24:32.000Z</published>
    <updated>2017-07-28T13:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>最近这一周空余的时间比较多，然后去重构了一个公司项目里的一个个人中心的页面，原来使用了<code>ListView</code>再加上<code>addHead</code>的方式，然后动态的去控制<code>Head</code>的高度去实现嵌套滑动的效果，因为我的模拟器没有跑起来，所以也没有去录下个GIF来，因为这篇主要说一下<code>CoordinatorLayout</code>的处理嵌套滑动的原理，没有效果图也影响不大。<a id="more"></a></p>
<h4 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h4><p>先写出来点大纲吧：</p>
<ul>
<li>为什么要有<code>CoordinatorLayout</code> </li>
<li><code>CoordinatorLayout</code>是怎么实现嵌套滑动的事件分发的</li>
<li><code>AppBarLayout</code>的一些东西</li>
</ul>
<h4 id="为什么要有CoordinatorLayout"><a href="#为什么要有CoordinatorLayout" class="headerlink" title="为什么要有CoordinatorLayout"></a>为什么要有<code>CoordinatorLayout</code></h4><p>先来回想一下<code>Android</code>系统的事件分发有什么不足的地方，就是一个<code>view</code>消费了事件，与此同时，其他的<code>view</code>的没有机会去接触到这个事件了。也就是在一个事件的某一时刻，有且只有一个<code>View</code>去相应这个事件。那么当我们要去做一些嵌套滑动的时候，就会有一些不方便。例如需要一个<code>View</code>跟随另一个<code>View</code>滑动，一般就是一个<code>CallBack</code>进行滑动状态的回调。<code>CoordinatorLayout</code>就可以比较优雅的处理这种事件。</p>
<h4 id="CoordinatorLayout是怎么实现嵌套滑动的事件分发的"><a href="#CoordinatorLayout是怎么实现嵌套滑动的事件分发的" class="headerlink" title="CoordinatorLayout是怎么实现嵌套滑动的事件分发的"></a><code>CoordinatorLayout</code>是怎么实现嵌套滑动的事件分发的</h4><p>先说一下两个接口吧，<code>NestedScrollingParent</code>和<code>NestedScrollingChild</code>，这两个接口看名字就比较容易理解他们的作用，就是一个给嵌套滑动的parent实现的，一个是给child实现，在现在的组件中，只有<code>CoordinatorLayout</code>实现了parent，所以下面说到parent就理解成<code>CoordinatorLayout</code>就OK啦，而child这个接口其实方法已经在<code>View</code>这个类里面帮我们实现好了，也就是说想要去成为一个可以嵌套滑动的child，仅仅去实现这个child接口就OK了，其他的<code>View</code>已经帮你写完了。下面还是以<code>RecycleView</code>为例子，它是实现了这个child的接口，还是回到情景里面说吧，说一下到底是怎么传递事件的。</p>
<ul>
<li>在<code>ReclceView</code>上down -&gt; <code>parent.onStartNestedScroll</code> -&gt;遍历有<code>Behavior</code>的直接子view -&gt;child的<code>Behavior.onStartNestedScroll</code>。<br>这里说一下<code>onStartNestedScroll</code>这个方法是有boolean的返回值，<code>true</code>的意思是要去处理这个事件，同时还会去调用<code>parent.onNestedScrollAccepted</code> -&gt; 遍历有<code>Behavior</code>的直接子view  -&gt;child的<code>Behavior.onNestedScrollAccepted</code>.这个方法里面可以做一些view配置的初始化。如果不需要当然可以不去重写。</li>
<li>在<code>RecycleView</code>上move -&gt; <code>dispatchNestedPreScroll</code>(也是child这个接口里面的)-&gt;<code>parent.onNestedPreScroll</code> -&gt; 遍历有<code>Behavior</code>的直接子view  -&gt;child的<code>Behavior.onNestedPreScroll</code>,同时之后还有一个流程也是在move的时候触发的 -&gt;<code>dispatchNestedScroll</code>(也是child这个接口里面的) -&gt;<code>parent.onNestedScroll</code> -&gt; 遍历有<code>Behavior</code>的直接子view  -&gt;child的<code>Behavior.onNestedScroll</code>.。这两个的主要区别的pre那个方法里面可以去处理消费了多少的滑动距离，比如手指滑动了12px,你可以选择把consumed[1]赋值为2，那么head就移动(消费)了2px，剩下的10px就给了下面的recycleview，而在<code>onNestedScroll</code>方法中还有机会去已经消费的和没有消费的距离再进行一次处理。</li>
<li>在<code>RecycleView</code>上面up -&gt; <code>stopNestedScroll</code>(也是child这个接口里面的) -&gt;<code>parent.onStopNestedScroll</code> -&gt; 遍历有<code>Behavior</code>的直接子view  -&gt;child的<code>Behavior.onStopNestedScroll</code>。</li>
<li>还有两个关于<code>Fling</code>的方法，就不说了，一个套路。</li>
</ul>
<p>还有就是再说一下<code>CoordinatorLayout</code>的<code>onInterceptTouchEvent</code>和<code>onTouchEvent</code>，这里贴一下代码吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">       <span class="keyword">final</span> View child = topmostChildList.get(i);</div><div class="line">       <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line">       <span class="keyword">final</span> Behavior b = lp.getBehavior();</div><div class="line"></div><div class="line">       <span class="keyword">if</span> ((intercepted || newBlock) &amp;&amp; action != MotionEvent.ACTION_DOWN) &#123;</div><div class="line">           <span class="comment">// Cancel all behaviors beneath the one that intercepted.</span></div><div class="line">           <span class="comment">// If the event is "down" then we don't have anything to cancel yet.</span></div><div class="line">           <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">if</span> (cancelEvent == <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">                   cancelEvent = MotionEvent.obtain(now, now,</div><div class="line">                           MotionEvent.ACTION_CANCEL, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0</span>);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">switch</span> (type) &#123;</div><div class="line">                   <span class="keyword">case</span> TYPE_ON_INTERCEPT:</div><div class="line">                       b.onInterceptTouchEvent(<span class="keyword">this</span>, child, cancelEvent);</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">                   <span class="keyword">case</span> TYPE_ON_TOUCH:</div><div class="line">                       b.onTouchEvent(<span class="keyword">this</span>, child, cancelEvent);</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!intercepted &amp;&amp; b != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">switch</span> (type) &#123;</div><div class="line">               <span class="keyword">case</span> TYPE_ON_INTERCEPT:</div><div class="line">                   intercepted = b.onInterceptTouchEvent(<span class="keyword">this</span>, child, ev);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               <span class="keyword">case</span> TYPE_ON_TOUCH:</div><div class="line">                   intercepted = b.onTouchEvent(<span class="keyword">this</span>, child, ev);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (intercepted) &#123;</div><div class="line">               mBehaviorTouchView = child;</div><div class="line">           &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>可以看出，每个直接的childview都会接受到拦截事件，即使你的手势不是在这个child上面触发的。</p>
<ul>
<li>还有个方法就是<code>layoutDependsOn</code>这个方法是在哪里调用的，这个是在onpredraw的时候就调用了，也就是没显示之前就已经开始准备各个view直接的依赖关系。当然内部实现也是在parent里面去便利child来实现的，也就只有parent可以获取到所有的child。</li>
</ul>
<h4 id="AppBarLayout的一些东西"><a href="#AppBarLayout的一些东西" class="headerlink" title="AppBarLayout的一些东西"></a><code>AppBarLayout</code>的一些东西</h4><p>我觉得<code>AppBarLayout</code>这个组件还是十分重要的，特别是里面的两个<code>Behavior</code>的实现，给了我们很好的参考的例子。具体的还是去看源码吧，太多了要说也是再开一篇。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;最近这一周空余的时间比较多，然后去重构了一个公司项目里的一个个人中心的页面，原来使用了&lt;code&gt;ListView&lt;/code&gt;再加上&lt;code&gt;addHead&lt;/code&gt;的方式，然后动态的去控制&lt;code&gt;Head&lt;/code&gt;的高度去实现嵌套滑动的效果，因为我的模拟器没有跑起来，所以也没有去录下个GIF来，因为这篇主要说一下&lt;code&gt;CoordinatorLayout&lt;/code&gt;的处理嵌套滑动的原理，没有效果图也影响不大。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
</feed>
