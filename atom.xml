<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>70kg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-23T00:19:32.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>70kg</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tinker补丁构建走读</title>
    <link href="http://yoursite.com/2017/05/23/Tinker%E8%A1%A5%E4%B8%81%E6%9E%84%E5%BB%BA%E8%B5%B0%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/05/23/Tinker补丁构建走读/</id>
    <published>2017-05-23T00:18:44.000Z</published>
    <updated>2017-05-23T00:19:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tinker简单问答"><a href="#Tinker简单问答" class="headerlink" title="Tinker简单问答"></a>Tinker简单问答</h2><h4 id="为什么要替换-Application"><a href="#为什么要替换-Application" class="headerlink" title="为什么要替换 Application"></a>为什么要替换 Application</h4><p>看上一篇和 Instant Run 的对比，可能考虑不全</p>
<ul>
<li>确保 Multidex 开启</li>
<li>保证应用 Application 类可修复</li>
<li>7.0 混合编译的影响，要去替换掉原始 PathClassLoader 的加载功能<a id="more"></a></li>
</ul>
<h4 id="为什么还要在-dexElements-前面插入而不是直接替换？"><a href="#为什么还要在-dexElements-前面插入而不是直接替换？" class="headerlink" title="为什么还要在 dexElements 前面插入而不是直接替换？"></a>为什么还要在 dexElements 前面插入而不是直接替换？</h4><p>因为 Tinker 是全量合成 dex ，比如在补丁前dex顺序是这样的：oldDex1 -&gt; oldDex2 -&gt; oldDex3..，那么假如修改了dex1中的文件，那么补丁顺序是这样的newDex1 -&gt; oldDex1 -&gt; oldDex2… 那为什么不直接使用newDex1去替换调oldDex呢？我觉得:</p>
<ul>
<li>运行期去替换调正在使用的dex是有风险的(也是我瞎猜)</li>
<li>考虑到版本回退和以后的增量升级，在前面插入确实比替换更加方便安全</li>
</ul>
<h2 id="Tinker补丁构建走读"><a href="#Tinker补丁构建走读" class="headerlink" title="Tinker补丁构建走读"></a>Tinker补丁构建走读</h2><p>Tinker的补丁加载网上资料很多了，读起来也没太大难度，这里就不多说了。关于补丁构建的整个过程倒是不多，这里简单走读一下。</p>
<h4 id="TinkerPatchSchemaTask"><a href="#TinkerPatchSchemaTask" class="headerlink" title="TinkerPatchSchemaTask"></a>TinkerPatchSchemaTask</h4><p>关于代码的变动  dex的patch  资源的patch</p>
<p>这个 Task 主要是用于 oldApk和 newApk 的差分，生成patch，包括dex,res,so的差分，主要起作用的类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ManifestDecoder manifestDecoder;<span class="comment">//检测是否增加了四大组件  关于dexMode的检测提示</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UniqueDexDiffDecoder dexPatchDecoder;<span class="comment">//dex 的patch</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BsDiffDecoder soPatchDecoder;<span class="comment">//so 的patch</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResDiffDecoder resPatchDecoder;<span class="comment">//资源的patch</span></div></pre></td></tr></table></figure>
<p>这个 Task 也是最关键的，可以从 <code>ApkDecoder</code> 这个类开始，首先会先把两个apk解压到<code>build/outputs/tinkerPatch/{variant}/apkName</code>目录下，在打patch 过程中<code>tinkerPatch</code> 目录下会生成很多过程文件，类似最终的patch apk,用于查看资源合成结果的 <code>resources_out.zip</code>，还有一下log.txt。关键的patch从</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Files.walkFileTree(mNewApkDir.toPath(), <span class="keyword">new</span> ApkFilesVisitor(config, mNewApkDir.toPath(), mOldApkDir.toPath(), dexPatchDecoder, soPatchDecoder, resPatchDecoder));</div></pre></td></tr></table></figure>
<p>这里开始，遍历newApk解压后的目录，根据<code>Pattern</code>去匹配使用上面四个中哪个<code>Decoder</code>去处理这两个新旧文件。</p>
<ul>
<li>dex查分</li>
</ul>
<p>从<code>UniqueDexDiffDecoder dexPatchDecoder;</code>处理dex开始，这里假如我们oldApk只有一个classes.dex,来到<code>DexDiffDecoder.patch</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不是为了对比 是为了检查dex的一些规则</span></div><div class="line">           excludedClassModifiedChecker.checkIfExcludedClassWasModifiedInNewDex(oldFile, newFile);</div></pre></td></tr></table></figure>
<p>这里去检查一下第一个dex中的一些限制，例如tinker的一些loader类一定要在第一个dex中等限制。<br>如果新增了一个dex<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//new add file 在new apk中多了一个dex 直接复制</span></div><div class="line">        <span class="keyword">if</span> (oldFile == <span class="keyword">null</span> || !oldFile.exists() || oldFile.length() == <span class="number">0</span>) &#123;</div><div class="line">            hasDexChanged = <span class="keyword">true</span>;</div><div class="line">            copyNewDexAndLogToDexMeta(newFile, newMd5, dexDiffOut);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>然后正常的修改了dex</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Before starting real diff works, we collect added class descriptor</div><div class="line">     * and deleted class descriptor for further analysing in &#123;<span class="doctag">@code</span> checkCrossDexMovingClasses&#125;.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectAddedOrDeletedClasses</span><span class="params">(File oldFile, File newFile)</span></span></div></pre></td></tr></table></figure>
<p>把对应的dex保存在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// collect current old dex file and corresponding new dex file for further processing.</span></div><div class="line">       oldAndNewDexFilePairList.add(<span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(oldFile, newFile));</div></pre></td></tr></table></figure></p>
<p>然后走到<code>dexPatchDecoder.onAllPatchesEnd();//开始生成 保存patch文件</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (config.mIsProtectedApp) &#123;<span class="comment">//仅仅在加固的时候使用 只将变化的类合成补丁</span></div><div class="line">            generateChangedClassesDexFile();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            generatePatchInfoFile();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>然后来到这个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">            DexPatchGenerator dexPatchGen = <span class="keyword">new</span> DexPatchGenerator(oldDexFile, newDexFile);</div><div class="line">            dexPatchGen.setAdditionalRemovingClassPatterns(config.mDexLoaderPattern);<span class="comment">//查分时候排除dex.loader闭包中的类</span></div><div class="line"></div><div class="line">            logWriter.writeLineToInfoFile(</div><div class="line">                    String.format(</div><div class="line">                            <span class="string">"Start diff between [%s] as old and [%s] as new:"</span>,</div><div class="line">                            getRelativeStringBy(oldDexFile, config.mTempUnzipOldDir),</div><div class="line">                            getRelativeStringBy(newDexFile, config.mTempUnzipNewDir)</div><div class="line">                    )</div><div class="line">            );</div><div class="line"></div><div class="line">            dexPatchGen.executeAndSaveTo(dexDiffOut);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerPatchException(e);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>这里就是具体的dexDiff算法了，我也看不懂，就当个黑盒，反正会生产处一个查分dex保存，然后后面还会在合成一个全量dex用来查看，保存一下log日志之类的，大致的dex查分就完成了。</p>
<ul>
<li>res 查分<br>回到遍历newApk目录的地方，还是根据<code>Pattern</code>去匹配资源文件，在这个方法中进行查分</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//处理修改的资源</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dealWithModeFile</span><span class="params">(String name, String newMd5, File oldFile, File newFile, File outputFile)</span></span></div></pre></td></tr></table></figure>
<p>还是使用了BSD进行差分，输出log，修改的文件复制到tinker_result的目录下。然后到<code>onAllPatchesEnd</code>，和dex一样，还是会生成全量的<code>resources_out.zip</code>去查看合成结果，还有log输出。</p>
<ul>
<li>so查分<br>这个也是使用了BSD查分，没太多好说的。</li>
</ul>
<h4 id="TinkerManifestTask"><a href="#TinkerManifestTask" class="headerlink" title="TinkerManifestTask"></a>TinkerManifestTask</h4><p>自动添加/修改tinker_id，运行时检查补丁版本</p>
<h4 id="TinkerResourceIdTask"><a href="#TinkerResourceIdTask" class="headerlink" title="TinkerResourceIdTask"></a>TinkerResourceIdTask</h4><p>R.txt 的保存 ids.xml public.xml的处理，用于处理资源改变时ID变动问题，将基础包的R.txt处理成ids.xml，public.xml，保存到<code>intermediates/res/merged/{variant}/values/</code>下，用于打包时候的资源ID分配。保证资源ID的不变动。</p>
<h4 id="TinkerProguardConfigTask"><a href="#TinkerProguardConfigTask" class="headerlink" title="TinkerProguardConfigTask"></a>TinkerProguardConfigTask</h4><p>混淆的处理，主要的作用是将tinker中默认的混淆信息和基准包的mapping信息加入混淆列表。</p>
<h4 id="TinkerMultidexConfigTask"><a href="#TinkerMultidexConfigTask" class="headerlink" title="TinkerMultidexConfigTask"></a>TinkerMultidexConfigTask</h4><p>主要将dex.loader中配置的class也keep进main dex.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Tinker简单问答&quot;&gt;&lt;a href=&quot;#Tinker简单问答&quot; class=&quot;headerlink&quot; title=&quot;Tinker简单问答&quot;&gt;&lt;/a&gt;Tinker简单问答&lt;/h2&gt;&lt;h4 id=&quot;为什么要替换-Application&quot;&gt;&lt;a href=&quot;#为什么要替换-Application&quot; class=&quot;headerlink&quot; title=&quot;为什么要替换 Application&quot;&gt;&lt;/a&gt;为什么要替换 Application&lt;/h4&gt;&lt;p&gt;看上一篇和 Instant Run 的对比，可能考虑不全&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保 Multidex 开启&lt;/li&gt;
&lt;li&gt;保证应用 Application 类可修复&lt;/li&gt;
&lt;li&gt;7.0 混合编译的影响，要去替换掉原始 PathClassLoader 的加载功能
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>由View.post引发的问题</title>
    <link href="http://yoursite.com/2017/05/14/%E7%94%B1View-post%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/05/14/由View-post引发的问题/</id>
    <published>2017-05-14T12:31:42.000Z</published>
    <updated>2017-05-14T12:36:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到<a href="http://www.jianshu.com/p/571e9b4f4b89" target="_blank" rel="external">记一次错误的使用View.post(Runnable)</a>这篇的时候，自己去实验了一下，当时是在 Activity 的 onDestory 中做的，以为到了 onDestory View 肯定是 Detach 的，结果并不是这样的。。后来发现在 API 24的时候，关于 View.Post 这部分的代码有重写，所有就捋了捋关于这部分的东西，简单记录一下。<a id="more"></a></p>
<h4 id="View-Detach"><a href="#View-Detach" class="headerlink" title="View Detach"></a>View Detach</h4><p>View 什么时候才会 Detach ？当 View 中 mAttachInfo 这个变量置空的时候，就 Detach 了，是在 dispatchDetachedFromWindow 这个方法中置空的，这方法是在 ViewRootImpl.dispatchDetachedFromWindow() 中调用的，ViewRootImpl 可以看做是在 View 和 WindowManager 中间一个类 ，WMS 通过 IWindow 进行 ipc 通信控制通知客户端的 WindowManager， WindowManager 还要稍微使用 WindowManagerGlobal 中转处理一下，然后再去调用 ViewRootImpl 中的一些方法，而 ViewRootImpl 是持有 DecorView ，DecorView 中又有 WindowCallBack ，其实就是 Activity ,因为 Activity 实现了 WindowCallBack。这样再去调用 Activity 中关于 Window 相关的回调。回到问题，什么时候Detach？ 当然还是在 Activity 销毁的时候，简单说下情形，A 启动 B ,在 B 中调用 finish。B finish-&gt; B onPause-&gt;A onResume-&gt;B onStop-&gt;B onDestroy-&gt;B onDetachedFromWindow 。大致的流程是ActivityManagerNative通知AMS,AMS通过IApplicationThread调用ActivityThread.H去sendMessage，然后再去ActivityThread某个类似performPauseActivity，然后Instrumentation，然后就是activity生命周期。在最后调用handleDestroyActivity中，先调用ondestory 然后调用wm的removeViewImmediate，[ActivityThread.handleDestroyActivity() –&gt;<br>WindowManager.removeViewImmediate() –&gt;<br>WindowManagerGlobal.removeViewLocked()方法 —&gt;<br>ViewRootImpl.die() –&gt; doDie() –&gt;<br>ViewRootImpl.dispatchDetachedFromWindow()],这个时候view.attachInfo 置空，所以当回调 Activity 的 onDestory 的时候，还没去调用 dispatchDetachedFromWindow ，当然还没 Detach 。关于 View 什么时候 Attached ，是在 onResume 之后，具体就不说了，和上面差不多。</p>
<h4 id="View-post"><a href="#View-post" class="headerlink" title="View.post"></a>View.post</h4><p>说一下现象，当在 Attached 的时候，使用 View.post 就是走 handler 那一套，使用的 handelr 是 ViewRootImpl 中的 ViewRootHandler ，looper 就是 mainLooper ，这个没什么好分析的，这个时候怎么post都是有回调的。当在 Detach 的时候，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</div><div class="line">        <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> attachInfo.mHandler.post(action);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></div><div class="line">        <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></div><div class="line">        getRunQueue().post(action);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>走下面的 <code>getRunQueue().post(action);</code> 这个在24 以前 看开头那篇分析，是用 ThreadLocal 来进行的线程隔离，在 24 的时候，getRunQueue 变成了view的私有变量 mRunQueue:HandlerActionQueue ,当post 到这个里面去的时候，基本上是不会在调用了，因为它的 <code>mRunQueue.executeActions(info.mHandler);</code>是在 <code>dispatchAttachedToWindow</code> 中调用的。。一个activity生命周期只会调一次，也基本上用不到什么自行车了。。</p>
<h4 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h4><p>看下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.onDestroy();</div><div class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">              button.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                  <span class="meta">@Override</span></div><div class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                      Log.e(<span class="string">"ssssss"</span>, <span class="string">"onDestroy"</span>);</div><div class="line">                  &#125;</div><div class="line">              &#125;);</div><div class="line">          &#125;</div><div class="line">      &#125;).start();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里面的Log会不会调用？？说实话，看缘分。。。不信自己去试试</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到&lt;a href=&quot;http://www.jianshu.com/p/571e9b4f4b89&quot;&gt;记一次错误的使用View.post(Runnable)&lt;/a&gt;这篇的时候，自己去实验了一下，当时是在 Activity 的 onDestory 中做的，以为到了 onDestory View 肯定是 Detach 的，结果并不是这样的。。后来发现在 API 24的时候，关于 View.Post 这部分的代码有重写，所有就捋了捋关于这部分的东西，简单记录一下。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Instant-Run与Tinker中Application替换</title>
    <link href="http://yoursite.com/2017/05/08/Instant-Run%E4%B8%8ETinker%E4%B8%ADApplication%E6%9B%BF%E6%8D%A2/"/>
    <id>http://yoursite.com/2017/05/08/Instant-Run与Tinker中Application替换/</id>
    <published>2017-05-08T14:58:02.000Z</published>
    <updated>2017-05-16T01:02:21.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>为什么要替换application</li>
</ul>
<p>因为5.0以下开始只会去加载第一个dex,如果appliaction不在第一个dex,则无法启动。如果把自己的appliaction放在第一个dex中，而自己的application没有使用multidex,则只会去加载原始加载生成的dex,也是会报错。所以办法就是去代理掉原始的application，将app启动的application设置为这个代理的application，在这个代理的application中可以确保使用multidex功能。</p>
<p>还有因为补丁是在appliaction中加载，这样会导致无法对appliaction的修复，还有因为 Android N 的混合编译的影响 ，Tinker 使用了类似 Instant-run 中 IncrementalClassLoader （具体实现过程还是有差距），新建一个classLoader，去 “替换”掉原始的 PathClassLoader 去加载所有dex。这些都需要在appliaction中进行修改。<br><a id="more"></a></p>
<ul>
<li>替换操作的差异</li>
</ul>
<p>Instant run 是在attachBaseContext的时候再去反射创建原始的application，然后再反射替换掉Framework中已经初始化的application(这个时候还是代理的application),还原回去我们原始的application。接下来就是正常的流程，在app中去get application也不会有问题。</p>
<p>Tinker使用的是静态代理，使用代理方案代码会更复杂一些，因为要去模拟出一个applicationLike的接口，在tinker中，我们真正的application只需要实现这个接口，并不需要去继承Android中的application，因为会在代理的application中反射调用我们的application生命周期方法。也就是说tinker中只有一个真正的application。</p>
<ul>
<li>优缺点</li>
</ul>
<p>在instant run中application的替换的透明的，两个application都是真正的Android application。好处就是透明，坏处也是使用了反射替换运行期的application，兼容性不如静态代理好，类似tinker中反射插入dex就分了好多个版本实习，这个会更复杂。tinker更加稳定。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;为什么要替换application&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为5.0以下开始只会去加载第一个dex,如果appliaction不在第一个dex,则无法启动。如果把自己的appliaction放在第一个dex中，而自己的application没有使用multidex,则只会去加载原始加载生成的dex,也是会报错。所以办法就是去代理掉原始的application，将app启动的application设置为这个代理的application，在这个代理的application中可以确保使用multidex功能。&lt;/p&gt;
&lt;p&gt;还有因为补丁是在appliaction中加载，这样会导致无法对appliaction的修复，还有因为 Android N 的混合编译的影响 ，Tinker 使用了类似 Instant-run 中 IncrementalClassLoader （具体实现过程还是有差距），新建一个classLoader，去 “替换”掉原始的 PathClassLoader 去加载所有dex。这些都需要在appliaction中进行修改。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Express + React 搭建简易web微博</title>
    <link href="http://yoursite.com/2017/03/02/%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93web%E5%BE%AE%E5%8D%9A/"/>
    <id>http://yoursite.com/2017/03/02/搭建简易web微博/</id>
    <published>2017-03-02T00:47:52.000Z</published>
    <updated>2017-05-08T15:08:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写点东西了，最近找了点时间玩了玩这两个东西，写了个简单的web微博，因为js的跨域问题，所以只能使用Node来中转一下，这样玩法也更丰富，随便处理数据。目前还只能看。但愿我有时间继续玩下去，感觉前端还挺好玩的。<a id="more"></a></p>
<p>Git地址在下面。其他的懒得写了，其实没什么难度，这篇是用于充数的，说明我还没忘记写东西。<br><a href="https://coding.net/u/70kg/p/express/git" target="_blank" rel="external">Express</a><br><a href="https://coding.net/u/70kg/p/React/git" target="_blank" rel="external">React</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没写点东西了，最近找了点时间玩了玩这两个东西，写了个简单的web微博，因为js的跨域问题，所以只能使用Node来中转一下，这样玩法也更丰富，随便处理数据。目前还只能看。但愿我有时间继续玩下去，感觉前端还挺好玩的。
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》笔记</title>
    <link href="http://yoursite.com/2016/12/31/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/12/31/《深入理解Java虚拟机》笔记/</id>
    <published>2016-12-31T08:54:38.000Z</published>
    <updated>2017-02-03T10:54:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动内存管理机制"><a href="#自动内存管理机制" class="headerlink" title="自动内存管理机制"></a>自动内存管理机制</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul>
<li>通过改变这个计数器的指决定执行的下一条指令</li>
<li>线程私有 每条线程独立</li>
<li>不会 oom <a id="more"></a><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3>存放基本类型和引用和   returnAddress类型(指向了一条字节码指令的地址）<br>描述 Java 方法执行的内存模型<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3></li>
<li>存放对象实例</li>
<li>线程共享，内存最大</li>
<li>GC 的主要区域</li>
<li>基于分代回收，大致分为新生代和老年代<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3></li>
<li>线程共享</li>
<li>类信息，常量，静态变量<h2 id="虚拟机对象"><a href="#虚拟机对象" class="headerlink" title="虚拟机对象"></a>虚拟机对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3>new指令的参数是否能在常量池中定位到一个类的符号引用-&gt;是否已经加载，解析初始化-&gt;分配内存(指针碰撞，空闲列表)-&gt;初始化为零值-&gt;为对象进行必要设置-&gt;&lt; init &gt; 方法。(ps：new 关键字其实为new和init两个方法)</li>
</ul>
<h3 id="对象的内存分布"><a href="#对象的内存分布" class="headerlink" title="对象的内存分布"></a>对象的内存分布</h3><ul>
<li>对象头<br>1.分用于存储对象自身的运行时数据,e.g.哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时 间戳等<br>2.类型指针,对象指向它的类元数据的指针,虚拟机通过这个指 针来确定这个对象是哪个类的实例.</li>
<li>实例数据</li>
<li>对其填充</li>
</ul>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>使用栈上的引用去操作堆上的实例。</p>
<ol>
<li>句柄<br>在堆中有一块内存区域作为句柄池，栈中的引用存储的是对象的句柄地址，句柄中包括对象的实例数据(实例池)和类型数据(方法区)。<br>好处：GC 时只会改变句柄中实例指针，不会影响栈中的指向。<ol>
<li>直接指针<br>栈中的引用直接指向对象地址。<br>好处：速度快，省一次指针定向</li>
</ol>
</li>
</ol>
<p>ps: <code>String.intern</code>的问题 <a href="http://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="external">点这里</a></p>
<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p>先标记需要回收的对象，然后统一回收。缺点是效率不高，会产生内存碎片问题。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>1：1分割内存，只用一半，回收时把存活的复制到另一半，清除原来一半。<br>实际使用在新生代，适合回收频率高的。朝生夕死。每次清理都有大量对象死亡。<code>HotSpot</code>默认为8:1:1,浪费10%的内存空间，使用8和1，当回收时候，复制到另一个1中。空间不够时候，需要依赖老年代。</p>
<h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h3><p>先标记，把存活的移动到一端，清除。适合老年代</p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>通过使用一组<code>OopMap</code>的数据结构知道哪些地方存放对象引用。在类加载完成时，<code>HotSpot</code>就把对象内什么偏移量上是什么类型的数据计算出来，在<code>JIT</code>编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，这样GC扫描时就可以直接得知。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>上面特定的位置是安全点，只有在安全点处暂停。主要使用主动式中断让所有线程都跑到安全点再停顿。不直接对线程操作，设置一个标志，各个线程主动去轮训，发现中断标志true就自己中断挂起。</p>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全区域用来解决在程序没有CPU时间，例如线程sleep或者block的时候进入GC。安全区域是指在一段代码之后，引用关系不会发生变化，在这个区域任何地方GC都是安全的。当程序执行到安全区域，首先标识进入，然后GC可以随时进行。当程序要离开安全区域时，先去检查GC是否完成，是-&gt;继续执行，否-&gt;等待完成。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>最基本最久远的收集器，单线程,STW。没有线程切换的开销，简单。复制算法</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>Serial收集器的多线程版本。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>和ParNew收集器类似，关注吞吐量</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial收集器的的老年代版本。标记-整理</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Scavenge收集器的老年代版本，标记-整理。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）<br>1，3步骤STW。1只标记GC roots能直接关联对象，很快。并发标记阶段就是进行GC RootsTracing 的过程,而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变 动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远 比并发标记的时间短。整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作<img src="http://7xjlmz.com1.z0.glb.clouddn.com/Java%E8%99%9A%E6%8B%9F%E6%9C%BAcms.png" alt=""><br>优点：<br>并发收集，低停顿<br>缺点：<br>对CPU资源敏感，默认回收线程(cpu数量+3)/4<br>cms无法处理”浮动垃圾”（当并发收集同时产生的垃圾）<br>标记-清除算法内存碎片问题</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>特点：</p>
<ul>
<li>分代收集</li>
<li>并行与并发</li>
<li>空间整合</li>
<li>可预测的停顿<br>将整个Java堆划分 为多个大小相等的独立区域(Region)<br>大致过程：<ol>
<li>初始标记(Initial Marking)</li>
<li>并发标记(Concurrent Marking)</li>
<li>最终标记(Final Marking)</li>
<li>筛选回收(Live Data Counting and Evacuation)<br>4-&gt;筛选回收阶段首先对各个Region的回收价值和成本进行排序, 根据用户所期望的GC停顿时间来制定回收计划</li>
</ol>
</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下,对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时,虚拟 机将发起一次Minor GC</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对 象年龄(Age)计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活,并且能被 Survivor容纳的话,将被移动到Survivor空间中,并且对象年龄设为1。对象在Survivor区中 每“熬过”一次Minor GC,年龄就增加1岁,当它的年龄增加到一定程度(默认为15岁),就 将会被晋升到老年代中。</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>如果在Survivor空间中相同年龄所有对象大小的总 和大于Survivor空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代,无须等 到MaxTenuringThreshold中要求的年龄。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC之前,虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有 对象总空间,如果这个条件成立,那么Minor GC可以确保是安全的。如果不成立,则虚拟机 会查看HandlePromotionFailure设置值是否允许担保失败。如果允许,那么会继续检查老年代 最大可用的连续空间是否大于历次晋升到老年代对象的平均大小,如果大于,将尝试着进行 一次Minor GC,尽管这次Minor GC是有风险的;如果小于,或者HandlePromotionFailure设置 不允许冒险,那这时也要改为进行一次Full GC。</p>
<h1 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h1><p>略</p>
<h1 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h1><p>略</p>
<h1 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h1><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>Class文件格式采用一种类似C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表<br>无符号数属于基本类型，有u1,u2,u4,u8表示几个字节，可以用来描述数字，索引引用，数据值或者按照UTF-8编码的字符串<br>表是由多个无符号数或者其他表作为数据结构的复合数据结构，表习惯以_info结尾。<br>整个Class本质上就是一个表<br>Class文件格式：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt=""></p>
<h3 id="魔数-u4"><a href="#魔数-u4" class="headerlink" title="魔数 u4"></a>魔数 u4</h3><p><code>0xCAFFBABE</code></p>
<h3 id="次版本号-u2"><a href="#次版本号-u2" class="headerlink" title="次版本号 u2"></a>次版本号 u2</h3><h3 id="主版本号-u2"><a href="#主版本号-u2" class="headerlink" title="主版本号 u2"></a>主版本号 u2</h3><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>u2的常量池大小 index从1开始，第0项空出<br>常量池中主要存放两大类常亮：字面量和符号引用<br>字面量类似Java的常量<br>符号引用包括：</p>
<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ol>
<p>常量池中每一项都是一个表(都对应一个Class)。一共14种表，表开始的第一位u1代表当前这个常量属于哪种常量类型<br>具体如下：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%B1%BB%E5%9E%8B.jpg" alt=""></p>
<h3 id="访问标志-u2"><a href="#访问标志-u2" class="headerlink" title="访问标志 u2"></a>访问标志 u2</h3><p>用于标识一些类或者接口成次的访问信息<br>具体如下：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.jpg" alt=""></p>
<h3 id="类索引、父类索引与接口索引集合-u2-u2-List"><a href="#类索引、父类索引与接口索引集合-u2-u2-List" class="headerlink" title="类索引、父类索引与接口索引集合 u2,u2,List"></a>类索引、父类索引与接口索引集合 u2,u2,List<u2></u2></h3><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>用于描述接口或类中的变量<br>字段包括类级变量(static)和实例级变量 不包括方法内部的局部变量</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>对方法的描述</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>用于描述某些场景专用信息。下面的必备的9个属性:<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E5%B1%9E%E6%80%A7%E8%A1%A8.png" alt=""></p>
<h4 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h4><p>简单理解就是方法体,具体的结构如下：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class_code%E5%B1%9E%E6%80%A7.jpg" alt=""></p>
<p>Code属性是Class文件中最重要的属性，如果把Java程序中信息分为代码（Code）和元数据(类，字段，方法定有以及其他信息)两部分。Code属性属于描述代码，所有的其他数据项目都用于描述元数据</p>
<h2 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h2><h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><p>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输<br>Tload -&gt; 将一个局部变量加载到操作栈<br>Tstore -&gt; 将一个数值从操作数栈存储到局部变量表<br>Tipush -&gt; 将一个变量加载到操作数栈<br>wide -&gt; 扩充局部变量表的访问索引指令</p>
<h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><p>用于对两个操作数栈上的值进行某种特定的运算，并把结果重新存入到操作栈顶。<br>算术运算大致分为对整形数据进行运算的指令和对浮点数进行运算的指令</p>
<p>加法指令 ：Tadd<br>减法指令: Tsub<br>乘法指令： Tmul<br>除法指令：Tdiv<br>求余指令：Trem<br>取反指令：Tneg<br>位移指令：Tshl,Tshr,Tushr<br>按位或指令：Tor<br>按位与指令：Tand<br>按位异或指令：Txor<br>局部变量自增指令：Tinc<br>比较指令：Tcmpg,Rcmpl</p>
<h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><p>用于将两种不同的数值类型进行相互转换，一般用于实现用户代码中的显式类型转换或者用于处理字节码指令集中数据类型相关指令无法一一对应的问题<br>i2b,i2c…</p>
<h3 id="对象创建和访问指令"><a href="#对象创建和访问指令" class="headerlink" title="对象创建和访问指令"></a>对象创建和访问指令</h3><p>Java虚拟机对类实例和数组的创建于操作用了不同的字节码指令。<br>创建类实例 -&gt; new<br>创建数组 -&gt; newarray,anewarray,multianewarray<br>访问类字段和实例字段 -&gt; getfield,putfield,getstatic,putstatic<br>把一个数组元素加载到操作数栈 -&gt; Taload<br>将一个操作数栈的值存储到数组元素中 -&gt;Tastore<br>取数组长度 -&gt; arraylength<br>检查类实例类型 -&gt; instanceof,checkcast</p>
<h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><p>直接操作操作数栈的指令<br>将操作数栈的栈顶一个或两个元素出栈 -&gt;pop,pop2<br>复制栈顶两个数值并将双份复制值从新压入栈顶 -&gt; dup2,dup2_x1,dup2_x2<br>栈顶两个数值交换 -&gt; swap</p>
<h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><p>条件分支，复合条件分支，无条件分支<br>各种类型的比较最终都会转化成int类型的比较操作，所以Java虚拟机提供的int类型的条件分支指令是最丰富和强大的</p>
<h3 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h3><p>invokevirtual -&gt;调用实例方法，最常见的<br>invokeinterface -&gt;调用接口方法，会在运行时搜索一个实现了这个接口方法的对象，找到合适的方法进行调用<br>invokespecial -&gt; 调用一些需要特殊处理的实例方法，包括实例初始化方法，私有方法和父类方法<br>invokestatic -&gt; 调用类方法<br>invokedynamic -&gt; 在运行时动态解析出调用点限定符所引用的方法，并执行该方法？？？？</p>
<p>方法调用指令与数据类型无关，返回指令是根据返回值的类型区分的.Treturn</p>
<h3 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h3><p>显示抛出异常(throw)都是由athrow指令实现。<br>处理异常不是由字节码指令实现的，采用异常表完成。</p>
<h3 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h3><p>支持方法级同步和方法内部一段指令序列的同步，是使用管程(Monitor)支持。</p>
<p>方法级的同步是隐式的,即无须通过字节码指令来控制,它实现在方法调用和返回操作 之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个 方法是否声明为同步方法。当方法调用时,调用指令将会检查方法的ACC_SYNCHRONIZED 访问标志是否被设置,如果设置了,执行线程就要求先成功持有管程,然后才能执行方法, 最后当方法完成(无论是正常完成还是非正常完成)时释放管程。在方法执行期间,执行线 程持有了管程,其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出 了异常,并且在方法内部无法处理此异常,那么这个同步方法所持有的管程将在异常抛到同 步方法之外时自动释放。</p>
<p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的,Java虚拟机的 指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义,正确实现 synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。</p>
<h1 id="Vim的简单快捷键"><a href="#Vim的简单快捷键" class="headerlink" title="Vim的简单快捷键"></a>Vim的简单快捷键</h1><p>这是在全咋会新加的一行<br>这是在全咋会新加的一行<br>这是在全咋会<br>复制先V 然后选择 y 复制  yy是复制整行 d是剪切 dd是剪切整行 p是粘贴<br>o 是在下面新开一行     O是在上面新开一行<br>x 是删除当前字符<br>a -&gt;在光标后面插入字符<br>0 -&gt;回到行头 $ 是到行尾<br>130G -&gt;跳转到130行</p>
<p>gg -&gt;到第一行<br>G -&gt; 到最后一行<br>w -&gt; 下一个单词开头 b-&gt; 上一个单词开头<br>e -&gt; 下一个单词结尾</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;自动内存管理机制&quot;&gt;&lt;a href=&quot;#自动内存管理机制&quot; class=&quot;headerlink&quot; title=&quot;自动内存管理机制&quot;&gt;&lt;/a&gt;自动内存管理机制&lt;/h1&gt;&lt;h2 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h2&gt;&lt;h3 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;通过改变这个计数器的指决定执行的下一条指令&lt;/li&gt;
&lt;li&gt;线程私有 每条线程独立&lt;/li&gt;
&lt;li&gt;不会 oom
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从零撸一个Redux</title>
    <link href="http://yoursite.com/2016/12/25/Redux-2/"/>
    <id>http://yoursite.com/2016/12/25/Redux-2/</id>
    <published>2016-12-25T13:53:53.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="扯一扯"><a href="#扯一扯" class="headerlink" title="扯一扯"></a>扯一扯</h4><p>这段时间在看 <code>Redux</code> 的东西，稍微梳理一下整个框架的流程。其实整个 <code>Redux</code> 的代码很少，现在我也不能理解很多它的思想，反正先撸出个简单的 <code>Redux</code> 吧。目标是照着它的流程写一个最简单的，也要支持异步 <code>Action</code>。也算是个笔记性的东西。<a id="more"></a></p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a><code>Action</code></h4><p>这里把 <code>Action</code> 放到了 <code>Store</code> 中，这样在 <code>Component</code> 中使用的时候只要导入 <code>store</code> 就可以，不用导入很多的 <code>Action</code>, <del>就是懒</del>。当然也可以使用 <code>React-Redux</code> 之类的进行绑定，但是这个库主要不是干这个的。。这个后面会提到一些。因为 <code>Actions</code> 都是提前定义的，所有写在了一个 <code>StoreConfig</code> 中，在创建 <code>Store</code> 的时候就可以把 <code>actions</code> 注入到 <code>Store</code> 中了。当然你也可以不这么做。先贴一下完整的代码吧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> createStore <span class="keyword">from</span> <span class="string">'./createStore'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> store = createStore(&#123;</div><div class="line">    <span class="comment">//把所有的action都放在了store中</span></div><div class="line">    actions: &#123;</div><div class="line">        <span class="comment">//同步的action</span></div><div class="line">        <span class="string">'printText'</span>: createRequest(<span class="function">(<span class="params">text</span>)=&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> &#123;<span class="attr">text</span>: text + <span class="string">"我想修改"</span>&#125;;</div><div class="line">        &#125;),</div><div class="line">        <span class="comment">//异步的action，async await可以看上一篇</span></div><div class="line">        <span class="string">'testAsync'</span>: createRequest(<span class="keyword">async</span>()=&gt; &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">await</span> Longtime();</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">initState</span>: &#123;&#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">//测试的代码不用说吧</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Longtime</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            resolve(&#123;<span class="attr">text</span>: <span class="string">'success'</span>&#125;);</div><div class="line">            <span class="comment">// reject('error');</span></div><div class="line">        &#125;, <span class="number">2000</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//这个是个actionCreater 之前有写过在项目中的使用 这里也不多说</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRequest</span>(<span class="params">actionCreator</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> finalActionCreator = <span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span></div><div class="line">        ? actionCreator</div><div class="line">        : <span class="function">(<span class="params">t</span>) =&gt;</span> t;</div><div class="line">    <span class="keyword">const</span> actionHandler = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">const</span> action = &#123;</div><div class="line">            <span class="attr">type</span>: actionHandler.toString()</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//真正的action都放在payload中，同步则是数据，异步是Promise。</span></div><div class="line">        <span class="keyword">const</span> payload = finalActionCreator(...args);</div><div class="line">        <span class="keyword">if</span> (!(payload === <span class="literal">null</span> || payload === <span class="literal">undefined</span>)) &#123;</div><div class="line">            action.payload = payload;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (action.payload <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</div><div class="line">            action.error = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> action;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> actionHandler;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</div></pre></td></tr></table></figure>
<h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a><code>Reducer</code></h4><p>这里的 <code>Reducer</code> 只创建了一个，就是直接把成功的数据更新到 <code>Store</code> 中，也没什么好看的，关于异步的 <code>Promise</code> 会在结果返回之后再去通知 <code>Reducer</code>去更新 <code>Store</code>，当然这就不是这个 <code>Reducer</code> 的工作了。代码很简单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">acceptSuccessActionReducer</span>(<span class="params">state, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!action.error &amp;&amp; action.payload) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, action.payload);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a><code>Store</code></h4><p>我觉得 <code>Redux</code> 的最重要的东西就是 <code>Store</code> 了。所有的 <code>Action</code> 都要经过 <code>Store</code> 分发，当结果返回之后也要通知 <code>Store</code> 去更新，<code>Component</code> 的数据也是从 <code>Store</code> 中获取。先贴一下 <code>CreateStore</code> 代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;handleActions&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</div><div class="line"><span class="keyword">import</span> &#123;applyMiddleware&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> promiseMiddleware <span class="keyword">from</span> <span class="string">'redux-promise'</span>;</div><div class="line"><span class="keyword">import</span> acceptSuccessActionReducer <span class="keyword">from</span> <span class="string">'../reducers/SuccessReducer'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> actions = config.actions;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> initState = config.initState;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> reducersDict = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="built_in">Object</span>.keys(actions).forEach(<span class="function"><span class="params">key</span>=&gt;</span> &#123;</div><div class="line">        <span class="keyword">var</span> action = actions[key];</div><div class="line">        action.toString = <span class="function"><span class="params">()</span>=&gt;</span>key;</div><div class="line">        reducersDict[key] = acceptSuccessActionReducer;<span class="comment">//将action与reducer绑定</span></div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//这个reducers应该是个类似arrays.reduce的function   果然--&gt; @see 'reduce-reducers'   what's means??</span></div><div class="line">    <span class="keyword">var</span> reducers = handleActions(reducersDict, initState);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> store = generateStore(reducers, applyMiddleware(promiseMiddleware));</div><div class="line"></div><div class="line">    store.actions = &#123;&#125;;</div><div class="line">    <span class="built_in">Object</span>.assign(store.actions, actions);</div><div class="line"></div><div class="line">    store.subscribe(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'这是修改后的===&gt;'</span>, store.getState());</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> store;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</div><div class="line">        enhancer = preloadedState;</div><div class="line">        preloadedState = <span class="literal">undefined</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> enhancer(generateStore)(reducer, preloadedState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> currentState = preloadedState;</div><div class="line">    <span class="keyword">let</span> currentReducer = reducer;</div><div class="line">    <span class="keyword">let</span> listeners = [];</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        getState() &#123;</div><div class="line">            <span class="keyword">return</span> currentState;<span class="comment">//返回当前 state</span></div><div class="line">        &#125;,</div><div class="line">        subscribe(listener) &#123;</div><div class="line">            <span class="keyword">let</span> index = listeners.length;</div><div class="line">            listeners.push(listener); <span class="comment">//缓存 listener</span></div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> listeners.splice(index, <span class="number">1</span>); <span class="comment">//返回删除该 listener 的函数</span></div><div class="line">        &#125;,</div><div class="line">        dispatch(action) &#123;</div><div class="line">            currentState = currentReducer(currentState, action);</div><div class="line">            listeners.slice().forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener());</div><div class="line">            <span class="keyword">return</span> action;<span class="comment">//返回 action 对象</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里偷懒用了一些库，但是仅仅是很简单的几个方法，例如 <code>import {handleActions} from &#39;redux-actions&#39;;</code> 这个里面的代码我没看的懂，但是知道返回一个类似<code>arrays.reduce</code>的<code>function</code>，这个可以理解返回一个 <code>rootReducer</code> ，也就是会迭代累加调用所有的 <code>Reducer</code> 。<code>generateStore</code> 也是抄了一部分的源码，大致的原理应该差不多。从这个也会发现一个问题，每当 <code>dispatch</code> 一个 <code>action</code> 都会去遍历所有的 <code>listeners</code> ，我们一般都是在 <code>listener</code> 中去做更新 <code>UI</code> 的工作，这样就会造成很多次无用的刷新。这个就可以使用上面提到过的 <code>React-Redux</code> 的 <code>mapStateToProps</code> 在某个 <code>Component</code> 中只去接受自己感兴趣的 <code>State</code> 的更新，然后再使用类似 <code>Immutable</code> 的库进去比较就可以很好的控制更新。当然这里不会多去说这个，因为我也没具体去理解过，以后可以多去学习学习。<br>这里还偷懒直接用了 <code>redux</code> 中的 <code>applyMiddleware</code>。我觉得这是我学习 <code>Redux</code> 中看到的最精彩的代码，贴一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, middlewares = <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) &#123;</div><div class="line">    middlewares[_key] = <span class="built_in">arguments</span>[_key];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);</div><div class="line">      <span class="keyword">var</span> _dispatch = store.dispatch;</div><div class="line">      <span class="keyword">var</span> chain = [];</div><div class="line"></div><div class="line">      <span class="keyword">var</span> middlewareAPI = &#123;</div><div class="line">        <span class="attr">getState</span>: store.getState,</div><div class="line">        <span class="attr">dispatch</span>: <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> _dispatch(action);</div><div class="line">        &#125;</div><div class="line">      &#125;;</div><div class="line">      chain = middlewares.map(<span class="function"><span class="keyword">function</span> (<span class="params">middleware</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> middleware(middlewareAPI);</div><div class="line">      &#125;);</div><div class="line">      _dispatch = _compose2[<span class="string">'default'</span>].apply(<span class="literal">undefined</span>, chain)(store.dispatch);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> _extends(&#123;&#125;, store, &#123;</div><div class="line">        <span class="attr">dispatch</span>: _dispatch</div><div class="line">      &#125;);</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过和上面的 <code>generateStore</code> 一起看，特别是 <code>applyMiddleware</code> 返回的匿名<code>Function</code>，真是精彩的代码。再去试想一下如果使用 <code>Java</code> 这样的强类型语言去实现得是多麻烦的事情。还有就是 <code>Function</code> 的一等公民地位的体现。真的值得多去读一读，很赞。不得不去佩服写这段代码的人。甚至有点自举的感觉。在还没创建 <code>store</code> 的时候就可以去使用 <code>Store.dispatch</code>，(这句话是有问题的，意会即可)。还有就是 <code>applyMiddleware</code> 的整个过程其实没有完全的弄明白，这里也不班门弄斧，等明白了会再来更新的。</p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>最后就是使用了，没什么好说的<code>store.dispatch(store.actions.testAsync());</code>就可以了。使用手动的 <code>subscribe</code> 或者 <code>React-redux</code> 的 <code>connect</code> 都能实现 <code>UI</code> 的更新，当然更推荐后者。后面还会去学习一个 <code>React-Redux</code> 这个东西，毕竟又使用 <code>React</code> 又使用 <code>Redux</code> 肯定也少不了这个东西。<br>先说到这吧，有什么想说的再来补一补。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;扯一扯&quot;&gt;&lt;a href=&quot;#扯一扯&quot; class=&quot;headerlink&quot; title=&quot;扯一扯&quot;&gt;&lt;/a&gt;扯一扯&lt;/h4&gt;&lt;p&gt;这段时间在看 &lt;code&gt;Redux&lt;/code&gt; 的东西，稍微梳理一下整个框架的流程。其实整个 &lt;code&gt;Redux&lt;/code&gt; 的代码很少，现在我也不能理解很多它的思想，反正先撸出个简单的 &lt;code&gt;Redux&lt;/code&gt; 吧。目标是照着它的流程写一个最简单的，也要支持异步 &lt;code&gt;Action&lt;/code&gt;。也算是个笔记性的东西。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Asncy await Promise的使用</title>
    <link href="http://yoursite.com/2016/12/15/Promise%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/12/15/Promise的使用/</id>
    <published>2016-12-15T03:53:56.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fetch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="comment">// resolve('success');</span></div><div class="line">            reject(<span class="string">'error'</span>);</div><div class="line">        &#125;, <span class="number">2000</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> testAsync = <span class="keyword">async</span>() =&gt; &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">await</span> fetch();</div><div class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">testAsync().then(<span class="function">(<span class="params">result</span>)=&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'这是成功的---&gt;'</span> + result);</div><div class="line">&#125;).catch(<span class="function">(<span class="params">error</span>)=&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'这是失败的---&gt;'</span> + error);</div><div class="line">&#125;);;</div></pre></td></tr></table></figure>
<p><code>async</code>函数返回的一个 <code>Promise</code>， 调用耗时函数前面加 <code>await</code> 关键字，返回成功的值，可以使用 <code>try..catch</code> 来进行捕获错误。上面的代码可以模拟一次请求的过程，最基本用法差不多都包括了<a id="more"></a></p>
<p><a href="http://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=true&amp;presets=latest,react,stage-2&amp;code=const%20fetch%20=%20%28%29%20=%3E%20%7B%0A%20%20%20%20return%20new%20Promise%28%28resolve,%20reject%29%20=%3E%20%7B%0A%20%20%20%20%20%20%20%20setTimeout%28%28%29%20=%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20//%20resolve%28%27success%27%29;%0A%20%20%20%20%20%20%20%20%20%20%20%20reject%28%27error%27%29;%0A%20%20%20%20%20%20%20%20%7D,%202000%29;%0A%20%20%20%20%7D%29;%0A%7D;%0A%0Aconst%20testAsync%20=%20async%28%29%20=%3E%20%7B%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%20%20%20return%20await%20fetch%28%29;%0A%20%20%20%20%7D%20catch%20%28error%29%20%7B%0A%20%20%20%20%20%20%20%20return%20Promise.reject%28error%29;%0A%20%20%20%20%7D%0A%7D;%0A%0AtestAsync%28%29.then%28%28result%29=%3E%20%7B%0A%20%20%20%20console.log%28%27%E8%BF%99%E6%98%AF%E6%88%90%E5%8A%9F%E7%9A%84---%3E%27%20%2b%20result%29;%0A%7D%29.catch%28%28error%29=%3E%20%7B%0A%20%20%20%20console.log%28%27%E8%BF%99%E6%98%AF%E5%A4%B1%E8%B4%A5%E7%9A%84---%3E%27%20%2b%20error%29;%0A%7D%29;;&amp;experimental=false&amp;loose=false&amp;spec=false&amp;playground=true" target="_blank" rel="external">点我运行</a></p>
<h4 id="Promise-then是异步的"><a href="#Promise-then是异步的" class="headerlink" title="Promise.then是异步的"></a><code>Promise.then</code>是异步的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(function (resolve)&#123;</div><div class="line">    console.log(&quot;inner promise&quot;); // 1</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div><div class="line">promise.then(function(value)&#123;</div><div class="line">    console.log(value); // 3</div><div class="line">&#125;);</div><div class="line">console.log(&quot;outer promise&quot;); // 2</div><div class="line"></div><div class="line"></div><div class="line">----------</div><div class="line">inner promise // 1</div><div class="line">outer promise // 2</div><div class="line">42            // 3</div></pre></td></tr></table></figure>
<p><a href="https://wohugb.gitbooks.io/promise/content/usage/async.html" target="_blank" rel="external">为啥这样</a></p>
<p>更多的关于 <code>Promise</code> 看下面的这本电子书，就不扯了，啦啦啦。</p>
<p>参考:<br><a href="https://wohugb.gitbooks.io/promise/content/index.html" target="_blank" rel="external">JavaScript Promise迷你书（中文版）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fetch = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// resolve(&#39;success&#39;);&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            reject(&lt;span class=&quot;string&quot;&gt;&#39;error&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;, &lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; testAsync = &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt;() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; fetch();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (error) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.reject(error);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;testAsync().then(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;result&lt;/span&gt;)=&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;这是成功的---&amp;gt;&#39;&lt;/span&gt; + result);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;).catch(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;error&lt;/span&gt;)=&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;这是失败的---&amp;gt;&#39;&lt;/span&gt; + error);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;函数返回的一个 &lt;code&gt;Promise&lt;/code&gt;， 调用耗时函数前面加 &lt;code&gt;await&lt;/code&gt; 关键字，返回成功的值，可以使用 &lt;code&gt;try..catch&lt;/code&gt; 来进行捕获错误。上面的代码可以模拟一次请求的过程，最基本用法差不多都包括了
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>简单谈谈Redux在项目中的使用</title>
    <link href="http://yoursite.com/2016/12/05/Redux-1/"/>
    <id>http://yoursite.com/2016/12/05/Redux-1/</id>
    <published>2016-12-05T10:54:46.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h1><p><code>Reducer</code> :为了描述 <code>action</code> 如何改变 <code>state tree</code>。 输入 <code>action</code> 和 <code>state</code>，一般根据 <code>action</code> 的 <code>type</code> 进行区分，然后处理，改变 <code>state tree</code>。<a id="more"></a></p>
<p><code>Reducer</code> 是纯函数，纯函数就是输入一个值，会输出一个确定的值，也就是 <code>Reducer</code> 里面不应该有 <code>getDate()</code>, 调用 <code>API</code> 等等之类不确定的操作。</p>
<p>e.g :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">const</span> store = configStore(reducers)</div><div class="line"></div><div class="line">    KeyboardReducer</div><div class="line">    </div><div class="line">    <span class="keyword">export</span> <span class="keyword">const</span> setKeyboardHeight = createRequest(<span class="string">'setKeyboardHeight'</span>, (keyboardHeight) =&gt; &#123;</div><div class="line">    <span class="keyword">var</span> oldKeyboarHeight = store.getState()[<span class="string">'keyboardHeight'</span>];</div><div class="line">    <span class="keyword">if</span> (oldKeyboarHeight == keyboardHeight) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;keyboardHeight&#125;;</div><div class="line">&#125;</div><div class="line">    <span class="keyword">export</span> <span class="keyword">default</span> KeyboardReducer = handleActions(&#123;</div><div class="line">        [setKeyboardHeight]: acceptSuccessActionReducer,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">keyboardHeight</span>: <span class="number">0</span>,</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里有个 <code>KeyboardReducer</code> 的一个自定义的 <code>Reducer</code> ,用来处理键盘高度的事件，先不看实现，这个 <code>Reducer</code> 接受一个 <code>type</code>  为 <code>setKeyboardHeight</code> 的 <code>action</code> ，然后获取原 <code>store</code> 中的 <code>oldState</code> 中的 <code>keyboardHeight</code> ，然后对比，改变 <code>state tree</code> 中的 <code>keyboardHeight</code> 这个 <code>state</code>。 同时可以发现，在创建给某个模块使用的 <code>store</code> 的时候，这个 <code>reducer</code> 已经对 <code>state tree</code> 做了一些改变，设置了 <code>keyboardHeight : 0</code> 这个默认值,举例这个我们可以在cs模块的 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = configStore(reducers);</div><div class="line">store.dispatch(getQuestions());</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</div></pre></td></tr></table></figure>
<p>在处理模块自己的 <code>action</code> 之前，断点可以看到</p>
<pre><code>store.getState()[&apos;keyboardHeight&apos;] ：0
</code></pre><p>也就印证了我们的猜想。</p>
<h4 id="拆分-Reducer"><a href="#拆分-Reducer" class="headerlink" title="拆分 Reducer"></a>拆分 <code>Reducer</code></h4><p><code>Reducer</code>接受一个 <code>state</code> 和 <code>action</code> ，返回一个新的 <code>State</code>,如果项目很大，对应的 <code>state</code> 也会很大，如果使用一个 <code>Reducer</code> 进行整个的 <code>state</code> 的处理就会非常的臃肿。这个时候就可以进行拆分 <code>Reducer</code> ,每个 <code>Reducer</code> 去处理自己职责范围内的 <code>state</code> ，类似上面的  <code>KeyboardReducer</code> 就只对 <code>store.getState()[&#39;keyboardHeight&#39;];</code> 这个 <code>stage</code> 感兴趣。 因为 <code>store</code> 只有一个，当分成多个 <code>Reducer</code> 的时候，那就需要一个 <code>Reducer</code> 去管理这些 <code>Reducers</code> 。可以使用 <code>combineReducers</code> 进行 <code>Reducer</code> 的合成，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">state = &#123;&#125;,action</span>)</span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type)&#123;</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,........);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">state = &#123;&#125;,action</span>)</span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type)&#123;</div><div class="line">    ...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,state,........);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> App = combineReducers(&#123;</div><div class="line">    foo,</div><div class="line">    foo1</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在项目中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> reducers = handleActions(&#123;</div><div class="line">    [setBrandId]: acceptSuccessActionReducer,</div><div class="line">    [getBrandCatalogs]: acceptSuccessActionReducer,</div><div class="line">    [getBrandInfo]: acceptSuccessActionReducer,</div><div class="line">    [setOrderByAndDirect]: acceptSuccessActionReducer,</div><div class="line">    [getFilterInfo]: acceptSuccessActionReducer,</div><div class="line">    [setFilter]: acceptSuccessActionReducer,</div><div class="line">    [followBrand]: acceptSuccessActionReducer,</div><div class="line">    [setPriceSelect]: acceptSuccessActionReducer,</div><div class="line">    [getCampaign]: acceptSuccessActionReducer,</div><div class="line">    [resetgetCampaigned]: acceptSuccessActionReducer,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里每个请求都对于同样的 <code>acceptSuccessActionReducer</code> 这个 <code>Reducer</code>，代码很简单就不贴了，最终这些 <code>reducer</code> 的统一处理是在 <code>createStore</code> 的时候，下面会说到</p>
<p>项目中管理这些 <code>Reducers</code> 是使用了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">reduceReducers(actionStateReducers, KeyboardReducer, reducer)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">reduceReducers</span>(<span class="params">...reducers</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</div><div class="line">        <span class="comment">//框架的安全检查类型，可暂时忽略。。</span></div><div class="line">        <span class="comment">// if (action.type === ActionTypes.INIT) &#123;</span></div><div class="line">        <span class="keyword">if</span> (action.type === <span class="string">'@@redux/INIT'</span>) &#123;</div><div class="line">            <span class="keyword">var</span> state = &#123;&#125;;</div><div class="line">            <span class="comment">// collect all init state.</span></div><div class="line">            reducers.forEach(<span class="function"><span class="params">reduce</span> =&gt;</span> &#123;</div><div class="line">                state = <span class="built_in">Object</span>.assign(state, reduce(<span class="literal">undefined</span>, action));</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> reducers.reduce(</div><div class="line">                <span class="comment">//迭代累加调用reducer</span></div><div class="line">                (state, reduce) =&gt; reduce(state, action),</div><div class="line">                state</div><div class="line">            );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Action"><a href="#Action" class="headerlink" title="Action"></a><code>Action</code></h1><p><code>Action</code>可以理解为一个动作或者事件。它的作用是将信息传递给某个 <code>Reducer</code> 进而去影响 <code>State tree</code>,而使用这些 <code>Action</code> 只有一种方法就是 <code>store.dispatch(action)</code>, 在项目中可以手动去调用，也可以使用 <code>react-redux</code> 的 <code>bindActionCreators</code>方法自动将多个 <code>Action</code> 绑定到 <code>Dispatch()</code> 方法上。这个肯定也是调用了 <code>store.dispatch(action)</code> ,一般的 <code>Action</code> 的结构类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    type: &quot;action-type&quot;</div><div class="line">    value: &quot;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>action</code>的定义十分灵活，一般只有 <code>type</code>是固定的，其他随便。但是在异步的 <code>action</code> 中，通过 <code>actionCreater</code>创建的一般都是 <code>function</code>，返回值才是起作用的 <code>action</code>。</p>
<h1 id="Store"><a href="#Store" class="headerlink" title="Store"></a><code>Store</code></h1><p>每个 <code>Redux</code>应用只有一个 <code>store</code>，如果觉得数据很多很臃肿，应该去使用组合 <code>Reducer</code> 的方法而不是去创建多个 <code>store</code> 解决。 <code>store</code>  有下面几个重要方法：</p>
<ul>
<li><code>store.getState</code> 对当前 <code>store</code> 进行快照，获取当前 <code>store</code> 对应的 <code>state</code>.</li>
<li><code>dispatch(action)</code> 分发 <code>action</code> 给 <code>reducer</code>。</li>
<li><code>subscribe(listener)</code> 注册监听器，当 <code>store</code> 改变时回调监听器。</li>
</ul>
<p>e.g.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">//当进入品牌详情页面，设置brandId导致store的改变，进而回调这里，去请求网络。</span></div><div class="line">    <span class="keyword">var</span> brandId = store.getState()[<span class="string">'brandId'</span>];</div><div class="line">    <span class="keyword">if</span>(brandId &amp;&amp; brandId !== lastBrandId) &#123;</div><div class="line">        lastBrandId = brandId;</div><div class="line">        store.dispatch(getBrandInfo());</div><div class="line">        store.dispatch(getFilterInfo());</div><div class="line">        store.dispatch(getBrandCatalogs(<span class="literal">true</span>));</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a><code>Middleware</code></h1><p>对于中间件，看这个就够了，我也说不了比它更好：</p>
<p><a href="http://cn.redux.js.org/docs/advanced/Middleware.html" target="_blank" rel="external">点击了解Middleware</a></p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><p>来简单的看一下项目中的一个请求 <code>action</code> 是如果经过一步步到最终 UI 上面展示的。先从创建 <code>Store</code> 开始，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//参数reducer是我们在模块中自己定义 一般一个请求对应一个reducer 参考actions目录</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configStore</span>(<span class="params">reducer</span>) </span>&#123;</div><div class="line">    <span class="comment">//createStore 第一个参数是reducer</span></div><div class="line">    <span class="keyword">const</span> store = createStore(</div><div class="line">        <span class="comment">//array.reducer类似一个迭代累加的效果 这里就是迭代去调用各种reducer,累加对store的影响</span></div><div class="line">        <span class="comment">//actionStateReducers:主要是为了异步的action 自动多了ACTION_WILL_START,ACTION_WILL_END这两个action</span></div><div class="line">        <span class="comment">//KeyboardReducer :处理键盘的</span></div><div class="line">        <span class="comment">//我们在模块中自己定义的各个reducer 详情见模块下的actions/index.js 中的export const reducers = handleActions。。。。。</span></div><div class="line">        <span class="comment">//类似注册的作用 预先创建各个 Reducers 到使用的时候一般由下面的中间件中调用。</span></div><div class="line">        reduceReducers(actionStateReducers, KeyboardReducer, reducer),</div><div class="line">        </div><div class="line">        <span class="comment">//Middleware作用在action创建之后,到达reducer之前的阶段</span></div><div class="line">        <span class="comment">//actionStateMiddleware:对应上面的actionStateReducers,处理多出来的两个action</span></div><div class="line">        <span class="comment">//会去调用上面注册的东西</span></div><div class="line">        applyMiddleware(actionStateMiddleware, errorHandlerMiddleware, promiseMiddleware, createLogger(&#123;</div><div class="line">            <span class="attr">predicate</span>: <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> (action.type === <span class="string">'ACTION_WILL_START'</span> || action.type === <span class="string">'ACTION_WILL_END'</span> || action.type === <span class="string">'CONCURRENT_EXECUTION_ERROR'</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;,</div><div class="line">        &#125;))</div><div class="line">    );</div><div class="line"></div><div class="line">    global.store = store;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> store;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们去创建一个请求，都是使用 <code>createRequest</code> ，其实也就是创建了一个 <code>action</code> ，但是这个 <code>action</code> 是个 <code>function</code>，这个 <code>function</code>的返回值是真正的 <code>action</code>， 这个先不管，但是起作用的 <code>action</code> 结构类似 ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//同步 &#123;</span></div><div class="line">        <span class="comment">//   type:setBrandId</span></div><div class="line">        <span class="comment">//   payload:object</span></div><div class="line">        <span class="comment">// &#125;</span></div><div class="line"><span class="comment">//异步&#123;</span></div><div class="line">        <span class="comment">//   type:getBrand</span></div><div class="line">        <span class="comment">//   payload:promise</span></div><div class="line">        <span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>对于最常用的异步 <code>action</code> ,对应与 <code>actionStateReducers</code> 这个 <code>reducer</code> ，详情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//每个action都会多创建这两个action，在原始action开始和结束的时候分发。</span></div><div class="line"><span class="keyword">const</span> actionWillStart = createAction(<span class="string">'ACTION_WILL_START'</span>);</div><div class="line"><span class="keyword">const</span> actionDidEnd = createAction(<span class="string">'ACTION_WILL_END'</span>);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> actionStateReducers = handleActions(&#123;</div><div class="line">    [actionWillStart]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">var</span> actionName = action.payload;<span class="comment">//请求回来的数据会在action.payload中 进而去改变store action type也就是请求名</span></div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'调用处理开始的action的地方,action--&gt;'</span>, action);</div><div class="line"></div><div class="line">        <span class="comment">//state中包含actionstate和我们自己定义的各种state</span></div><div class="line">        <span class="keyword">var</span> actionState = state[<span class="string">'actionState'</span>];</div><div class="line">        <span class="comment">//actionstate的结构类似这样:</span></div><div class="line">        <span class="comment">//&#123;</span></div><div class="line">        <span class="comment">// getLiveShow:1   //是action的名称 和 数量 这个数量暂时还不知道是干什么用的  一般就是0或者1</span></div><div class="line">        <span class="comment">// &#125;</span></div><div class="line">        <span class="keyword">var</span> count = actionState[actionName];</div><div class="line">        <span class="keyword">if</span> (count) &#123;</div><div class="line">            count += <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            count = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        actionState[actionName] = count;</div><div class="line">        <span class="comment">//如果是ACTION_WILL_START这个action  就把对应的action中的actionstate +1 表明创建了这个一个action??</span></div><div class="line">        <span class="comment">//然后应用修改的state</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;actionState&#125;);</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//这个是ACTION_WILL_END 同上</span></div><div class="line">    [actionDidEnd]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;<span class="comment">//在数据回来的时候调用</span></div><div class="line">        <span class="keyword">var</span> actionName = action.payload;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> actionState = state[<span class="string">'actionState'</span>];</div><div class="line">        <span class="keyword">var</span> count = actionState[actionName];</div><div class="line">        --count;</div><div class="line">        actionState[actionName] = count;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'调用处理结束的action的地方,action--&gt;'</span>, action);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;actionState&#125;);</div><div class="line">    &#125;,</div><div class="line">&#125;, &#123;</div><div class="line">    <span class="attr">actionState</span>: &#123;&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> 上面的代码主要是帮我们多创建了两个 <code>action</code>，而何时去调用，调用的顺序是在下面的 <code>actionStateMiddleware</code> 中定义的，详情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">actionStateMiddleware</span>(<span class="params">&#123;dispatch, getState&#125;</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</div><div class="line">            <span class="comment">// action throttling</span></div><div class="line">            <span class="keyword">if</span> (isPromise(action.payload)) &#123;</div><div class="line">                <span class="keyword">if</span> (action.type == <span class="string">'CONCURRENT_EXECUTION_ERROR'</span>) &#123;</div><div class="line">                    <span class="keyword">return</span> next(action);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'进来中间件,action--&gt;'</span>, action);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (action.type !== actionWillStart.toString() &amp;&amp;</div><div class="line">                    action.type !== actionDidEnd.toString()) &#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">'分发开始的action,action--&gt;'</span>, action);</div><div class="line">                    dispatch(actionWillStart(action.type));<span class="comment">//不是那两种 action, 分发actionWillStart:&#123;type:action.type&#125;</span></div><div class="line">                &#125;</div><div class="line">                <span class="comment">//这里的payload是个promise</span></div><div class="line">                action.payload.then(</div><div class="line">                    <span class="function"><span class="params">result</span> =&gt;</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (action.type !== actionWillStart.toString() &amp;&amp;</div><div class="line">                            action.type !== actionDidEnd.toString()) &#123;</div><div class="line">                            <span class="built_in">console</span>.log(<span class="string">'分发结束的action,action--&gt;'</span>, action);</div><div class="line">                            dispatch(actionDidEnd(action.type));<span class="comment">//数据回来的时候 调用这个</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;,</div><div class="line">                    error =&gt; &#123;</div><div class="line">                        <span class="keyword">if</span> (action.type !== actionWillStart.toString() &amp;&amp;</div><div class="line">                            action.type !== actionDidEnd.toString()) &#123;</div><div class="line">                            dispatch(actionDidEnd(action.type));</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                );</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isFSA(action) &amp;&amp; !action.error &amp;&amp; !action.payload) &#123;</div><div class="line">                <span class="comment">// return action directly, and the payload will not be reduced into store.</span></div><div class="line">                <span class="keyword">return</span> action;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> next(action);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而处理原始的 <code>action</code> 则是在 <code>acceptSuccessActionReducer</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">acceptSuccessActionReducer</span>(<span class="params">state, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!action.error &amp;&amp; action.payload) &#123;</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'调用处理原始的action的地方,action--&gt;'</span>, action);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, action.payload);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>何时去调用则是在 <code>promiseMiddleware</code> 这个中间件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">....略</div><div class="line"> return isPromise(action.payload) ? action.payload.then(function (result) &#123;</div><div class="line">        return dispatch(_extends(&#123;&#125;, action, &#123; payload: result &#125;));</div><div class="line">....</div></pre></td></tr></table></figure>
<p>最后以品牌详情切换排序方式为例，看一下完整的 <code>action</code> 到 UI 改变的过程。</p>
<p><img src="http://7xjlmz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-04%20%E4%B8%8B%E5%8D%888.54.40.png" alt=""> </p>
<p>无论是开始还是结束的action，都会触发 <code>state</code> 中的 <code>actionState</code> 的改变，进而触发 <code>store</code> 的改变，进而触发页面中 <code>state</code> 的更新。所以会出现多次更新 UI的情况。</p>
<p>createRequest<br>-&gt;dispatch(action)<br>-&gt;actionStateMiddleware<br>-&gt;dispatch(actionWillStart(action.type))<br>-&gt;reduceReducers<br>-&gt;迭代执行reducers(1:包括start,end的actionStateReducers，2：KeyboardReducer，3：模块中定义的reducers：handactions(…..))<br>-&gt;调用handleActions中start action对应的reducer逻辑<br>-&gt;修改start action 对应的actionstate<br>-&gt;请求结果返回<br>-&gt;调用handleActions中end action对应的reducer逻辑<br>-&gt;修改end action 对应的actionstate<br>-&gt;调用promiseMiddleware中的promise响应<br>-&gt;修改store<br>-&gt;调用组件中mapStateToProps<br>-&gt;调用componentWillReceiveProps。</p>
<h2 id="Why-Redux"><a href="#Why-Redux" class="headerlink" title="Why Redux"></a><code>Why Redux</code></h2><p>扯了半天，为什么要用 <code>Redux</code>? 它的定义是 :<strong>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</strong> 为什么说是可预测的状态，因为一个确定的 <code>state</code> 就对应一个确定的 <code>view</code>，使用 <code>Redux</code> 能感受到它的数据的单向流动性，用户触发某个动作，发出一个 <code>action</code> ，经过 <code>Reducer</code>,改变 <code>store</code> 的数据，进而去控制 UI的效果，仅仅有这一种方式，单向数据流也保证了可预测的状态。如果不这样做，我们的 <code>View</code> 可以被各种各样的 <code>event</code>,<code>Model</code>甚至其他的 <code>View</code>控制，一个 <code>View</code> 的状态无法预测，当改变因素很多的时候就无法控制。这只是我浅显的理解。<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/WechatIMG4.jpeg" alt=""></p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>好大老师改了原 <code>actions/index.js</code>和 <code>store/index.js</code>，结合了这两个，看完了上面的这些东西，再去看改动应该就没什么压力了，也更理解为什么这么改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Reducer&quot;&gt;&lt;a href=&quot;#Reducer&quot; class=&quot;headerlink&quot; title=&quot;Reducer&quot;&gt;&lt;/a&gt;Reducer&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Reducer&lt;/code&gt; :为了描述 &lt;code&gt;action&lt;/code&gt; 如何改变 &lt;code&gt;state tree&lt;/code&gt;。 输入 &lt;code&gt;action&lt;/code&gt; 和 &lt;code&gt;state&lt;/code&gt;，一般根据 &lt;code&gt;action&lt;/code&gt; 的 &lt;code&gt;type&lt;/code&gt; 进行区分，然后处理，改变 &lt;code&gt;state tree&lt;/code&gt;。
    
    </summary>
    
    
      <category term="Redux" scheme="http://yoursite.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Router设计</title>
    <link href="http://yoursite.com/2016/11/16/Router%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2016/11/16/Router设计/</id>
    <published>2016-11-16T11:20:57.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近公司的项目要进行页面间跳转的重构，首先项目是单 <code>Activity</code> + 多 <code>Fragment</code> 的结构，因为是电商的项目，所以涉及到很多 H5 , <code>Native</code> 和 <code>React Native</code> 页面之间的交互与跳转，这篇不是介绍两者之间是如何进行通信的，而是当 H5 或者外部分享的链接打开后传递过来 <code>Uri</code> 要解析跳转到 <code>Native</code> 的页面的处理。当然各个页面的 <code>Host</code>  是提前统一定义好的，具体的做法这里也不说了，也没什么难点。原来的写法是都放到一个 <code>Util</code> 类里面，各种 <code>Switch</code> <code>Case</code> 来进行分支判断，当项目越来越大维护起来十分的困难，而且本身 <code>Native</code> 的页面之间还有一套跳转的逻辑，同时维护两套的代价是很大的，所有希望将项目重构一下，统一两端的处理逻辑，就产生了下面的这个路由结构。<a id="more"></a></p>
<p>&emsp;&emsp;在开始重构之前，也是去搜索了一下网上的一些开源例子，绝大多数都是基于 <code>Activity</code> 的跳转，写的功能虽然很多，但是对于我们的项目却是很冗余并且也不怎么合适，所以要去定制一套适合自己的路由，目标就是统一 H5 , <code>Native</code> 和 <code>React Native</code> 这三端之间的跳转逻辑，同时做到简单易用，容易维护和容易拓展。去写人人都能很容易看的懂的代码，而不是写那么花里胡哨的各种”炫技”的代码。</p>
<p>&emsp;&emsp;先放一下这个项目的类图，不怎么熟悉 <code>UML</code>,里面有些关系表示的不正确，大概的意思还是可以表达出来的。首先要去统一两端的逻辑，肯定需要在跳转直接转换成统一的 <code>Uri</code> 进行跳转，从 H5 过来的就很简单就是个 <code>Uri</code>,而 <code>Native</code> 的跳转则要去进行处理拼接，然后通过统一的路由进行处理，最后跳转到具体的页面。</p>
<p><img src="http://7xjlmz.com1.z0.glb.clouddn.com/Class%20Diagram%20%282%29.png" alt=""></p>
<p>&emsp;&emsp;先说一下设计的思想，一个页面对应一个 <code>Uri</code>,并且使用不同的 <code>Host</code> 或者 <code>Path</code> 进行区分和信息的传递，这里先建立了一个全局的”路由表”,让 <code>Url</code> 和一个具体页面的切换器进行对应，当路由获取到一个 <code>Uri</code> 的时候，在路由表中找到对应的切换器，切换到具体的页面。当然在切换之前还需要一些其他的处理，这里加入了拦截器的机制，默认实现了两种拦截器，<code>LoginInterceptor</code> 和 <code>LogInterceptor</code> 分别进行需要登录页面的 <code>Uri</code> 的拦截使其跳转到登录页面和打印 <code>Uri</code> 和其他跳转参数。当然也可以去实现其他的拦截器，这样就使得整个路由十分的灵活。</p>
<p>&emsp;&emsp;说一下怎么使用，首先在 <code>Application</code> 中初始化路由表，这个路由表是个 <code>pageMap : Map&lt;String, Switcher&gt;</code> ，这里的 <code>Key</code> 就是每个页面对应的 <code>Host</code> ,<code>Value</code> 的 <code>Switcher</code> 就是处理每个页面切换逻辑的地方，类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pageMap.put(REACT_NATIVE, new RnSwitcher());</div><div class="line">pageMap.put(SCHEMA_HTTP, new H5Switcher());</div><div class="line">pageMap.put(HOST_CATALOG, new CatalogDetailSwitcher());</div></pre></td></tr></table></figure>
<p>这样就初始化了全局的路由表。因为是单 <code>Activity</code> +多 <code>Fragment</code> 的结构，几乎所有的页面都是 <code>Fragment</code> ,不像切换 <code>Activity</code> 那么简单，这里要去处理相对复杂的 <code>Fragment</code> 的切换逻辑和维护回退栈的操作，所以封装了一个 <code>NavigationManager</code> 用来处理这些操作。看一下初始化的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Router.install(mNavigationManager)</div><div class="line">            .addInterceptor(new LoginInterceptor())</div><div class="line">            .addInterceptor(new LogInterceptor());</div></pre></td></tr></table></figure>
<p>因为要持有 <code>Activiry</code> 所以要在 <code>onDestroy</code> 的时候及时释放引用 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Router.unInstall();</div></pre></td></tr></table></figure>
<p>然后看一下具体的跳转：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Router.config().setUri(uri).start()</div></pre></td></tr></table></figure>
<p>这样就可以跳转到具体的页面了，当然只是简单的示例一下，实际使用的时候肯定还有其他的配置。因为使用者不可能记得每个页面的 <code>Uri</code> 是怎么拼接的，所以还可以在写个工具类来封装一下，这个就不说了。</p>
<p> &emsp;&emsp;说一下这个路由的优点：</p>
<ol>
<li>简单易懂，几乎人人都读得懂，基本不需要学习成本。更没有任何的注解反射之类的。</li>
<li>方便统一进行跳转管理，使用了拦截器，可以打印出跳转中的 <code>Uri</code> 和其他参数，调试十分方便。加入了登录拦截器，使得跳转可以无脑跳转，无需关心页面是否需要登录，路由帮你做好了判断和后续登录成功跳转到目标页面。</li>
<li>容易拓展，无论是新增页面还是修改维护旧页面。将每个页面切换逻辑封装到对应的 <code>Switcher</code> 里面，快速定位。</li>
<li>统一 <code>H5</code> , <code>Native</code> 和 <code>React Native</code> 三端的跳转，更加方便维护。</li>
<li>啦啦啦啦。。。</li>
</ol>
<p>&emsp;&emsp;以后甚至可以将路由表让服务端去控制，无论是灵活性还是稳定性都大大提高，只是目前还没有这样的需求，但是改造起来将十分的简单。这个路由从设计到项目的改造大概花了一周的时间，也算是独立设计开发的完整的重要模块，现在还处于比较初级的阶段，肯定有提升空间。目前用在 <a href="http://www.bolome.com/" target="_blank" rel="external">波罗蜜全球购</a> 的 <code>Android</code> 客户端中，欢迎大家支持。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;最近公司的项目要进行页面间跳转的重构，首先项目是单 &lt;code&gt;Activity&lt;/code&gt; + 多 &lt;code&gt;Fragment&lt;/code&gt; 的结构，因为是电商的项目，所以涉及到很多 H5 , &lt;code&gt;Native&lt;/code&gt; 和 &lt;code&gt;React Native&lt;/code&gt; 页面之间的交互与跳转，这篇不是介绍两者之间是如何进行通信的，而是当 H5 或者外部分享的链接打开后传递过来 &lt;code&gt;Uri&lt;/code&gt; 要解析跳转到 &lt;code&gt;Native&lt;/code&gt; 的页面的处理。当然各个页面的 &lt;code&gt;Host&lt;/code&gt;  是提前统一定义好的，具体的做法这里也不说了，也没什么难点。原来的写法是都放到一个 &lt;code&gt;Util&lt;/code&gt; 类里面，各种 &lt;code&gt;Switch&lt;/code&gt; &lt;code&gt;Case&lt;/code&gt; 来进行分支判断，当项目越来越大维护起来十分的困难，而且本身 &lt;code&gt;Native&lt;/code&gt; 的页面之间还有一套跳转的逻辑，同时维护两套的代价是很大的，所有希望将项目重构一下，统一两端的处理逻辑，就产生了下面的这个路由结构。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>React Native + Redux + React-Redux</title>
    <link href="http://yoursite.com/2016/09/30/Redux/"/>
    <id>http://yoursite.com/2016/09/30/Redux/</id>
    <published>2016-09-30T07:17:53.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>Component</code>中的<code>state</code>相当于组件内的本地变量，用于储存view的本地变化</p>
<p><code>props</code>中存储数据， <code>props</code>属于readOnly的常量dic<a id="more"></a></p>
<p>store相当于全集的数据状态仓库，只有一个，改变它的唯一方式就是store.dispatch(action)，可以通过store.getState对当前的store进行一次快照，store还有store.subscribe方法，也就是在store.dispatch触发了store的数据更新，回调这个subscribe方法。</p>
<p>使用了React-Redux这个库有两个重要的方法：<code>mapStateToProps</code>是用来把外部的state,也就是当前store的快照映射到UI组件的参数上(props),也就是输入数据。<code>mapDispatchToProps</code>是把对UI组件的操作映射成action，</p>
<p>当dispatch一个action后，reduce会自动生成一个当前store的快照 =&gt;state，调用mapStateToProps，将state映射到props,调用React native的生命周期方法<code>componentWillReceiveProps</code>,这里可以再处理一下数据，改变this.state的值。</p>
<p><code>mapStateToProps</code>会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;Component&lt;/code&gt;中的&lt;code&gt;state&lt;/code&gt;相当于组件内的本地变量，用于储存view的本地变化&lt;/p&gt;
&lt;p&gt;&lt;code&gt;props&lt;/code&gt;中存储数据， &lt;code&gt;props&lt;/code&gt;属于readOnly的常量dic
    
    </summary>
    
    
      <category term="React Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit源码浅析</title>
    <link href="http://yoursite.com/2016/08/17/Refrofit%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2016/08/17/Refrofit源码浅析/</id>
    <published>2016-08-16T16:49:43.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p> 这篇主要会走读一下<code>Retrofit</code>的源码，解析一下里面遇到的一些设计模式，网络请求的过程等。</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>从创建<code>Retrofit</code>开始，看一下常见的创建<code>Retrofit</code>的实例的方式<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();</div><div class="line">        interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</div><div class="line">        OkHttpClient client = new OkHttpClient.Builder()</div><div class="line">                .addInterceptor(interceptor)</div><div class="line">                .retryOnConnectionFailure(true)</div><div class="line">                .connectTimeout(15, TimeUnit.SECONDS)</div><div class="line">                .addNetworkInterceptor(createHeaderInterceptor())</div><div class="line">                .build();</div><div class="line">                </div><div class="line">Retrofit retrofit = new Retrofit.Builder()</div><div class="line">                .baseUrl(BuildConfig.BASE_API_URL)</div><div class="line">                .client(client)</div><div class="line">                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div><div class="line">                .addConverterFactory(BolomeGsonConverterFactory.create())</div><div class="line">                .build();</div><div class="line">          Net net = retrofit.create(Net.class)</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出，<code>Retrofit</code>并没有去真正的执行网络请求，还是交给了<code>OkHttp</code>来进行实现，<code>Retrofit</code>可以看作的对<code>OkHttp</code>的一层非常棒的封装，<code>Retrofit</code>的关注点是在如何让你更快捷更灵活的去进行网络请求。如果你使用过<code>Retrofit</code>的话，你也会明白用<code>Retrofit</code>去实现一次网络请求是多方便的事情。</p>
<h3 id="retrofit-create"><a href="#retrofit-create" class="headerlink" title="retrofit.create"></a><code>retrofit.create</code></h3><p>从<code>Net net = retrofit.create(Net.class)</code>这里开始入手，用过<code>Retrofit</code>的几乎都知道<code>Retrofit</code>是用了动态代理，动态代理说简单点就是动态的去生成接口的实现类，也可以在原始的结果返回前对参数或者结果进行修改，这个特性也使得一些<code>Hook</code>框架大量使用了动态代理，比如很著名的360的<code>DroidPlugin</code>。有点扯远了，还是去源码里面去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</div><div class="line">  ...</div><div class="line">  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">      new InvocationHandler() &#123;</div><div class="line">        private final Platform platform = Platform.get();</div><div class="line"></div><div class="line">        @Override public Object invoke(Object proxy, Method method, Object... args)</div><div class="line">            throws Throwable &#123;</div><div class="line">          ...</div><div class="line">          ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">          OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">          return serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里省略了一下判断的逻辑，但是主要的就是最后的三行代码，从方法的签名来看，是传进来一个接口类，返回一个接口类型的实例，但是这个实例的具体实现类型是由<code>serviceMethod.callAdapter.adapt</code>方法动态决定了，而且这个接口里面的每一次方法调用，都会进入这个<code>invoke</code>方法，也就是由接口的实现类去完成功能。例如，<code>Retrofit</code>默认的请求方式是<code>Call&lt;T&gt;</code>,这里默认的实现类就是<code>ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt;</code>，而在这个类里面又是用代理类的方式去交给<code>Okhttp</code>的<code>call</code>去执行真正的请求，这个就是后面再说了。</p>
<h3 id="ServiceMethod"><a href="#ServiceMethod" class="headerlink" title="ServiceMethod"></a><code>ServiceMethod</code></h3><p>这个类主要是储存了请求的信息和<code>Retrofit</code>的配置信息以及对请求注解的解析生成正常的地址和请求。</p>
<h3 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a><code>OkHttpCall</code></h3><p>第二行<code>OkHttpCall</code>可以看成是<code>OkHttp</code>的<code>call</code>在<code>Retrofit</code>层面的一次封装。从上面一步看到，把请求参数和配置信息交给了这个<code>OkHttpCall</code>，然后让<code>OkHttp</code>去执行请求操作。</p>
<h3 id="callAdapter"><a href="#callAdapter" class="headerlink" title="callAdapter"></a><code>callAdapter</code></h3><p>不知道该怎么去具体描述这个类的意思，可以理解成将请求转换成不同的请求形式，例如默认的<code>call</code>或者常见的<code>Rxjava</code>的<code>Observable&lt;T&gt;</code>的形式亦或者是<code>Agera</code>的<code>Supplier&lt;Result&lt;T&gt;&gt;</code>的形式等等。以<code>@drakeet</code>的<a href="https://github.com/drakeet/retrofit-agera-call-adapter" target="_blank" rel="external">retrofit-agera-call-adapter</a>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">public final class AgeraCallAdapterFactory extends CallAdapter.Factory &#123;</div><div class="line"></div><div class="line">    public static AgeraCallAdapterFactory create() &#123;</div><div class="line">        return new AgeraCallAdapterFactory();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private AgeraCallAdapterFactory() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">        ...</div><div class="line">        支持Supplier&lt;Result&lt;T&gt;&gt;形式</div><div class="line">            return new BodyCallAdapter(innerTypeOfInnerType);</div><div class="line">        &#125;</div><div class="line">        ...支持Supplier&lt;Result&lt;Response&lt;T&gt;&gt;&gt;形式</div><div class="line">        return new ResponseCallAdapter(responseType);</div><div class="line">    &#125;</div><div class="line">    private static class BodyCallAdapter implements CallAdapter&lt;Supplier&lt;?&gt;&gt; &#123;</div><div class="line"></div><div class="line">        private final Type responseType;</div><div class="line"></div><div class="line"></div><div class="line">        BodyCallAdapter(Type responseType) &#123;</div><div class="line">            this.responseType = responseType;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        @Override public Type responseType() &#123;</div><div class="line">            return responseType;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        @Override</div><div class="line">        public &lt;T&gt; Supplier&lt;Result&lt;T&gt;&gt; adapt(Call&lt;T&gt; call) &#123;</div><div class="line">            return new CallSupplier(call);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class CallSupplier&lt;T&gt; implements Supplier&lt;Result&lt;T&gt;&gt; &#123;</div><div class="line"></div><div class="line">    private final Call&lt;T&gt; originalCall;</div><div class="line"></div><div class="line"></div><div class="line">    CallSupplier(@NonNull final Call&lt;T&gt; call) &#123;</div><div class="line">        this.originalCall = checkNotNull(call);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @NonNull @Override public Result&lt;T&gt; get() &#123;</div><div class="line">        Result&lt;T&gt; result;</div><div class="line">        try &#123;</div><div class="line">            Response&lt;T&gt; response = originalCall.clone().execute();</div><div class="line">            //将Response转换成Result&lt;T&gt;的形式 因为数据要从Result中取，而不像默认的call那样直接走回调</div><div class="line">            if (response.isSuccessful()) &#123;</div><div class="line">                result = Result.success(response.body());</div><div class="line">            &#125; else &#123;</div><div class="line">                result = Result.failure(new HttpException(response));</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            result = Result.failure(e);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码没太多难度，看看就明白了。也是非常棒的自定义<code>CallAdapter</code>教程。</p>
<h3 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue"></a><code>enqueue</code></h3><p>异步请求的时候是这个样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">mNet.getLiveShows(20, 1).enqueue(new Callback&lt;LiveBlock&gt;() &#123;</div><div class="line">           @Override</div><div class="line">           public void onResponse(Call&lt;LiveBlock&gt; call, Response&lt;LiveBlock&gt; response) &#123;</div><div class="line">               </div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onFailure(Call&lt;LiveBlock&gt; call, Throwable t) &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure>
<p>而<code>getLiveShows</code>返回的<code>call</code>其实是上面说的<code>ExecutorCallbackCall</code>，这个的<code>enqueue</code>是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">      if (callback == null) throw new NullPointerException(&quot;callback == null&quot;);</div><div class="line"></div><div class="line">      delegate.enqueue(new Callback&lt;T&gt;() &#123;</div><div class="line">        @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</div><div class="line">          callbackExecutor.execute(new Runnable() &#123;</div><div class="line">            @Override public void run() &#123;</div><div class="line">              if (delegate.isCanceled()) &#123;</div><div class="line">                // Emulate OkHttp&apos;s behavior of throwing/delivering an IOException on cancellation.</div><div class="line">                callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">              &#125; else &#123;</div><div class="line">                callback.onResponse(ExecutorCallbackCall.this, response);</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</div><div class="line">          callbackExecutor.execute(new Runnable() &#123;</div><div class="line">            @Override public void run() &#123;</div><div class="line">              callback.onFailure(ExecutorCallbackCall.this, t);</div><div class="line">            &#125;</div><div class="line">          &#125;);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用了<code>delegate.enqueue</code>这个<code>delegate</code>就是上面说到的<code>OkHttpCall</code>看这个里面的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">call.enqueue(new okhttp3.Callback() &#123;</div><div class="line">      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)</div><div class="line">          throws IOException &#123;</div><div class="line">        Response&lt;T&gt; response;</div><div class="line">        try &#123;</div><div class="line">          response = parseResponse(rawResponse);</div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">          callFailure(e);</div><div class="line">          return;</div><div class="line">        &#125;</div><div class="line">        callSuccess(response);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public void onFailure(okhttp3.Call call, IOException e) &#123;</div><div class="line">        try &#123;</div><div class="line">          callback.onFailure(OkHttpCall.this, e);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      private void callFailure(Throwable e) &#123;</div><div class="line">        try &#123;</div><div class="line">          callback.onFailure(OkHttpCall.this, e);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      private void callSuccess(Response&lt;T&gt; response) &#123;</div><div class="line">        try &#123;</div><div class="line">          callback.onResponse(OkHttpCall.this, response);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;</div><div class="line">    ResponseBody rawBody = rawResponse.body();</div><div class="line">   .....//使用responseConverter.convert(body)</div><div class="line">      T body = serviceMethod.toResponse(catchingBody);</div><div class="line">      return Response.success(body, rawResponse);</div><div class="line">    ....</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>注意的是这里几个<code>call</code>的区别和三个<code>enqueue</code>的区别和作用</p>
<p>###<code>Converter</code><br>这个是用来将<code>RequestBody</code>和<code>responseBody</code>转换成相应的类型，具体去看看官方的<code>GsonConverterFactory</code>就可以了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 这篇主要会走读一下&lt;code&gt;Retrofit&lt;/code&gt;的源码，解析一下里面遇到的一些设计模式，网络请求的过程等。&lt;/p&gt;
&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h3&gt;&lt;p&gt;从创建&lt;code&gt;Retrofit&lt;/code&gt;开始，看一下常见的创建&lt;code&gt;Retrofit&lt;/code&gt;的实例的方式&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>浅谈CoordinatorLayout</title>
    <link href="http://yoursite.com/2016/08/01/%E6%B5%85%E8%B0%88CoordinatorLayout/"/>
    <id>http://yoursite.com/2016/08/01/浅谈CoordinatorLayout/</id>
    <published>2016-08-01T14:24:32.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>这是一篇重新写的东西，之前写过一点，但是烂尾了，我也很久没有去写点东西了，也是很惭愧，之前打算的事情也没有坚持下来。最近这一周空余的时间比较多，然后去重构了一个公司项目里的一个个人中心的页面，原来使用了<code>ListView</code>再加上<code>addHead</code>的方式，然后动态的去控制<code>Head</code>的高度去实现嵌套滑动的效果，因为我的模拟器没有跑起来，所以也没有去录下个GIF来，因为这篇主要说一下<code>CoordinatorLayout</code>的处理嵌套滑动的原理，没有效果图也影响不大。<a id="more"></a></p>
<h4 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h4><p>感觉好久没有写点东西，写起来很是生疏，不知道该怎么去写一篇博客了，那就先写出来点大纲吧，说到哪是哪。这篇主要分这几部分吧</p>
<ul>
<li>为什么要有<code>CoordinatorLayout</code> </li>
<li><code>CoordinatorLayout</code>是怎么实现嵌套滑动的事件分发的</li>
<li><code>AppBarLayout</code>的一些东西</li>
</ul>
<h4 id="为什么要有CoordinatorLayout"><a href="#为什么要有CoordinatorLayout" class="headerlink" title="为什么要有CoordinatorLayout"></a>为什么要有<code>CoordinatorLayout</code></h4><p>先来回想一下<code>Android</code>系统的事件分发有什么不足的地方，当然我觉得<code>Android</code>的事件分发写的也是十分的巧妙。这里就不去再多说事件分发的东西，说一下这样的一个场景，就是下面一个类似<code>list</code>的可滚动区域，上面是一个头，这种场景在很多的个人中心的地方比较常见。如果要去实现这样的效果，传统的做法就是外面包一层parent，当然直接去处理list的滑动事件应该也是可以的，我觉得包一层比较好写点，让这个parent去分发事件和处理事件。好吧，我有点不知道说什么了，还是直接说事件分发的不足的地方吧，就是一个view消费了事件，与此同时，其他的view的没有机会去接触到这个事件了，这样当遇到上面说的情况，就是嵌套滑动的时候，我们需要上下两个view都能同时接触到这个事件，处理不处理就让他们自己去决定了。这样我觉得实现嵌套滑动的情况就好多了，因为都有机会去消费掉这个事件，无论事件是在哪个view上面，其实就是类似再外面包了一层parent的效果，这就是<code>CoordinatorLayout</code> 帮我们做的事件，靠，我写的好烂啊。。真的说不清楚这些。</p>
<h4 id="CoordinatorLayout是怎么实现嵌套滑动的事件分发的"><a href="#CoordinatorLayout是怎么实现嵌套滑动的事件分发的" class="headerlink" title="CoordinatorLayout是怎么实现嵌套滑动的事件分发的"></a><code>CoordinatorLayout</code>是怎么实现嵌套滑动的事件分发的</h4><p>先说一下两个接口吧，<code>NestedScrollingParent</code>和<code>NestedScrollingChild</code>，这两个接口看名字就比较容易理解他们的作用，就是一个给嵌套滑动的parent实现的，一个是给child实现，在选择的系统中，只有<code>CoordinatorLayout</code>实现了parent，所以下面说到parent就理解成<code>CoordinatorLayout</code>就OK啦，而child这个接口其实方法已经在<code>View</code>这个类里面帮我们实现好了，也就是说想要去成为一个可以嵌套滑动的child，仅仅去实现这个child接口就OK了，其他的<code>View</code>已经帮你写完了。下面还是以<code>RecycleView</code>为例子，它是实现了这个child的接口，还是回到情景里面说吧，说一下到底是怎么传递事件的。</p>
<ul>
<li>在<code>ReclceView</code>上down -&gt; <code>parent.onStartNestedScroll</code> -&gt;遍历有<code>Behavior</code>的直接子view -&gt;child的<code>Behavior.onStartNestedScroll</code>。<br>这里说一下<code>onStartNestedScroll</code>这个方法是有boolean的返回值，<code>true</code>的意思是要去处理这个事件，同时还会去调用<code>parent.onNestedScrollAccepted</code> -&gt; 遍历有<code>Behavior</code>的直接子view  -&gt;child的<code>Behavior.onNestedScrollAccepted</code>.这个方法里面可以做一些view配置的初始化。如果不需要当然可以不去重写。</li>
<li>在<code>RecycleView</code>上move -&gt; <code>dispatchNestedPreScroll</code>(也是child这个接口里面的)-&gt;<code>parent.onNestedPreScroll</code> -&gt; 遍历有<code>Behavior</code>的直接子view  -&gt;child的<code>Behavior.onNestedPreScroll</code>,同时之后还有一个流程也是在move的时候触发的 -&gt;<code>dispatchNestedScroll</code>(也是child这个接口里面的) -&gt;<code>parent.onNestedScroll</code> -&gt; 遍历有<code>Behavior</code>的直接子view  -&gt;child的<code>Behavior.onNestedScroll</code>.。这两个的主要区别的pre那个方法里面可以去处理消费了多少的滑动距离，比如手指滑动了12px,你可以选择把consumed[1]赋值为2，那么head就移动(消费)了2px，剩下的10px就给了下面的recycleview，而在<code>onNestedScroll</code>方法中还有机会去已经消费的和没有消费的距离再进行一次处理。</li>
<li>在<code>RecycleView</code>上面up -&gt; <code>stopNestedScroll</code>(也是child这个接口里面的) -&gt;<code>parent.onStopNestedScroll</code> -&gt; 遍历有<code>Behavior</code>的直接子view  -&gt;child的<code>Behavior.onStopNestedScroll</code>。</li>
<li>还有两个关于<code>Fling</code>的方法，就不说了，一个套路。</li>
</ul>
<p>还有就是再说一下<code>CoordinatorLayout</code>的<code>onInterceptTouchEvent</code>和<code>onTouchEvent</code>，这里贴一下代码吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">       final View child = topmostChildList.get(i);</div><div class="line">       final LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line">       final Behavior b = lp.getBehavior();</div><div class="line"></div><div class="line">       if ((intercepted || newBlock) &amp;&amp; action != MotionEvent.ACTION_DOWN) &#123;</div><div class="line">           // Cancel all behaviors beneath the one that intercepted.</div><div class="line">           // If the event is &quot;down&quot; then we don&apos;t have anything to cancel yet.</div><div class="line">           if (b != null) &#123;</div><div class="line">               if (cancelEvent == null) &#123;</div><div class="line">                   final long now = SystemClock.uptimeMillis();</div><div class="line">                   cancelEvent = MotionEvent.obtain(now, now,</div><div class="line">                           MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0);</div><div class="line">               &#125;</div><div class="line">               switch (type) &#123;</div><div class="line">                   case TYPE_ON_INTERCEPT:</div><div class="line">                       b.onInterceptTouchEvent(this, child, cancelEvent);</div><div class="line">                       break;</div><div class="line">                   case TYPE_ON_TOUCH:</div><div class="line">                       b.onTouchEvent(this, child, cancelEvent);</div><div class="line">                       break;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           continue;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (!intercepted &amp;&amp; b != null) &#123;</div><div class="line">           switch (type) &#123;</div><div class="line">               case TYPE_ON_INTERCEPT:</div><div class="line">                   intercepted = b.onInterceptTouchEvent(this, child, ev);</div><div class="line">                   break;</div><div class="line">               case TYPE_ON_TOUCH:</div><div class="line">                   intercepted = b.onTouchEvent(this, child, ev);</div><div class="line">                   break;</div><div class="line">           &#125;</div><div class="line">           if (intercepted) &#123;</div><div class="line">               mBehaviorTouchView = child;</div><div class="line">           &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>可以看出，每个直接的childview都会接受到拦截事件，即使你的手势不是在这个child上面触发的。</p>
<ul>
<li>还有个方法就是<code>layoutDependsOn</code>这个方法是在哪里调用的，这个是在onpredraw的时候就调用了，也就是没显示之前就已经开始准备各个view直接的依赖关系。当然内部实现也是在parent里面去便利child来实现的，也就只有parent可以获取到所有的child。</li>
</ul>
<h4 id="AppBarLayout的一些东西"><a href="#AppBarLayout的一些东西" class="headerlink" title="AppBarLayout的一些东西"></a><code>AppBarLayout</code>的一些东西</h4><p>我觉得<code>AppBarLayout</code>这个组件还是十分重要的，特别是里面的两个<code>Behavior</code>的实现，给了我们很好的参考的例子。具体的还是去看源码吧，太多了要说也是再开一篇。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;这是一篇重新写的东西，之前写过一点，但是烂尾了，我也很久没有去写点东西了，也是很惭愧，之前打算的事情也没有坚持下来。最近这一周空余的时间比较多，然后去重构了一个公司项目里的一个个人中心的页面，原来使用了&lt;code&gt;ListView&lt;/code&gt;再加上&lt;code&gt;addHead&lt;/code&gt;的方式，然后动态的去控制&lt;code&gt;Head&lt;/code&gt;的高度去实现嵌套滑动的效果，因为我的模拟器没有跑起来，所以也没有去录下个GIF来，因为这篇主要说一下&lt;code&gt;CoordinatorLayout&lt;/code&gt;的处理嵌套滑动的原理，没有效果图也影响不大。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>自定义控件学习笔记</title>
    <link href="http://yoursite.com/2016/08/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/08/01/自定义控件学习笔记/</id>
    <published>2016-08-01T14:24:32.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>#Canvas</p>
<p>##canvas简介<br>&emsp;&emsp;每个canvas都有bitmap为其保存像素，canvas有两个构造函数，无参函数和一个bitmap参数的函数，<code>Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);  
        Canvas canvas = new Canvas(bitmap);</code>这样就创建了一个canvas对象，Android推荐使用有参函数。其实无参和有参数的构造函数都是需要创建一个bitmap，无参会默认创建一个。一个canvas需要一个bitmap来保存像素信息，当然也是可以没有bitmap，但是画的东西没有地方保存，也就没有意义。<a id="more"></a></p>
<p>##canvas的主要方法<br>&emsp;&emsp;canvas主要有几种方法，draw…这类方法是用来画一下东西的，clip…就是用来裁剪的，还有scale,translate，skew，rotate是用来进行画布的变换，还有saveXXX和restoreXXX构成的画布锁定和还原。</p>
<p>##裁剪画布<br>&emsp;&emsp;裁剪画布可以裁剪规则区域<code>canvas.clipRect</code>和裁剪不规则的区域<code>canvas.clippath</code>，第一个就是传进去一个矩形，然后裁剪剩下矩形区域的画布，第二个就是按路径裁剪。还有就是Region.Op，中文就是区域，这个在API21弃用了，但是还是写一下吧，这个就跟图形的组合模式差不多，Region.Op是个枚举类，<br><img src="http://img.blog.csdn.net/20141216162324031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWlnZXN0dWRpbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>使用举例：</p>
<pre><code>// 填充颜色  
canvas.drawColor(Color.BLUE);  

canvas.save();  

// 裁剪区域A  
canvas.clipRegion(mRegionA);  

// 再通过组合方式裁剪区域B  
canvas.clipRegion(mRegionB, Region.Op.DIFFERENCE);  

// 填充颜色  
canvas.drawColor(Color.RED);  

canvas.restore(); 
</code></pre><p>Rect、Cricle、Ovel等封闭的曲线都可以使用Region.Op。Region和Rect有什么区别呢？首先最重要的一点，Region表示的是一个区域，而Rect表示的是一个矩形，这是最根本的区别之一，其次，Region有个很特别的地方是它不受Canvas的变换影响，Canvas的local不会直接影响到Region自身。</p>
<p>##Path<br>&emsp;&emsp;使用路径可以做出很多很有意思的图形或者动画，<br>先从简单的开始，<code>path.lineto()</code>这个是用来画直线，如果不设置起点，则是默认从（0.0）为起点，可以使用<code>path。moveto(x,y)</code>来将起点移动到合适的位置。要绘制一个闭合的图形，可以使用<code>paht.close()</code>可以自动将最后一个点和最初的一个点进行连接构成封闭的图形。</p>
<p>###贝塞尔曲线<br>&emsp;&emsp;要绘制贝塞尔曲线可以使用<code>quadTo(float x1, float y1, float x2, float y2)</code>前两个是控制点，后两个是终点。控制点就像一个磁铁，去吸引橡皮条上的另一个磁铁，橡皮条弯曲成一个曲线就类似控制点控制的贝塞尔曲线。<img src="http://img.blog.csdn.net/20141216160213685" alt=""><br>再来两张动图吧，这个的从<a href="http://blog.csdn.net/aigestudio/article/details/41960507" target="_blank" rel="external">爱歌</a>的<a href="http://blog.csdn.net/column/details/androidcustomview.html" target="_blank" rel="external">Android自定义控件其实很简单</a>专栏里面偷得，这篇博客也是看着他的博客总结的。</p>
<ul>
<li>一阶贝塞尔曲线<br><img src="http://img.blog.csdn.net/20141216154914760" alt=""></li>
<li>二阶贝塞尔曲线<br><img src="http://img.blog.csdn.net/20141216155508803" alt=""></li>
<li>三阶贝塞尔曲线<br><img src="http://img.blog.csdn.net/20141216155707332" alt=""></li>
<li>四阶贝塞尔曲线<br><img src="http://img.blog.csdn.net/20141216155817984" alt=""></li>
<li>五阶贝塞尔曲线<br><img src="http://img.blog.csdn.net/20141216155848359" alt=""><br>看着就挺爽的。在Android中除了上面提到的<code>quadTo(float x1, float y1, float x2, float y2)</code>来绘制二阶贝塞尔曲线，还有<code>cubicTo(float x1, float y1, float x2, float y2, float x3, float y3)</code>来实现三阶贝塞尔曲线。类似下面的<img src="http://img.blog.csdn.net/20141216160322419" alt=""><br>我们使用贝塞尔曲线主要就是要去控制它的起点终点和控制点。之前看网上写过一个类似QQ气泡拖拽消失的例子，地址：<a href="https://github.com/70kg/Android-Studio-Project/blob/master/app/src/main/java/com/com/mr_wrong/Bezier/BezierView.java" target="_blank" rel="external">我的GitHub</a>原理比较简单，就是计算各个点的坐标比较复杂一些。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Canvas&lt;/p&gt;
&lt;p&gt;##canvas简介&lt;br&gt;&amp;emsp;&amp;emsp;每个canvas都有bitmap为其保存像素，canvas有两个构造函数，无参函数和一个bitmap参数的函数，&lt;code&gt;Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);  
        Canvas canvas = new Canvas(bitmap);&lt;/code&gt;这样就创建了一个canvas对象，Android推荐使用有参函数。其实无参和有参数的构造函数都是需要创建一个bitmap，无参会默认创建一个。一个canvas需要一个bitmap来保存像素信息，当然也是可以没有bitmap，但是画的东西没有地方保存，也就没有意义。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>RxJava和Retrofit的那些事</title>
    <link href="http://yoursite.com/2016/08/01/RxJava%E5%92%8CRetrofit%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2016/08/01/RxJava和Retrofit的那些事/</id>
    <published>2016-08-01T14:24:32.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>##关于Retrofit<br>这是一个最近很火的网络请求库，官网在这<a href="http://square.github.io/retrofit/" target="_blank" rel="external">官网</a>,当然这也是一个开源的项目<a href="https://github.com/square/retrofit" target="_blank" rel="external">GitHub地址</a>。可能你对这个不是很熟悉，但是说起他的兄弟，okhttp估计就比较熟悉了，还有大名鼎鼎的依赖注入dagger和图片加载库picasso还有检查内存泄露的LeakCanary都是出自Square公司。当然这只是在JAVA和Android端，在js和Python上也有很棒的项目，有兴趣就自己看了，扯远了。。<a id="more"></a></p>
<p>为什么要用Retrofit呢，因为他除了提供给我们常见的请求Callback形式，还封装了Observable的请求形式，这就很方便的支持了Rxjava,而Rxjava的强大就是体现在异步任务上。下面来简单的介绍一下使用。</p>
<p>对于RxJava的语法就不说了，有一篇写了关于这方面的，下面就直接开始了。</p>
<p>以github的开放API作为数据来源，我们要去获取某个项目的contributors，以square的retrofit为例，可以调用这个<code>https://api.github.com/repos/square/retrofit/contributors</code>返回的json是这样的array</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">login: &quot;JakeWharton&quot;,</div><div class="line">id: 66577,</div><div class="line">avatar_url: &quot;https://avatars.githubusercontent.com/u/66577?v=3&quot;,</div><div class="line">gravatar_id: &quot;&quot;,</div><div class="line">url: &quot;https://api.github.com/users/JakeWharton&quot;,</div><div class="line">html_url: &quot;https://github.com/JakeWharton&quot;,</div><div class="line">followers_url: &quot;https://api.github.com/users/JakeWharton/followers&quot;,</div><div class="line">following_url: &quot;https://api.github.com/users/JakeWharton/following&#123;/other_user&#125;&quot;,</div><div class="line">gists_url: &quot;https://api.github.com/users/JakeWharton/gists&#123;/gist_id&#125;&quot;,</div><div class="line">starred_url: &quot;https://api.github.com/users/JakeWharton/starred&#123;/owner&#125;&#123;/repo&#125;&quot;,</div><div class="line">subscriptions_url: &quot;https://api.github.com/users/JakeWharton/subscriptions&quot;,</div><div class="line">organizations_url: &quot;https://api.github.com/users/JakeWharton/orgs&quot;,</div><div class="line">repos_url: &quot;https://api.github.com/users/JakeWharton/repos&quot;,</div><div class="line">events_url: &quot;https://api.github.com/users/JakeWharton/events&#123;/privacy&#125;&quot;,</div><div class="line">received_events_url: &quot;https://api.github.com/users/JakeWharton/received_events&quot;,</div><div class="line">type: &quot;User&quot;,</div><div class="line">site_admin: false,</div><div class="line">contributions: 619</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>这里我们只使用到<code>login</code>和<code>contributions</code></p>
<p> 1.定义一个接口，这个看代码就明白了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface GithubApi &#123;</div><div class="line"> @GET(&quot;/repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</div><div class="line">    Observable&lt;List&lt;Contributor&gt;&gt; contributors(@Path(&quot;owner&quot;) String owner,</div><div class="line">                                               @Path(&quot;repo&quot;) String repo);</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>通过注解来提供参数，这里注解有很多，还有<code>@Query</code>，<code>@QueryMap</code>，<code>@Body</code>等等，也可以通过<code>@Headers</code>设置请求头。参数基于base url,其实就是拼接成的。这个返回的是一个<code>Observable</code>，这样就很方便的去发布一个事件了。</p>
<p> 2.设置<code>RestAdapter</code>和<code>service</code>,先用<code>Endpoint(API)</code>并调用buid()方法来创建一个RestAdapter对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RestAdapter adapter = new RestAdapter.Builder().setEndpoint(</div><div class="line">              &quot;https://api.github.com/&quot;).setLogLevel(RestAdapter.LogLevel.FULL).build();</div></pre></td></tr></table></figure>
<p>然后使用我们的adapter来创建一个服务适配器(service for adapter)。<code>adapter.create(GithubApi.class);</code><br>完整的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private GithubApi _createGithubApi() &#123;</div><div class="line">      RestAdapter adapter = new RestAdapter.Builder().setEndpoint(</div><div class="line">            &quot;https://api.github.com/&quot;).setLogLevel(RestAdapter.LogLevel.FULL).build();</div><div class="line"></div><div class="line">      return adapter.create(GithubApi.class);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p> 3.这就到了Rxjava的地方了，上一步获取到了GithubApi对象，就可以去调用函数了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">_subscriptions.add(</div><div class="line">                _api.contributors(_username.getText().toString(), _repo.getText().toString())//事件源</div><div class="line">                        .subscribeOn(Schedulers.io())</div><div class="line">                        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">                        .subscribe(new Observer&lt;List&lt;Contributor&gt;&gt;() &#123;//订阅者</div><div class="line">                            @Override</div><div class="line">                            public void onCompleted() &#123;</div><div class="line">                                </div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            @Override</div><div class="line">                            public void onError(Throwable e) &#123;</div><div class="line">                               </div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            @Override</div><div class="line">                            public void onNext(List&lt;Contributor&gt; contributors) &#123;</div><div class="line">                                for (Contributor c : contributors) &#123;</div><div class="line">                                    _adapter.add(format(&quot;%s has made %d contributions to %s&quot;,</div><div class="line">                                            c.login,</div><div class="line">                                            c.contributions,</div><div class="line">                                            _repo.getText().toString()));</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;));</div></pre></td></tr></table></figure>
<p>当然这是一个比较简单的处理过程，并没有用到一下通配符，但是基本的流程就是这样的。</p>
<p>到现在发现我们并没有去解析json数据就自动生成了bean类，这是因为Retrofit已经集成了Gson，并且默认使用Gson来进行解析，当然你也可以自己去定义。在创建<code>RestAdapter</code>的时候使用<code>setConverter(new GsonConverter(gson))</code>。默认是使用okhttp进行加载的，当然你也可以去配置一些关于<code>OkHttpClient</code>的数据，然后通过<code>setClient(new OkClient(client))</code>进行设置进去。</p>
<p>现在<code>Retrofit</code>的2.0版本已经出了，主要就是 取消了同步和异步，可以取消正在进行中的业务，取消了Gson的依赖等等，具体可以看这里<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0915/3460.html" target="_blank" rel="external">Retrofit 2.0：有史以来最大的改进</a><br>这篇参考了GitHub上的项目<a href="https://github.com/70kg/RxJava-Android-Samples" target="_blank" rel="external">RxJava-Android-Samples</a>，这里只是拣取了关于Retrofit的部分，有兴趣可以看看其他的。</p>
<p>参考：<br><a href="http://www.tuicool.com/articles/26jUZjv" target="_blank" rel="external">http://www.tuicool.com/articles/26jUZjv</a><br><a href="http://www.cnblogs.com/angeldevil/p/3757335.html" target="_blank" rel="external">http://www.cnblogs.com/angeldevil/p/3757335.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##关于Retrofit&lt;br&gt;这是一个最近很火的网络请求库，官网在这&lt;a href=&quot;http://square.github.io/retrofit/&quot;&gt;官网&lt;/a&gt;,当然这也是一个开源的项目&lt;a href=&quot;https://github.com/square/retrofit&quot;&gt;GitHub地址&lt;/a&gt;。可能你对这个不是很熟悉，但是说起他的兄弟，okhttp估计就比较熟悉了，还有大名鼎鼎的依赖注入dagger和图片加载库picasso还有检查内存泄露的LeakCanary都是出自Square公司。当然这只是在JAVA和Android端，在js和Python上也有很棒的项目，有兴趣就自己看了，扯远了。。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 5.0 Transition介绍</title>
    <link href="http://yoursite.com/2016/07/09/transition%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2016/07/09/transition介绍/</id>
    <published>2016-07-09T15:38:49.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>###扯淡<br>之所以写这篇是因为看到别人写的APP都很酷炫，了解到之后发现5.0之后的动画丰富了那么多，特别是共享元素和圆形展开那个(不知道是不是这么叫的)特别酷，就去了解了一下。再加上我最近才上的5.0，终于有真机可以进行调试了，看到动画在自己手机上运行，还是挺有成就感的😂。<a id="more"></a><br>下面的文章来自国外的一篇译文，摘抄自泡网，我在这个dome上也注释了一些，<a href="">地址</a>.</p>
<p>##Activity和Fragment Transition介绍</p>
<p>###什么是Transition?<br>安卓5.0中Activity和Fragment 变换是建立在名叫Transitions的安卓新特性之上的。这个诞生于4.4的transition框架为在不同的UI状态之间产生动画效果提供了非常方便的API。该框架主要基于两个概念：场景（scenes）和变换（transitions）。场景（scenes）定义了当前的UI状态，变换（transitions）则定义了在不同场景之间动画变化的过程。虽然transition翻译为变换似乎很确切，但是总觉得还是没有直接使用transition直观，为了更好的理解下面个别地方直接用transition代表变换。</p>
<p>当一个场景改变的时候，transition主要负责：</p>
<p>（1）捕捉每个View在开始场景和结束场景时的状态。</p>
<p>（2）根据两个场景（开始和结束）之间的区别创建一个Animator。</p>
<p>考虑这样一个例子，当用户点击屏幕，让activity中的view逐渐消失。使用安卓的transition框架，我们只需几行代码就可完成，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class ExampleActivity extends Activity implements View.OnClickListener &#123;</div><div class="line">    private ViewGroup mRootView;</div><div class="line">    private View mRedBox, mGreenBox, mBlueBox, mBlackBox;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        mRootView = (ViewGroup) findViewById(R.id.layout_root_view);</div><div class="line">        mRootView.setOnClickListener(this);</div><div class="line">        mRedBox = findViewById(R.id.red_box);</div><div class="line">        mGreenBox = findViewById(R.id.green_box);</div><div class="line">        mBlueBox = findViewById(R.id.blue_box);</div><div class="line">        mBlackBox = findViewById(R.id.black_box);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void onClick(View v) &#123;</div><div class="line">        TransitionManager.beginDelayedTransition(mRootView, new Fade());</div><div class="line">        toggleVisibility(mRedBox, mGreenBox, mBlueBox, mBlackBox);</div><div class="line">    &#125;</div><div class="line">    private static void toggleVisibility(View... views) &#123;</div><div class="line">        for (View view : views) &#123;</div><div class="line">            boolean isVisible = view.getVisibility() == View.VISIBLE;</div><div class="line">            view.setVisibility(isVisible ? View.INVISIBLE : View.VISIBLE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了更好的理解幕后发生的事情，让我们来一步一步的分析，假设最开始每个view都是可见的：</p>
<p>（1）当点击事件发生之后调用TransitionManager的beginDelayedTransition()方法，并且传递了mRootView和一个Fade对象最为参数。之后，framework会立即调用transition类的captureStartValues()方法为每个view保存其当前的可见状态(visibility)。</p>
<p>（2）当beginDelayedTransition返回之后，在上面的代码中将每个view设置为不可见。</p>
<p>（3）在接下来的显示中framework会调用transition类的captureEndValues()方法，记录每个view最新的可见状态。</p>
<p>（4）接着，framework调用transition的createAnimator()方法。transition会分析每个view的开始和结束时的数据发现view在开始时是可见的，结束时是不可见的。Fade（transition的子类）会利用这些信息创建一个用于把view的alpha属性变为0的AnimatorSet，并且将此AnimatorSet对象返回。</p>
<p>（5）framework会运行返回的Animator，导致所有的View都渐渐消失。</p>
<blockquote>
<p>编者注：读者可以在这里回想假如不使用transition框架，我们自己使用属性动画（Animator）来实现是不是复杂很多，其实transition框架的作用就是封装了属性动画的操作。</p>
</blockquote>
<p>这个简单的例子强调了transition框架的两个主要优点。第一、Transitions抽象和封装了属性动画，Animator的概念对开发者来说是透明的，因此它极大的精简了代码量。开发者所做的所有事情只是改变一下view前后的状态数据，Transition就会自动的根据状态的区别去生成动画效果。第二、不同场景之间变换的动画效果可以简单的通过使用不同的Transition类来改变，本例中用的是Fade。<br><img src="http://jcodecraeer.com/uploads/20150113/1421146073174536.gif" alt=""><br>实现上图中的那两个不同的动画效果可以将Fade替换成Slide或者Explode即可。在接下来的文章中你将会发现，这些优点将使得我们只用少量代码就可以创建复杂的Activity 和Fragment切换动画。在接下来的小节中，将看到是如何使用Lollipop的Activity 和Fragment transition API来实现这种变换的。</p>
<p>###5.0中的Activity和Fragment Transition<br>Android 5.0中Transition可以被用来实现Activity或者Fragment切换时的异常复杂的动画效果。虽然在以前的版本中，已经可以使用Activity的overridePendingTransition() 和 FragmentTransaction的setCustomAnimation()来实现Activity或者Fragment的动画切换，但是他们仅仅局限与将整个视图一起动画变换。新的Lollipop api更进了一步，让单独的view也可以在进入或者退出其布局容器中时发生动画效果，甚至还可以在不同的activity/Fragment中共享一个view。</p>
<p>在开始讲解之前我们先做一些约定，虽然下面的约定是针对activity的，但是在Fragment中也是一样的约定。</p>
<blockquote>
<p>A和B分别是两个Activity，假设activity A 调用activity B。将A代表调用Activity ，B代表被调用Activity。</p>
</blockquote>
<p>Activity transition API围绕退出（exit），进入（enter），返回（return）和再次进入（reenter）四种transition。按照上面对A和B的约定，我这样描述这一过程。</p>
<blockquote>
<p>Activity A的退出变换（exit transition）决定了在A调用B的时候，A中的View是如何播放动画的。</p>
<p>Activity B的进入变换（enter transition）决定了在A调用B的时候，B中的View是如何播放动画的。</p>
<p>Activity B的返回变换（return transition）决定了在B返回A的时候，B中的View是如何播放动画的。</p>
<p>Activity A的再次进入变换（reenter transition）决定了在B返回A的时候，A中的View是如何播放动画的。</p>
</blockquote>
<p>最后framework提供了两种Activity transition- 内容transition和共享元素的transition：<br><img src="http://jcodecraeer.com/uploads/150113/1-150113195F54J.gif" alt=""><br>上图中演示了Google Play Newsstand 应用的效果，虽然我们无法查看它的源码，但是我敢打赌它用了以下的transition：</p>
<blockquote>
<p>activity A 中exit和reenter transition是为null的，因为A中的非共享view在退出和再次进入的时候没有动画效果。</p>
<p>activity B中的enter content transition使用了自定义的slide-in变换。该变换使B中list的元素从下到上过度。</p>
<p>activity B中return content transition是一组TransitionSet，同时播放了两个子元素的变换：上半部分和下半部分的slide变换。看起来就像整个界面被从从中间分割成了两半。</p>
<p>enter and return 共享元素变换是用了ChangeImageTransform。让两个activity中的ImageView无缝切换。</p>
</blockquote>
<p>你可能还注意到了在共享元素变换播放的同时还有个圆形水波效果的动画。我们将在以后的博客中讨论如何实现。目前为了是问题更简单，我们主要讨论熟悉的activity变换。</p>
<p>###Activity Transition API介绍<br>用5.0的API创建一个基本的Activity transition是较为简单的。下面的总结是实现Activity transition的步骤。这篇文章主要是对Activity transition做简单的介绍，作为引入的篇章。在后续的文章中我们再介绍一些高级的用法。</p>
<p>1.在调用与被调用的activity中，通过设定Window.FEATURE_ACTIVITY_TRANSITIONS  和 Window.FEATURE_CONTENT_TRANSITIONS 来启用transition api ，可以通过代码也可以通过设置主题来启用：</p>
<p>代码方式，在setContentView之前调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);</div></pre></td></tr></table></figure>
<p>主题xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;item name=&quot;android:windowContentTransitions&quot;&gt;true&lt;/item&gt;</div></pre></td></tr></table></figure>
<p>2.分别在调用与被调用的activity中设置exit 和enter transition。Material主题默认会将exit的transition设置成null而enter的transition设置成Fade .如果reenter 或者 return transition没有明确设置，则将用exit 和enter的transition替代。</p>
<p>3.分别在调用与被调用的activity中设置exit 和enter 共享元素的transition。Material主题默认会将exit的共享元素transition设置成null而enter的共享元素transition设置成@android:transition/move.如果reenter 或者 return transition没有明确设置，则将用exit 和enter的共享元素transition替代。开始一个activity的content transaction需要调用startActivity(Context, Bundle)方法，将下面的bundle作为第二个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ActivityOptions.makeSceneTransitionAnimation(activity, pairs).toBundle();</div></pre></td></tr></table></figure>
<p>其中pairs参数是一个数组：Pair<view, string=""> ，该数组列出了你想在activity之间共享的view和view的名称。别忘了给你的共享元素加上一个唯一的名称，否则transition可能不会有正确的结果。</view,></p>
<p>4.在代码中触发通过finishAfterTransition()方法触发返回动画，而不是调用finish()方法。</p>
<p>5.默认情况下，material主题的应用中enter/return的content transition会在exit/reenter的content transitions结束之前开始播放（只是稍微早于），这样会看起来更加连贯。如果你想明确屏蔽这种行为，可以调用setWindowAllowEnterTransitionOverlap() 和 setWindowAllowReturnTransitionOverlap()方法。</p>
<p>###Fragment Transition API介绍</p>
<p>如果你想在Fragment中使用transition，除了一小部分区别之外和activity大体一致：</p>
<p>1.Content的exit, enter, reenter, 和return transition需要调用fragment的相应方法来设置，或者通过fragment的xml属性来设置。</p>
<p>2.共享元素的enter和return transition也n需要调用fragment的相应方法来设置，或者通过fragment的xml属性来设置。</p>
<p>3.虽然在activity中transition是被startActivity()和finishAfterTransition()触发的，但是Fragment的transition却是在其被FragmentTransaction执行下列动作的时候自动发生的。added, removed, attached, detached, shown, ，hidden。</p>
<p>4.在Fragment commit之前，共享元素需要通过调用addSharedElement(View, String) 方法来成为FragmentTransaction的一部分。</p>
<p>总结<br>在本文中，我们仅仅是对新的Activitiy 和Fragment transition API做了一个简单的介绍。但是在接下来的文章中你会看到对基础概念的掌握会让你以后学习的更快，尤其是当你要做一些自定义Transition的时候。后面的文章中我们将更深入的去理解content transition和hared element transition，同时对Activity 和Fragment transition的工作原理有更深的理解。</p>
<p>##深入理解Content Transition</p>
<p>###什么是Content Transition<br>content transition决定了非共享view元素在activity和fragment切换期间是如何进入或者退出场景的。根据google最新的Material Design设计语言，content transition让我们毫不费力的去协调Activity/Fragment切换过程中view的进入和退出，让这个过程更流畅。在5.0之后content transition可以通过调用Window和Fragment的如下代码来设置：</p>
<p>ps:还记得上篇文章中对A和B的约定吗</p>
<p>(1)setExitTransition() - 当A start B时，使A中的View退出场景的transition</p>
<p>(2)setEnterTransition() - 当A start B时，使B中的View进入场景的transition</p>
<p>(3)setReturnTransition() - 当B 返回 A时，使B中的View退出场景的transition</p>
<p>(4)setReenterTransition() - 当B 返回 A时，使A中的View进入场景的transition</p>
<p>以下图为例，演示了google play Games app如何通过content transition实现activity之间的平滑切换。当第二个activity开始的时候，enter  transition让用户的头像从底部边缘慢慢滑入。而在activity退出的时候，屏幕被分成两半，各自消失在上下边缘。<br><img src="http://www.jcodecraeer.com/uploads/20150116/1421395105402519.gif" alt=""><br>到目前位置我们只是肤浅的勾勒出了content transition轮廓，有几个非常重要的问题仍然存在。content transition触发的内部机制，有哪些Transition类可用？framework如何确定哪些view是transitioning view？ViewGroup和它的孩子可以被作为一个整体播放动画吗？，我们将逐个解答。</p>
<p>###Content Transition内部揭秘<br>回忆上篇文章的内容，一个Transition主要有两个职责：捕获目标view的开始和结束时的状态、创建一个用于在两个状态之间播放动画的Animator。Content transition同样如此：在Content transition动画（animation）创建之前，framework必须通过设置transitioning view的visibility将动画需要的状态信息告诉animation。具体来说，当Activity A startsActivity B之时，发生了如下的事件：</p>
<p>一、Activity A 调用startActivity().<br>    1.framework遍历A的View树，确定当A的exit transition运行时哪些view会退出场景（即哪些view是transitioning view）。<br>    2.A的exit transition捕获A中transitioning view的开始状态。<br>    3.framework将A中所有的transitioning view设置为INVISIBLE。<br>    4.A的exit transition捕获到A中transitioning view的结束状态。<br>    5.A的exit transition比较每个transitioning view的开始和结束状态，然后根据前后状态的区别创建一个Animator。Animator开始运行，同时transitioning view退出场景。</p>
<p>二、Activity B启动.<br>    1.framework遍历B的View树，确定当B的enter transition运行时哪些view会进入场景，transitioning view会被初始化为INVISIBLE。<br>    2.B的enter transition捕获B中transitioning view的开始状态。<br>    3.framework将B中所有的transitioning view设置为VISIBLE。<br>    4.B的enter transition捕获到B中transitioning view的结束状态。<br>    5.B的enter transition比较每个transitioning view的开始和结束状态，然后根据前后状态的区别创建一个Animator。Animator开始运行，同时transitioning view进入场景。</p>
<p>通过在每个transitioning view中来回切换INVISIBLE 和VISIBLE，framework确保content transition得到创建animation（期望的animation）所需的状态信息。显然content Transition对象需要在开始和结束场景中都能记录到transitioning view的visibility。 非常幸运的是抽象类Visibility已经为你做了这些工作：Visibility的子类只需要实现onAppear() 和 onDisappear() 两个工厂方法，在这两个工厂方法中创建并返回一个进入或者退出场景的Animator对象。在api 21中，有三个现成的Visibility的实现：Fade, Slide, 和 Explode</p>
<p>他们都可以用在Activity 和 Fragment中创建content transition。如果必要，还可以自定义Visibility，这将在今后的文章中讲解。</p>
<p>###Transitioning Views以及Transition Groups<br>到目前为止，我们假设了content transition是操作非共享元素的（即提到了很多次的transitioning view）。在本节，我们将讨论framework是如何决定transitioning view的集合以及如何使用transition groups自定义它。</p>
<p>在transition开始之前，framework通过递归遍历Activity（或者Fragment）的Window中的View树来决定transitioning view的集合。整个搜索过程开始在根view中调用ViewGroup的captureTransitioningView方法，captureTransitioningView的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void captureTransitioningViews(List&lt;View&gt; transitioningViews) &#123;</div><div class="line">    if (getVisibility() != View.VISIBLE) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (isTransitionGroup()) &#123;</div><div class="line">        transitioningViews.add(this);</div><div class="line">    &#125; else &#123;</div><div class="line">        int count = getChildCount();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            View child = getChildAt(i);</div><div class="line">            child.captureTransitioningViews(transitioningViews);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个递归的过程比较简单粗暴：framework跟踪不同级别的view树直到它找到一个VISIBLE的叶子view或者是一个transition group。transition group允许我们将整个ViewGroup作为一个整体来变换。如果一个ViewGroup的isTransitionGroup()方法返回true，则它的所有孩子都将被视为一个整体一起播放动画。否则将会继续递归该ViewGroup，其子view也会在动画的时候被单独对待。遍历的最后结果是一个完整的transitioning view的集合将在content transition的时候播放动画。</p>
<blockquote>
<p>注：默认情况下，isTransitionGroup()将在ViewGroup有背景或者有transition name的时候返回true（参见documentation 中对该方法的声明）。</p>
</blockquote>
<p>以下图为例，在整个过程中，用户的头像先是作为一个单独的元素渐渐的进入到下一个界面，而在返回的时候他又是和其他元素一起作为一个整体被动画。google play Games 中貌似用的是transition group来实现将屏幕分成两半的效果。</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150116/1421395183295370.gif" alt=""><br>有时候transition groups被用来修改一些Activity切换是出现的莫名其妙的bug。还是以上图为例，calling Activity 显示了封面图片的相册界面，而被调用activity则显示了一个header的背景图片，共享的封面图片，一个webview。这个app使用了类似与Google Play Games的transition：从中间成两半，各自滑倒上下边缘。但是，仔细观察你会发现只有上部分有滑动的动画效果，Webview没有。</p>
<p>那么问题来了，到底是哪里没对？上面的结果证明WebView虽然是一个ViewGroup但是没有被系统认为是transition view。因此content transition没有在它上面运行。幸运的是我们可以在return transition之前的某个地方调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webView.setTransitionGroup(true)</div></pre></td></tr></table></figure>
<p>来解决这个问题。</p>
<p>###总结<br>总的来说，本文涉及到了三个重要的方面：</p>
<p>1.content transition决定非共享元素（即transitioning view）在Activity切换的时候是如何变换的。</p>
<p>2.Content transition的触发是通过改变transitioning view的visibility来实现的。</p>
<p>3.Transition group让我们可以将ViewGroup作为一个整体来变换。</p>
<p>##深入理解共享元素变换（Shared Element Transition）-上</p>
<p>###什么是共享元素变换？<br>元素共享式变换（shared element transition）决定了共享的view元素从一个Activity/Fragment 到另一个Activity/Fragment t的切换中是如何动画变化的。共享元素在被调用Activity进入和返回时播放动画，共享元素在进入和返回时的变换效果通过window和Fragment的如下方法来设置：</p>
<p>进入：</p>
<p>setSharedElementEnterTransition()</p>
<p>设置在B进入时播放的动画，共享元素以A中的位置作为起始，B中的位置为结束来播放动画。</p>
<p>返回：</p>
<p>setSharedElementReturnTransition()</p>
<p>设置在B返回A时的动画，共享元素以B中的位置作为起始，A中的位置为结束来播放动画。</p>
<blockquote>
<p>注意，Activity Transition API 也可以使用 setSharedElementExitTransition() 和setSharedElementReenterTransition()方法分别设置共享元素的exit 和reenter 变换。但是一般来讲这是不必要的。如果你想看先关的例子，可以查看这篇博客<a href="https://halfthought.wordpress.com/2014/12/08/what-are-all-these-dang-transitions/" target="_blank" rel="external">this blog post</a>.至于为什么Fragment中没有共享元素的exit 和reenter 变换，请查看George Mount在stackoverflow上的回答:<a href="http://stackoverflow.com/q/27346020/844882" target="_blank" rel="external">this StackOverflow post</a>。</p>
</blockquote>
<p><img src="http://www.jcodecraeer.com/uploads/20150201/1422779465610233.gif" alt=""><br>上图演示了google play music应用中的共享元素变换效果。变换包含了两个共享的view元素：一个ImageView以及他的父亲CardView。ImageView在两个activity之间无缝的动画切换，而CardView则是渐渐的扩展到界面上。</p>
<p>在第一章中我们简单的介绍了这个话题，这篇文章则是更深入的去分析共享元素变换（shared element transition）。共享元素变换的原理是什么？有哪些共享元素变换效果可用？共享元素变换动画是如何绘制的，又是在哪里绘制的？接下来的小节中我们将一一回答。</p>
<p>###共享元素变换揭秘<br>从前两篇文章中我们知道，一个变换（Transition ）主要有两方面的职责：</p>
<p>捕获view开始和结束状态以及创建一能在两个状态间渐变的动画。共享元素变换没有什么不同。在共享元素变换开始之前，必须首先捕获每个共享元素的开始和结束状态（调用activity以及被调用activity中的位置、大小、外观），有了这些信息才能决定每个共享元素的入场动画。</p>
<p>和深入理解Content Transition 中类似，framework的共享元素变换是通过运行时改变其属性实现的，当Activity A 调用 Activity B ，发生的事件流如下：</p>
<p>1.Activity A调用startActivity()， Activity B被创建，测量，同时初始化为半透明的窗口和透明的背景颜色。</p>
<p>2.framework重新分配每个共享元素在B中的位置与大小，使其跟A中一模一样。之后，B的进入变换（enter transition）捕获到共享元素在B中的初始状态。</p>
<p>3.framework重新分配每个共享元素在B中的位置与大小，使其跟B中的最终状态一致。之后，B的进入变换（enter transition）捕获到共享元素在B中的结束状态。</p>
<p>4.B的进入变换（enter transition）比较共享元素的初始和结束状态，同时基于前后状态的区别创建一个Animator(属性动画对象)。</p>
<p>5.framework 命令A隐藏其共享元素，动画开始运行。随着动画的进行，framework 逐渐将B的activity窗口显示出来，当动画完成，B的窗口才完全可见。</p>
<p>与内容变换（content transition）取决于view的可见性不同（visibility），共享元素变换取决于每个共享元素的位置、大小以及外观。在api 21中，框架层提供了几个Transition 的实现，可以用于定义共享元素在场景中的切换效果。</p>
<p>ChangeBounds -捕获共享元素的layout bound，然后播放layout bound变化动画。ChangeBounds 是共享元素变换中用的最多的，因为前后两个activity中共享元素的大小和位置一般都是不同的。</p>
<p>ChangeTransform -  捕获共享元素的缩放（scale）与旋转（rotation）属性 ，然后播放缩放（scale）与旋转（rotation）属性变化动画。</p>
<p>ChangeClipBounds -  捕获共享元素clip bounds，然后播放clip bounds变化动画。</p>
<p>ChangeImageTransform -  捕获共享元素（ImageView）的transform matrices 属性，然后播放ImageViewtransform matrices 属性变化动画。与ChangeBounds相结合，这个变换可以让ImageView在动画中高效实现大小，形状或者ImageView.ScaleType 属性平滑过度。</p>
<p>@android:transition/move -  将上述所有变换同时进行的一个TransitionSet 。就如在第一章中所讲的一样，如果共享元素的进入和返回变换没有特别声明，框架将使用它作为默认的变换。</p>
<p>我们可以看到，共享元素变换并不是真正实现了两个activity或者Fragment之间元素的共享，实际上我们看到的几乎所有变换效果中（不管是B进入还是B返回A）,共享元素都是在B中绘制出来的。Framework没有真正试图将A中的某个元素传递给B，而是采用了不同的方法来达到相同的视觉效果。A传递给B的是共享元素的状态信息。B利用这些信息来初始化共享View元素，让它们的位置、大小、外观与在A中的时候完全一致。当变换开始的时候，B中除了共享元素之外，所有的其他元素都是不可见的。随着动画的进行，framework 逐渐将B的activity窗口显示出来，当动画完成，B的窗口才完全可见。</p>
<p>###使用共享元素的 Overlay<br>最后，我们需要讨论一下shared element overlay这个概念才算是对共享元素变换的绘制过程有了一个完整的了解。</p>
<p>虽然不是非常明显的可以看到，共享元素默认其实是绘制在整个view树结构的最上层，在一个叫ViewOverlay的东西上面。你可能没听说过ViewOverlay，他是4.3之后才有的一个新类，它是view的最上面的一个透明的层，添加到ViewOverlay上面的Drawable和view可以被绘制到任何东西的上面，甚至是ViewGroup的子元素。这似乎可以解释为什么framework 会选择ViewOverlay来作为共享元素变换的绘制空间了。<br>-关于ViewOverlay，除了官方解释还可以看看这篇文章：<a href="http://jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0130/2384.html" target="_blank" rel="external">ViewOverlay与animation介绍 </a><br>虽然共享元素默认是绘制在ViewOverlay上面，但是framework 还是提供了关闭这个选项的功能，调用Window的setSharedElementsUseOverlay(false) 方法。这样主要是为了防止万一有这样的开发需要。如果你选择了关闭overlay，那么请注意这是有一定副作用的。<br><img src="http://www.jcodecraeer.com/uploads/20150201/1422779979139164.gif" alt=""></p>
<p>在上图的效果中，我们运行了两次不同方式的动画，第二次便是关闭overlay之后的效果，我们可以明显的看到这导致了一个问题。</p>
<p>总之除非有一万个理由，否则不要关闭shared element overlay。</p>
<p>###总结<br>这篇文章涵盖了如下几个要点：</p>
<p>1.元素共享式变换（shared element transition）决定了共享的view元素从一个Activity/Fragment 到另一个Activity/Fragment t的切换中是如何动画变化的。</p>
<p>2.共享元素变换取决于每个共享元素的位置、大小以及外观。</p>
<p>3.共享元素默认其实是绘制在整个view树结构的最上层，在一个叫ViewOverlay的东西上面。</p>
<p>4.共享元素变换并不是真正实现了两个activity或者Fragment之间元素的共享，Framework采用了不同的方法来达到相同的视觉效果。</p>
<p>##Postponed Shared Element Transitions (part 3b)<br>这里还有一篇，并没有翻译，看了一遍，写贴上，有时间我去翻译一下 <a href="http://www.androiddesignpatterns.com/2015/03/activity-postponed-shared-element-transitions-part3b.html" target="_blank" rel="external">地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###扯淡&lt;br&gt;之所以写这篇是因为看到别人写的APP都很酷炫，了解到之后发现5.0之后的动画丰富了那么多，特别是共享元素和圆形展开那个(不知道是不是这么叫的)特别酷，就去了解了一下。再加上我最近才上的5.0，终于有真机可以进行调试了，看到动画在自己手机上运行，还是挺有成就感的😂。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Thinking in Java</title>
    <link href="http://yoursite.com/2016/07/09/Java/"/>
    <id>http://yoursite.com/2016/07/09/Java/</id>
    <published>2016-07-09T15:37:53.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>写一些看书的笔记</p>
<p>##第二章 一切都是对象</p>
<p>###JAVA堆栈和堆<br>&emsp;&emsp;堆栈就是平时所说的栈，位于通用的ROM中，从堆栈指针从处理器那里获得直接支持。堆栈的指针向下移动，分配新的内存，向上移动，释放内存。在创建程序时，系统必须知道存储在盾战中所有的项目的确切生命周期，以便赏析移动堆栈的指针。这一约束限制了程序的灵活性，所以虽然某些JAVA数据存储在堆栈中–特别是对象引用，但是JAVA对象并不存储其中（<del>然而我并不怎么理解</del>。。）。<br>&emsp;&emsp;堆是一种通用的内存池，也是位于RAM中，用于存放所有的JAVA对象。堆对于栈的好处就是：编译器不需要知道存储的数据在堆里存货多长时间。当需要一个对象时，只需要去new，当执行这个代码会自动在堆内进行储存分配。但是用堆进行存储分配和清理可能比用栈分配需要更多的时间。<br><a id="more"></a></p>
<p>###基本类型<br>基本类型是存储在堆里，不用new来创建变量，而是创建一个并非是引用的”自动”变量（<del>看不懂…555</del>）。基本类型具有包装器类，使得可以在堆中创建一个非基本类型，用来表示对应的基本类型。<br>可以这么用<code>int i = 5</code>也可以<code>Integer i = new Integer(5)</code>。在JAVA se5之后的自动包装功能能自动的将基本类型转换为包装器类型：<code>Character ch = &#39;x&#39;</code></p>
<p>###基本成员默认值<br>若类的某个成员是基本数据类型，即使没有初始化，JAVA也会确保它获得一个默认值。但是局部变量不会初始化。</p>
<p>##第三章 操作符</p>
<p>###赋值<br>赋值操作的是一个对象的引用，看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> class Tank&#123;</div><div class="line">int level;</div><div class="line">   &#125;</div><div class="line">     public class Assignment&#123;</div><div class="line">     public static void main(String[] args)&#123;</div><div class="line">	Tank t1 = new Tank();</div><div class="line">	Tank t2 = new Tank();</div><div class="line"></div><div class="line">	t1.level = 9;</div><div class="line">	t2.level = 21;</div><div class="line"></div><div class="line">	System.out.println(&quot;原本的t1:&quot;+t1.level+&quot;  原本的t2:&quot;+t2.level);</div><div class="line"></div><div class="line">	t1 = t2;</div><div class="line"></div><div class="line">	System.out.println(&quot;现在的t1:&quot;+t1.level+&quot;  现在的t2:&quot;+t2.level);</div><div class="line"></div><div class="line">	t1.level = 40;</div><div class="line">	</div><div class="line">	System.out.println(&quot;后来的t1:&quot;+t1.level+&quot;  后来的t2:&quot;+t2.level);</div><div class="line"></div><div class="line">&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>看输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">原本的t1:9  原本的t2:21</div><div class="line">现在的t1:21  现在的t2:21</div><div class="line">后来的t1:40  后来的t2:40</div></pre></td></tr></table></figure>
<p>正确的给t1赋值应该这样：</p>
<pre><code>t1.level = t2.level
</code></pre><p>###自动递增和递减<br>&emsp;&emsp;这个是我一直搞混的东西，总是弄混前缀和后缀的区别，现在写一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int i = 1;</div><div class="line">System.out.println(&quot;i:&quot;+i);</div><div class="line">System.out.println(&quot;i++ :&quot;+ i++);//1</div><div class="line">System.out.println(&quot;++i :&quot; + ++i);//3</div></pre></td></tr></table></figure>
<p> i++是先生成值后计算，也就是说在<code>i++</code>这里面的i是上一个状态的i,结果要在下一个状态才可以获取。前缀写法是先执行计算然后生成值，所以这里的i就等于三。</p>
<p>###关系操作符<br>&emsp;&emsp;关系操作符==和!=比较的是对象的引用，这个和在使用=进行对象赋值时一样，都是对象的引用而不是内部值。例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Integer n1 = new Integer(1);</div><div class="line">Integer n2 = new Integer(1);</div><div class="line">System.out.println(n1 == n2);//false</div><div class="line">System.out.println(n1 !=n2);//true</div></pre></td></tr></table></figure>
<p>要是想比较实际内容，可以使用所有对象都适用的方法<code>equals()</code> 。但是这个方法不适用于基本类型，基本类型直接使用<code>==</code>和<code>!=</code>即可。但是在自己创建的类中，还要注意<code>euqals()</code>的坑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Value&#123;</div><div class="line">			int i;</div><div class="line">		&#125;</div><div class="line">		Value v1 = new Value();</div><div class="line">		Value v2 = new Value();</div><div class="line">		System.out.println(v1.equals(v2));//false</div></pre></td></tr></table></figure>
<p>这是为啥？因为JAVA的设计者把对关系比较的权利完全给了类的设计者，因为<code>equasl()</code>方法对所有的对象都可以使用，所以他直接是卸载<code>Object</code>类里面。要想实现我们希望的功能，就要在自己的类中覆盖这个方法。这个方法的默认是返回对引用的比较。</p>
<pre><code> public boolean equals(Object obj) {
    return (this == obj);
}
</code></pre><p>总结就是：想比较实际内容，用<code>equals()</code>，想比较引用，使用<code>==</code>。（<del>感觉一般也很少直接进行对象的比较吧</del>）。</p>
<p>###指数计数法<br>在JAVA中，看到1.39e^{-43}f这样的表达式，真正的意义是1.39*10^{-43}，这个历史原因我也懒得管，要使用e有现成的公式调用（<del>我还没在开发中用过e..</del>）。</p>
<p>###截尾和舍入<br>在将<code>float</code>和<code>double</code>转化为<code>int</code>的时候，默认是对该数字进行<strong>截尾</strong>，就是直接舍弃小数点后面的内容。要想得到舍入的结果，可以使用<code>Math.round()</code>方法；</p>
<p>##第五章 初始化与清理</p>
<p>###区别重载方法<br>区别重载方法是靠方法的参数列表的不同来区分，甚至参数的顺序不同也可以区分，但是不建议这么做，太特么混乱了。</p>
<p>###清理:终结处理和垃圾回收<br>JAVA主要要gc进行自动的垃圾回收，但是如果使用的对象不是new出来的，他获得了一块”特殊的”内存区域，由于垃圾回收器只知道回收那些由new分配的内存，所以它不知道如何去释放这块内存。为了对付这样的场景，JAVA允许在类中定义一个<code>finalize()</code>的方法，但是又不是像c++中的析构函数。（<del>特么编不下去了，我不懂啊，不写这玩意了</del>）。书上有三个要点还是写一下吧：</p>
<ol>
<li>对象可能不被垃圾回收</li>
<li>垃圾回收不等于析构</li>
<li>垃圾回收只与内存有关</li>
</ol>
<p>ps:书上还有很多关于如何使用<code>finalize()</code>和JAVA是如何进行垃圾回收的的东西，我对gc没点了解，暂时不看了。。</p>
<p>###构造器初始化<br>可以使用构造器进行初始化。在运行时刻，可以调用方法或者进行某些动作来确定初值。但是：<strong>无法阻止自动初始化的进行，它将在构造器被调用之前发生</strong>。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Counter&#123;</div><div class="line">int i;</div><div class="line">Counter()&#123;</div><div class="line">i = 7;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">这里的i先被置为0，然后变成7。</div><div class="line">在类的内部，定义变量的顺序决定了初始化的顺序，即使变量定义散步在方法之间，**它们仍然会在任何方法(包括构造器)被调用之前得到初始化**</div></pre></td></tr></table></figure>
<p>class Window{<br>         Window(int i){<br>                System.out.println(“window:”+i);<br>            }<br>        }<br>           class House{<br>            Window w1 = new Window(1);<br>            House(){<br>            System.out.println(“House()”);<br>            w3 = new Window(33);<br>            }<br>            Window w2 = new Window(2);<br>            void f(){System.out.println(“f()”);}<br>            Window w3 = new Window(3);<br>            }</p>
<pre><code>House h= new House();
h.f();
    //---------结果--------
    window:1
    window:2
    window:3
    House()
    window:33
    f()
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">		</div><div class="line"> </div><div class="line"></div><div class="line">##第七章 复用类</div><div class="line">###组合和继承</div><div class="line">&amp;emsp;&amp;emsp;组合和继承都允许在新的类中放置子对象，组合是显示的这么做，继承是隐式的做。组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情形，即新类中嵌入某个对象，让其实现所需要的功能，但新类的用户看到的只是为新类所定义的接口，而非所嵌入对象的接口，让其实现所需要的功能，需要在新类中嵌入一个现有类的private对象。</div><div class="line">&amp;emsp;&amp;emsp;判断应该使用继承还是组合，就是是否需要从新类向上转型。如果需要，继承是必须的。</div><div class="line">###final</div><div class="line"></div><div class="line"> 1. final的数据</div><div class="line"> 一个永不改变的编译时常量。</div><div class="line"> 一个运行时被初始化的值，不希望被改变。</div><div class="line"></div><div class="line">final修饰的是基本类型时数值保持不变，但是final修饰的是一个对象时，是对引用保持不变，但是对象又是可以修改的，所以用final修饰对象作用不大。</div><div class="line"></div><div class="line">&amp;emsp;&amp;emsp;空白final</div><div class="line">空白final是指声明为final但是又没有给定初始值的域。这样当我们使用不同的构造函数创建不同的类时，就可以根据对象的不同有所不同，但是又保持不变。但是必须在每个域的定义处或者每个构造函数处对final赋值。</div><div class="line"></div><div class="line"> 1. final方法</div><div class="line"></div><div class="line"> 把方法锁定，以防任何继承类修改它的含义</div><div class="line"> 确保在继承中使方法的行为保持不变。（~~子类对父类的方法只能看不能摸~~）</div><div class="line"> 类中的所有的private方法都隐式的指定为final</div><div class="line"> </div><div class="line">##第八章 多态</div><div class="line">&amp;emsp;&amp;emsp;多态是继 数据抽象 和 继承 之后的第三种基本类型。&quot;封装&quot;通过合并特性和行为来创建新的数据类型。多态的作用消除**类型**之间的耦合关系。</div><div class="line">###域和静态方法</div><div class="line">只有普通的方法的调用是多态的，成员变量没有多态。（通过get和set方法去调用，而不是直接访问成员）。</div><div class="line">如果方法是静态的，也没有多态性。（一般的工具类中的静态方法，子类没法重写）。</div><div class="line">###构造函数和方法</div><div class="line">构造函数不具有多态性，实际上他们是隐式的static方法。</div><div class="line">复杂对象的构造方法调用顺序：</div><div class="line"></div><div class="line"> 1. 基类的构造函数（一直递归下去，直到子类）</div><div class="line"> 2. 按声明顺序调用成员的初始化方法。</div><div class="line"> 3. 调用子类的构造函数主体。</div><div class="line"> </div><div class="line"></div><div class="line">###构造函数内部的多态方法的行为</div><div class="line">先看个例子：</div></pre></td></tr></table></figure>
<p>public class Main1 {<br>    public static void main(String[] args) {<br>        new RoundGlyph(5);<br>    }<br>     }<br>     class Glyph{<br>    void draw(){System.out.println(“Glayph.draw”);}</p>
<pre><code>Glyph(){
    System.out.println(&quot;before draw&quot;);
    draw();
    System.out.println(&quot;after draw&quot;);
}
 }
class RoundGlyph extends Glyph{
private int radius = 1;
RoundGlyph(int r){
    this.radius = r;
    System.out.println(&quot;RoundGlyph.RoundGlyph(): &quot;+radius);
}

@Override
void draw() {
    System.out.println(&quot;RoundGlyph.draw(): &quot;+radius);    
}
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line"></div><div class="line">输出：</div><div class="line"></div><div class="line">    before draw</div><div class="line">    RoundGlyph.draw(): 0//此时，还没有调用子类的构造方法，也就是还没有初始化，radius默认被赋值0</div><div class="line">    after draw</div><div class="line">    RoundGlyph.RoundGlyph(): 5</div><div class="line"></div><div class="line">初始化的实际过程：</div><div class="line"></div><div class="line"> 1. 在其他任何事物发生之前，将分配给对象的储存空间初始化为二进制的零。</div><div class="line"> 2. 调用父类的构造函数</div><div class="line"> 3. 按声明顺序调用成员的初始化方法</div><div class="line"> 4. 调用子类的构造函数</div><div class="line"> </div><div class="line">因此要避免在构造函数内调用可能会重写的方法，安全的做法是调用final的方法。</div><div class="line"></div><div class="line">##第九章 接口</div><div class="line">&amp;emsp;&amp;emsp;接口表示：所有实现了该特定接口的类看起来都像这样。接口被用来创建类与类之间的协议。接口不仅仅是一个极度抽象的类，因为他允许人们通过创建一个能够向上转型为多种基类的类型，来实现某种类似多重继承变种的特性。</div><div class="line">&amp;emsp;&amp;emsp;如果接口不添加public修饰，那么他默认是包访问权限。</div><div class="line">&amp;emsp;&amp;emsp;这里还有对策略模式和适配器模式的介绍，这里对会在设计模式系列里面介绍。</div><div class="line">&amp;emsp;&amp;emsp;使用接口的核心原因：为了能够向上转型为多个基类型。第二：防止创建该类的对象，并确保这仅仅是建立一个接口。</div><div class="line">&amp;emsp;&amp;emsp;可以通过对接口的继承来进行接口的拓展，而且接口可以多重继承。</div></pre></td></tr></table></figure>
<p> interface Monster{<br>    void menace();<br>    }<br>    interface DangerousMonster extends Monster{<br>    void destory();<br>    }<br>     interface Lethal{<br>    void kill();<br>    }</p>
<pre><code>interface Vampire extends Lethal,DangerousMonster{
void drinkblood();
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">&amp;emsp;&amp;emsp;接口最吸引人的地方是允许同一个接口具有多个不同的实现。一个类 可以实现多个接口就可以实现向上转型为多个基类型   </div><div class="line">&amp;emsp;&amp;emsp;有接口，肯定就会想到工厂模式，这也会在设计模式系列中写到（~~但愿我不拖更555~~）。</div><div class="line">###抽象类与接口</div><div class="line">（~~不负责任总结~~）</div><div class="line">让抽象类去实现接口 不需要实现全部的方法 可以只实现一部分  然后剩下的子类去实现 子类必须实现抽象类中的抽象方法 </div><div class="line">感觉抽象类可以作为普通类的一个缓冲   接口是完全的抽象  当只需要具有接口的部分特性  可以使用抽象类</div><div class="line">一个类实现了一个接口  就可以把这个类当做接口的实例穿进去</div><div class="line"></div><div class="line">##第十章 内部类</div><div class="line">* 内部类就是将一个类的定义放在另一个类的内部。内部类和组合是不一样的概念。</div><div class="line">* 内部类可以访问到外围对象的所有成员而不需要任何的特殊条件，此外，内部类还拥有外部类的所有元素的访问权。</div><div class="line">* 在内部类中生成对外部类的引用，可以使用`Outside.this`</div><div class="line">* 创建内部类的对象 `Out.Inner in = out.new Inner();`</div><div class="line">* 在拥有外部类对象之前是不可能创建内部类的对象的，除非是嵌套类（静态内部类）</div><div class="line">* 将内部类向上转型为基类型，尤其是转型为一个接口时候，内部类就很有用了</div></pre></td></tr></table></figure>
<pre><code>public class Main3 {
        public static void main(String[] args) {
            RelaMain main = new RelaMain();
            Contents c = main.contents();
            Destination d = main.destination(&quot;laal&quot;);

            RelaMain.PDestination pd = main.new PDestination(&quot;hahah&quot;);
            //RelaMain.PContents pc = main.new PContents();访问不到  因为是private的
        }

    }
    class RelaMain{
        private class PContents implements Contents{
            private int i  = 1;
            public int value() {
                return i;
            }
        }
        protected class PDestination implements Destination{
            private String label;
            PDestination(String whereto){
                this.label = whereto;
            }
            public String readLabel() {
                return label;
            }
        }
        public Destination destination(String label){
            return new PDestination(label);
        }
        public Contents contents(){
            return new PContents();
        }
    }
    interface Destination{
        String readLabel();
    }
    interface Contents{
        int value();
    }
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">* 可以在方法里面或者任意的作用域内定义内部类：</div><div class="line">  1：实现某类型的接口，于是可以创建并返回对其的引用；</div><div class="line">  2：创建一个类来辅助你的解决方案，又不希望这个类是公共可用的。</div><div class="line"></div><div class="line">* 匿名内部类和工厂方法</div></pre></td></tr></table></figure>
<p>interface Service{<br>    void method1();<br>    void method2();<br>}<br>interface ServiceFactory{//抽象工厂接口 用于返回工厂产品<br>    Service getService();<br>}</p>
<p>class Implementation1 implements Service{</p>
<pre><code>public void method1() {
    System.out.println(&quot;Implementation1.method1&quot;);
}

public void method2() {
    System.out.println(&quot;Implementation1.method2&quot;);
}
public static ServiceFactory factory = new ServiceFactory() {

    public Service getService() {
        return new Implementation1();
    }
};
</code></pre><p>}</p>
<p>class Implementation2 implements Service{</p>
<pre><code>public void method1() {
    System.out.println(&quot;Implementation2.method1&quot;);
}

public void method2() {
    System.out.println(&quot;Implementation2.method1&quot;);
}
public static ServiceFactory factory = new ServiceFactory() {

    public Service getService() {
        return new Implementation2();
    }
};
</code></pre><p>}<br>public class Main2 {</p>
<pre><code>public static void serviceConsumer(ServiceFactory factory){
    Service s = factory.getService();
    s.method1();
    s.method2();

}
public static void main(String[] args) {

    serviceConsumer(Implementation1.factory);
    serviceConsumer(Implementation2.factory);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">###嵌套类 </div><div class="line"></div><div class="line">如果不需要内部类对象对其外围类对象之间的联系，那么可以将内部类声明为static，叫做嵌套类。</div><div class="line"></div><div class="line"> 1.要创建嵌套类的对象，并不需要其外围类的对象</div><div class="line"> </div><div class="line"> 2.不能从嵌套类的对象中访问非静态的外围类对象</div></pre></td></tr></table></figure></p>
<pre><code>private static class ParcelDestination implements Destination{
    private String label;
    ParcelDestination(String whereto){
        this.label = whereto;
    }
    public String readLabel() {
        return label;
    }
    static class AnotherLevel{
        public static void f(){};
    }

}
public static Destination destination(String s){
    return new ParcelDestination(s);
}
//in main
Destination dd = destination(&quot;lal&quot;);
    dd.readLabel();
    ParcelDestination.AnotherLevel.f();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 接口中的内部类</div><div class="line"></div><div class="line">如果想创建某些公用代码，使得他们可以被某个接口的所有不同实现所公用</div></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>在接口内可以定义类</li>
<li>@author Mr_Wrong</li>
<li></li>
<li>只有实现了这个接口的类  才能访问到这个内部类  所以可以被实现了这个接口的所以类所共用<br><em>
</em>/<br>public interface ClassInInterface {<br> void howby();<br> class TestClassInInterface implements ClassInInterface{<pre><code>public void howby() {
    System.out.println(&quot;这是接口内部的类的howby方法&quot;);            
}
public static void main(String[] args) {
    new TestClassInInterface().howby();
    System.out.println(&quot;这是共用的部分&quot;);
}
</code></pre> }<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">###为什么需要内部类</div><div class="line"></div><div class="line">一般来说，内部类继承自某个类或则实现某个接口，内部类的代码操作创建它的外围类对象，所以可以认为内部类提供了某种进入外围类的窗口。</div><div class="line"></div><div class="line">每个内部类都能独立的继承自一个（接口）的实现，所以无论外围类是否已经继承了某个（接口）的实现，对于内部类都是没有影响的。（内部类也有种多重继承的感觉）</div><div class="line"></div><div class="line">内部类的其他特征：</div><div class="line"></div><div class="line">1.内部类可以有多个实例 ，每个实例都有自己的状态信息，并且与其外围类的信息相互独立。</div><div class="line"></div><div class="line">2.在单个外围类中，可以让多个内部类以不同的方式实现一个接口，或者继承自同一个类。</div><div class="line"></div><div class="line">3.创建内部类对象的时刻并不依赖外围类对象的创建。</div><div class="line"></div><div class="line">4.内部类冰没有令人迷惑的&quot;is-a&quot;关系，它就是一个独立的实体。</div><div class="line">###闭包与回调</div><div class="line"></div><div class="line">闭包是一个可调用的对象，它记录了一些信息，这些信息来自创建它的作用域。</div><div class="line"></div><div class="line">这是一个外围类实现一个接口和内部类实现这个接口的区别：</div></pre></td></tr></table></figure>
<p>class Test2 implements TestInterface{</p>
<pre><code>public String dothings() {
    return &quot;hasdone&quot;;
}
public TestInterface getinterface(){
    return new Test2();
}
</code></pre><p>}</p>
<p>class Test3{</p>
<pre><code>public String dothings(){
    return &quot;test3hasdone&quot;;
}
class InTest3 implements TestInterface{

    public String dothings() {
        return &quot;InTest3hasdone&quot;;
    }

}
TestInterface getinterface(){
    return new InTest3();
}
</code></pre><p>}</p>
<p>public class Test1 {</p>
<pre><code>public static void main(String[] args) {
    TestInterface interface1 = new Test2();
    System.out.println(interface1.dothings());


    Test3 test3 = new Test3();
    System.out.println(test3.getinterface().dothings());
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">因为在test3中有dothings这方法，我们又不想因为实现了接而覆盖掉它，这时候就可以定义一个内部类去代替它去实现这个接口，然后在通过一个方法暴露出去。这就是一个hook（勾子）</div><div class="line"></div><div class="line">###内部类的继承</div><div class="line">内部类的继承有一些特殊的语法，还是直接上代码吧</div></pre></td></tr></table></figure>
<p>class WidthInner {<br>    class Inner{}<br>}</p>
<p>public class InheritInner extends WidthInner.Inner{<br>//构造函数要传外围类<br>    InheritInner(WidthInner wi){<br>        wi.super();<br>    }<br>    public static void main(String[] args) {<br>        WidthInner wi = new WidthInner();<br>        InheritInner hi = new InheritInner(wi);</p>
<pre><code>}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##第十一章 持有对象</div><div class="line">###添加元素</div><div class="line">当使用Arrays.aslist时候应该注意类型问题：</div></pre></td></tr></table></figure>
<p>public class Main {<br>    public static void main(String[] args) {</p>
<pre><code>    List&lt;Snow&gt; snow1 = Arrays.asList(new Crusty(),new Powder(),new Slush());

    //List&lt;Snow&gt; snow2= Arrays.asList(new Light());//这样提示错误  下面两个可以

    List&lt;Snow&gt; snow3 = new ArrayList&lt;Snow&gt;();
    Collections.addAll(snow3, new Light(),new Heavy(),new Slush());

    List&lt;Snow&gt; snow4 = Arrays.&lt;Snow&gt;asList(new Light(),new Slush());


   }
}
class Snow{};
class Powder extends Snow{};
class Light extends Powder{};
class Heavy extends Powder{};
class Crusty extends Snow{}
class Slush extends Snow{}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###迭代器</div></pre></td></tr></table></figure>
<pre><code>public class Main1 {
    public static void main(String[] args) {


        List&lt;String&gt; strings = Arrays.asList(&quot;hah&quot;,&quot;lal&quot;,&quot;en&quot;,&quot;yes&quot;,&quot;no&quot;);

        //可以这样  包装成真正的list
        List&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;hah&quot;,&quot;lal&quot;,&quot;en&quot;,&quot;yes&quot;,&quot;no&quot;));

        Iterator&lt;String&gt; it  = strings.iterator();

        while (it.hasNext()) {
            String string = (String) it.next();
            System.out.println(string);
        }

        for (String string : strings) {
            System.out.println(string);
        }

        it  = list.iterator();
        for (int i = 0; i &lt; 2; i++) {
            it.next();
            it.remove();//这里不能进行对strings进行remove  是因为这个list仅仅是对数组的的包装   数组有确切的长度  不能进行remove操作
            //在使用迭代器的remove之前要先调用next
        }
        System.out.println(list);
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ListIterator是Iterator的一个子类，只能用于各种list类的访问，它可以双向移动：</div></pre></td></tr></table></figure>
<p>ListIterator<string> listit = list.listIterator();</string></p>
<pre><code>while (listit.hasNext()) {
    String string = (String) listit.next();
    System.out.println(string+&quot;,&quot;+listit.nextIndex()+&quot;,&quot;+listit.previousIndex());
}
while (listit.hasPrevious()) {
    System.out.println(listit.previousIndex());
    listit.set(&quot;&quot;);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###栈</div></pre></td></tr></table></figure>
<p>public class Main2 {<br>    public static void main(String[] args) {<br>        Stack<string> stack = new Stack<string>();<br>        for (String s : “my dog is dog ha ha ha”.split(“ “)) {<br>            stack.push(s);<br>        }<br>        while(!stack.empty()){<br>            System.out.println(stack.pop());<br>        }<br>    }<br>}<br>class Stack<t>{<br>    private LinkedList<t> storage = new LinkedList<t>();<br>    public void push(T v){storage.addFirst(v);}<br>    public T peek(){return storage.getFirst();}<br>    public T pop(){return storage.removeFirst();}<br>    public boolean empty(){return storage.isEmpty();}<br>    public String tosString(){return storage.toString();}<br>}</t></t></t></string></string></p>
<p>//输出<br>ha<br>ha<br>ha<br>dog<br>is<br>dog<br>my<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">###Set</div><div class="line">set不保存重复的元素，查找就是set中最重要的操作。通常使用一个hashset，它专门为快速查找进行了优化：</div></pre></td></tr></table></figure></p>
<pre><code>Random rand = new Random();
    Set&lt;Integer&gt; intset = new HashSet&lt;Integer&gt;();

    for (int i = 0; i &lt; 100; i++) {
        intset.add(rand.nextInt(10));
    }
    System.out.println(intset);
    //输出
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">其实hashset的输出是没有顺序的，要想有顺序可以使用treeset，但是这里为什么是有顺序的呢，这也算是一个巧合吧，具体的可以看这里  知乎上的解释[Java遍历HashSet为什么输出是有序的？](http://www.zhihu.com/question/28414001)</div><div class="line"></div><div class="line">treeset将元素储存在红黑树数据结构中，而HashSet使用的是散列函数。LinkedList因为查询速度的原因也使用了散列，但是看起来它使用了链表来维护元素的插入顺序。</div><div class="line"></div><div class="line">使用treeset可以指定排序方式。</div><div class="line"></div><div class="line">    		//按字母表排序</div><div class="line">    		Set&lt;String&gt; words = new TreeSet&lt;String&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line"></div><div class="line"></div><div class="line">###Map</div><div class="line"></div><div class="line">###Queue</div><div class="line"></div><div class="line">队列是一个典型的先进先出的容器。</div><div class="line"></div><div class="line">LinkedList提供了方法以支持队列的行为，并且它实现了queue接口，因此linkedklist可以作为queue的一种实现。</div><div class="line"></div><div class="line">一些queue的常用方法：</div><div class="line"></div><div class="line">offer()将一个元素插入到队尾或者返回false;</div><div class="line">peek()和element()都在不移除的情况下返回队头，但是peek()方法在队列为空时返回Null，element()会抛出NoSuchElementException异常。</div><div class="line">Poll()和remove()移除并返回队头，当队列为空时，同上。</div><div class="line"></div><div class="line">###Collection和Iterator</div><div class="line">Collection是描述所有序列容器的共性根接口。</div><div class="line">要实现Collection就意味着需要提供iterator()方法。</div><div class="line"></div><div class="line">###Foreach与迭代器</div><div class="line"></div><div class="line">如果你创建了任何实现了Iterable的类，都可以将它用于foreach语句中。</div><div class="line"></div><div class="line">尝试把数组当做一个Iterable参数传递会导致失败。这说明不存在任何从数组到Iterable的自动转换，必须手动执行这种转换。</div><div class="line"></div><div class="line"></div><div class="line">###总结</div><div class="line"></div><div class="line"> 1. 数组将数字与对象联系起来，但是数组一旦生成，其容量就不能改变。</div><div class="line"> 2. Collection保存单一的元素，Map保存相关联的键值对。容器不能持有基本类型，但是自动包装机制会执行双向转换。</div><div class="line"> 3. 进行大量随机的访问，使用ArrayList。经常从表中间插入或者删除元素，使用LinkedList.</div><div class="line"> 4. 各种Queue以及栈的行为，由linkedlist提供支持。</div><div class="line"></div><div class="line">![](http://img.my.csdn.net/uploads/201012/10/0_129197029221PZ.gif)</div><div class="line"></div><div class="line">##第十二章 通过异常处理错误</div><div class="line"></div><div class="line"></div><div class="line">这章暂时先不看了，处理异常的内容我觉得先暂时了解了一些，在写Android用处没那么多，以后要用的时候再来从头看。</div><div class="line"></div><div class="line">##第十三章 字符串</div><div class="line"></div><div class="line">* String对象是不可变的</div><div class="line">* 在使用&quot;+&quot;进行String的拼接的时候，隐式的调用了StringBuilder来进行处理。这不意味着可以随便的使用&quot;+&quot;。显式的调用效率会更高，使用`stringbuilder.append(string)`来进行拼接。同时StringBuilder还提供了丰富的处理字符串的方法。</div><div class="line">* 当想打印对象的内存地址的时候，或许会考虑使用this。比如</div></pre></td></tr></table></figure>
<p>@Override<br>    public String toString() {<br>        return “InfiniteRecursion address :”+this;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">这时候会出现一大堆的异常信息。这是因为发生了无意识的递归。在使用&quot;+&quot;this的时候，编译器尝试把this转换为一个字符串，就又去调用了tostring方法。所以正确的方法是调用`super.tostring()`</div><div class="line"></div><div class="line">###String对象有一下基本的方法，</div><div class="line">  * `equalsIgnoreCase()`  忽略大小写</div><div class="line">  * `startswith(),endswith()`  起始和结束的string</div><div class="line">  </div><div class="line">###String的格式化输出</div><div class="line"></div><div class="line">Formatter类，可以看做是一个翻译器，它将你的格式化字符串与数据翻译成需要的结果。</div><div class="line">格式化说明符：</div><div class="line"></div><div class="line">    %[argument_index$][flags][width][.precision]conversion</div><div class="line">    </div><div class="line">width是指定一个域的最小尺寸，Formatter对象通过添加空格来保证最小尺寸。默认是右对齐，可以使用-来进行左对齐。precision的来指定最大的尺寸，可以用于浮点数取位。无法用于整数，会引发异常。例如：</div></pre></td></tr></table></figure></p>
<p>s=String.format(“%-10.2f %-5s”, 1.2334,”后面的”);<br>System.out.println(s);<br>//结果<br>1.23       后面的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">###正则表达式</div><div class="line">* ？表示可能有</div><div class="line">* \d 表示一个数字</div><div class="line">* + 表示有一个或多个</div><div class="line">* \w 表示分隔单词</div><div class="line">这个我也只是看了点简单的，后面复杂的也没去了解，一则因为目前开发中还用不到那么复杂的正则表达式，一般就是处理一下字符串。二则网上有很多在线生成表达式的网站。暂时先放着吧。</div><div class="line"></div><div class="line">## 第十四章 类型信息</div><div class="line"></div><div class="line"> - 运行时类型信息使得你可以在程序运行时发现和使用类型信息。</div><div class="line"> - RTTI（Run-Time Type Identification）：就是在运行时识别一个对象的类型。</div><div class="line">###Class对象</div><div class="line"> - 类型信息在运行时的表达是由称作Class对象的特殊对象完成的。所有的类都是在对其第一次使用时，动态加载带JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类，这也说明了构造函数是类的静态方法。</div><div class="line"> - `Class.forName(&quot;&quot;)`这个方法是class类（所有class对象都属于这个类）的一个static成员。这个是获取class对象的引用的一种方式。如果类没有被加载就去加载它。</div><div class="line"> - `Class`的`newInstance()`方法是实现&quot;虚拟构造器&quot;的一种途径，&quot;我不知道你的具体类型，但是无论如何要正确的创建自己&quot;。</div><div class="line">###类字面常量</div><div class="line"> - 也是用来生成对class对象的引用，`Toy.class`。这个不仅简单，而且更安全，编译期就会收到检查。但是他不会自动初始化该class对象。</div><div class="line">####泛化的class引用</div><div class="line"> - 类似```Class&lt;?&gt; intclass = int.class ```,向class引用添加泛型语法的原因仅仅是为了提供编译期类型检查。</div><div class="line">####类型转换前先做检查</div><div class="line">已知的RTTI形式包括</div><div class="line"> 1. 传统的类型转换。</div><div class="line"> 2. 代表对象的类型的class对象。</div><div class="line"> 3. 还有就是使用`instanceof`，告诉我们对象是不是某个特定类型的实例。</div><div class="line"></div><div class="line">###反射：运行时的类信息</div><div class="line">这个关于反射的后面写了一篇专门的，[java反射](http://70kg.info/2015/09/14/java%E5%8F%8D%E5%B0%84/)</div><div class="line">###动态代理</div><div class="line">之前也过代理模式，去那里看吧。[代理模式](http://70kg.info/2015/08/04/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/)</div><div class="line">###空对象</div><div class="line">这个不知道怎么写了。。</div><div class="line">###接口和类型信息</div><div class="line">这个怎么说呢，还是在讲反射的应用，还有接口，类转型的问题。</div><div class="line"></div><div class="line">##第十五章 泛型</div><div class="line"></div><div class="line"> - 一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。所以可以使用泛型，这个意思就是适用于许许多多的类型。</div><div class="line">###简单泛型</div><div class="line">引入泛型的最引人注目的原因就是创造容器类。</div><div class="line">这是一个简答的泛型例子：</div></pre></td></tr></table></figure></p>
<p>public class Holder<t> {<br>    private T a;<br>    public Holder(T a){this.a = a;}<br>    public T get(){return a;}<br>    public void set(T a){this.a = a;}</t></p>
<pre><code>public static void main(String[] args) {
    Holder&lt;Mobile&gt; holder = new Holder&lt;Mobile&gt;(new Mobile());
    holder.get();
    holder.set(new Mobile());
}
</code></pre><p>}<br>class Mobile{}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">####元组</div><div class="line"></div><div class="line"> - return语句只能返回一个对象，当我们需要返回多个对象的时候，可以创建一个对象，让他来持有想要返回的多个对象，这就是元组的概念。我们可以使用泛型来优化使用。</div></pre></td></tr></table></figure></p>
<p>public class Tuple<a,b> {<br>    public final A first;<br>    public final B second;<br>    public Tuple(A a,B b ){<br>        this.first = a;<br>        this.second= b;<br>    }<br>    public String toString(){<br>        return first+”,”+second;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在上面的程序中，`first`和`second`都是public，理论上应该是private的，然后通过get和set方法去访问他们的值，但是这里使用了final。这样就只允许外界去读取而不允许去改变值。同时我们还可以使用继承去拓展元组，让它去支持更多的参数。</div><div class="line">要使用元组也是很方便：</div></pre></td></tr></table></figure></a,b></p>
<pre><code>static Tuple&lt;String,Integer&gt; f(){
    return new Tuple&lt;String, Integer&gt;(&quot;hahah&quot;, 12);
}
public static void main(String[] args) {
    System.out.println(f());
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">###泛型接口</div><div class="line"></div><div class="line"> - 泛型可以应用于接口，例如生成器，这样一种专门负责创建对象的类，实现上实际是工厂方法设计模式的一种应用。例如</div></pre></td></tr></table></figure>
<p>public interface Generator<t> {<br>    T next();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">下面演示一下如何使用</div></pre></td></tr></table></figure></t></p>
<p>public class CoffeeGenerator implements Generator<coffee>,Iterable<coffee>{</coffee></coffee></p>
<pre><code>private Class[] types = {Mocha.class,Coffee.class,Mocha.class};
private static Random random = new Random(47);
private int size = 0;
public CoffeeGenerator(){}
public CoffeeGenerator(int size){this.size= size;}
public Iterator&lt;Coffee&gt; iterator() {
    return new CoffeeIterator();
}
public void forEach(Consumer&lt;? super Coffee&gt; action) {
}

public Spliterator&lt;Coffee&gt; spliterator() {
    return null;
}

public Coffee next(){
    try {
        return (Coffee) types[random.nextInt(types.length)].newInstance();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}

class CoffeeIterator implements Iterator&lt;Coffee&gt;{
    int count = size;

    public boolean hasNext() {
        return count&gt;0;
    }

    public Coffee next() {
        count--;
        return CoffeeGenerator.this.next();
    }

    public void remove() {
        throw new UnsupportedOperationException();
    }

    public void forEachRemaining(Consumer&lt;? super Coffee&gt; action) {

    }

}
public static void main(String[] args) {
    CoffeeGenerator gen = new CoffeeGenerator();
    for(int i = 0;i&lt;5;i++){
        System.out.println(gen.next());
    }
    for(Coffee c:new CoffeeGenerator(5)){
        System.out.println(c);
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">###泛型方法</div><div class="line"></div><div class="line"> - 泛型方法使得方法可以独立于类而产生变化：无论何时，只要你能做到，就应该尽量使用泛型方法。例子：</div></pre></td></tr></table></figure></p>
<p>public class GeneircMethods {<br>    public <t> void f(T x){<br>        System.out.println(x.getClass().getSimpleName());<br>    }<br>    public static void main(String[] args) {<br>        GeneircMethods m = new GeneircMethods();<br>        m.f(“”);<br>        m.f(1);<br>        m.f(1.0);<br>        m.f(m);<br>    }<br>}<br>//输出<br>String<br>Integer<br>Double<br>GeneircMethods</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">泛型是不支持基本类型作为类型参数的 ，但是由于JAVA的自动打包机制，我们并不需要太多担心。</div><div class="line"></div><div class="line"> - 可变参数和泛型方法可以很好的共存：</div></pre></td></tr></table></figure>
<p>public static <t> List<t> makelist(T…args){<br>        List<t> result = new ArrayList<t>();<br>        for(T item: args){<br>            result.add(item);<br>        }<br>        return result;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">####用于Generator的泛型方法</div><div class="line"> - 使用生成器，可以很方便的填充一个Collection。</div></pre></td></tr></table></figure></t></t></t></t></p>
<p>public class Generators {<br>    public static <t> Collection<t> fill(Collection<t> coll,Generator<t> gen,int n){<br>        for(int i = 0;i&lt;n;i++){<br>            coll.add(gen.next());<br>        }<br>        return coll;<br>    }</t></t></t></t></p>
<pre><code>public static void main(String[] args) {
    Collection&lt;Coffee&gt; coffee= fill(new ArrayList&lt;Coffee&gt;(), new CoffeeGenerator(), 4);
    for(Coffee c:coffee){
        System.out.println(c);
    }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">####一个通用的Generator</div></pre></td></tr></table></figure></p>
<p>public class BaseGenerator<t> implements Generator<t>{<br>    private Class<t> type;<br>    public BaseGenerator(Class<t> type){this.type = type;}</t></t></t></t></p>
<pre><code>public T next() {
    try {
        return type.newInstance();
    } catch (Exception e) {
        throw new RuntimeException();
    } 
}
public static &lt;T&gt; Generator&lt;T&gt; create(Class&lt;T&gt; type){
    return new BaseGenerator&lt;T&gt;(type);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">要使用这个生成器，这个类必须声明为public和必须有默认的构造函数。例如使用：</div></pre></td></tr></table></figure></p>
<p>public class CountedObject {<br>    private static long count = 0;<br>    private final long id = count++;<br>    private long id(){return id;}<br>    public String toString(){return “CountedObject”+id;}<br>}<br>//—<br>public class BaseGeneratorDome {<br>    public static void main(String[] args) {<br>        Generator<countedobject> gen = BaseGenerator.create(CountedObject.class);<br>        for(int i = 0;i<5;i++){ system.out.println(gen.next());="" }="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">同时我又改造了一下，使他可以支持有参构造函数😁：</div></pre></td></tr></table></5;i++){></countedobject></p>
<p>public class BaseGenerator<t> implements Generator<t>{<br>    private Class<t> type;<br>    private Object[] a;<br>    public BaseGenerator(Class<t> type){this.type = type;}<br>    public BaseGenerator(Class<t> type,Object[] a){this.type = type;this.a= a;;}</t></t></t></t></t></p>
<pre><code>public T next() {
    try {
        return type.newInstance();
    } catch (Exception e) {
        throw new RuntimeException();
    } 
}
public T next(Class&lt;?&gt;... agrs) {
    try {
        Constructor c = type.getDeclaredConstructor(agrs);
        c.setAccessible(true); 
        return (T) c.newInstance(a);
    }catch (Exception e) {
        throw new RuntimeException();
    } 
}

public static &lt;T&gt; Generator&lt;T&gt; create(Class&lt;T&gt; type){
    return new BaseGenerator&lt;T&gt;(type);
}
public static &lt;T&gt; Generator&lt;T&gt; create(Class&lt;T&gt; type,Object[] a){
    return new BaseGenerator&lt;T&gt;(type,a);
}
</code></pre><p>}<br>//—使用—<br>Generator<countedobject> gen1 = BaseGenerator.create(CountedObject.class,new Object[]{5,6});<br>        gen1.next(new Class[]{int.class,int.class});</countedobject></p>
<p>```</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写一些看书的笔记&lt;/p&gt;
&lt;p&gt;##第二章 一切都是对象&lt;/p&gt;
&lt;p&gt;###JAVA堆栈和堆&lt;br&gt;&amp;emsp;&amp;emsp;堆栈就是平时所说的栈，位于通用的ROM中，从堆栈指针从处理器那里获得直接支持。堆栈的指针向下移动，分配新的内存，向上移动，释放内存。在创建程序时，系统必须知道存储在盾战中所有的项目的确切生命周期，以便赏析移动堆栈的指针。这一约束限制了程序的灵活性，所以虽然某些JAVA数据存储在堆栈中–特别是对象引用，但是JAVA对象并不存储其中（&lt;del&gt;然而我并不怎么理解&lt;/del&gt;。。）。&lt;br&gt;&amp;emsp;&amp;emsp;堆是一种通用的内存池，也是位于RAM中，用于存放所有的JAVA对象。堆对于栈的好处就是：编译器不需要知道存储的数据在堆里存货多长时间。当需要一个对象时，只需要去new，当执行这个代码会自动在堆内进行储存分配。但是用堆进行存储分配和清理可能比用栈分配需要更多的时间。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>聊聊从setContentView到界面的显示</title>
    <link href="http://yoursite.com/2016/07/09/%E8%81%8A%E8%81%8A%E4%BB%8EsetContentView%E5%88%B0%E7%95%8C%E9%9D%A2%E7%9A%84%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2016/07/09/聊聊从setContentView到界面的显示/</id>
    <published>2016-07-09T15:34:45.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>###背景<br>&emsp;&emsp;为什么要写这篇呢，其实想写一篇比较深入的文章很久了，只是一直比较懒和各种接口没去花精力去实施，正好有个元旦假期，花了点时间看了一些博客再加上自己的分析，然后想记录下来，不敢说多么的精彩和深入，就当个笔记。也算是<code>frameWork</code>层的初步探索吧。开始吧。<a id="more"></a></p>
<p>###setContentView<br>&emsp;&emsp;在Android里面，去设置布局最常见的就是在<code>onCreate</code>方法里面使用<code>setContentView(int layoutResID)</code>这个函数把定义的XML文件设置进去，跟进去看看，发现其实有三个重载的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">        getWindow().setContentView(layoutResID);</div><div class="line">        initWindowDecorActionBar();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setContentView(View view) &#123;</div><div class="line">        getWindow().setContentView(view);</div><div class="line">        initWindowDecorActionBar();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setContentView(View view, ViewGroup.LayoutParams params) &#123;</div><div class="line">        getWindow().setContentView(view, params);</div><div class="line">        initWindowDecorActionBar();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>但是最终都是调用了<code>getWindow().setContentView</code>，这个<code>getWindow()</code>又是啥？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Window getWindow() &#123;</div><div class="line">        return mWindow;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>返回的是一个<code>Window</code>对象，这个<code>Window</code>是个抽象类(不那么啰嗦了),真正作用的是唯一的一个实现类<code>PhoneWindow</code>，在<code>attach</code>里面可以看到<code>mWindow = new PhoneWindow(this);</code>再回到前面还有个方法<code>initWindowDecorActionBar();</code>看名字是初始化Window装饰ActionBar，进去看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Creates a new ActionBar, locates the inflated ActionBarView,</div><div class="line">     * initializes the ActionBar with the view, and sets mActionBar.</div><div class="line">     */</div><div class="line">    private void initWindowDecorActionBar() &#123;</div><div class="line">        Window window = getWindow();</div><div class="line"></div><div class="line">        // Initializing the window decor can change window feature flags.</div><div class="line">        // Make sure that we have the correct set before performing the test below.</div><div class="line">        window.getDecorView();</div><div class="line"></div><div class="line">        if (isChild() || !window.hasFeature(Window.FEATURE_ACTION_BAR) || mActionBar != null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mActionBar = new WindowDecorActionBar(this);</div><div class="line">        mActionBar.setDefaultDisplayHomeAsUpEnabled(mEnableDefaultActionBarUp);</div><div class="line"></div><div class="line">        mWindow.setDefaultIcon(mActivityInfo.getIconResource());</div><div class="line">        mWindow.setDefaultLogo(mActivityInfo.getLogoResource());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里看到又调用了<code>getWindow</code>而且下面还有个<code>window.getDecorView();</code>上面的注释看到，这个函数执行之后就初始化了<code>window</code>的各种<code>feature flags</code>所以这就是为什么我们常见的设置<code>feature</code>一定要在<code>setContentView</code>之前了，因为在执行<code>setContentView</code>之后，就把Window的相关特征标志给初始化了，再去设置也没什么卵用。这个<code>window.getDecorView()</code>在<code>PhoneWindow</code>是这个样子的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line"> public final View getDecorView() &#123;</div><div class="line">    if (mDecor == null) &#123;</div><div class="line">         installDecor();</div><div class="line">     &#125;</div><div class="line">      return mDecor;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这个<code>installDecor</code>在<code>setContentView</code>里面也有使用，还是回去吧，看看<code>setContentView</code>里面是什么样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</div><div class="line">        // decor, when theme attributes and the like are crystalized. Do not check the feature</div><div class="line">        // before this happens.</div><div class="line">        if (mContentParent == null) &#123;</div><div class="line">            installDecor();//这个见过了，后面会再说</div><div class="line">        &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">            mContentParent.removeAllViews();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">        //这个在共享元素里面用过</div><div class="line">            final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</div><div class="line">                    getContext());</div><div class="line">            transitionTo(newScene);</div><div class="line">        &#125; else &#123;</div><div class="line">        //这个就是把布局文件加入到mContentParent</div><div class="line">            mLayoutInflater.inflate(layoutResID, mContentParent);</div><div class="line">        &#125;</div><div class="line">        final Callback cb = getCallback();</div><div class="line">        //就是回调喽，可以发现我们可以多次调用setContentView，因为会removeAllViews，并且会回调onContentChanged，在这个方法里面就可以执行想要的操作了。</div><div class="line">        if (cb != null &amp;&amp; !isDestroyed()) &#123;</div><div class="line">            cb.onContentChanged();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里有两个疑问，<code>mContentParent</code>是啥？<code>installDecor();</code>里面到底干了啥？下面再细说一下。</p>
<p>###installDecor()</p>
<p>直接进入这个方法看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//只看关键的</div><div class="line">private void installDecor() &#123;</div><div class="line">     if (mDecor == null) &#123;</div><div class="line">            mDecor = generateDecor();</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">         if (mContentParent == null) &#123;</div><div class="line">            mContentParent = generateLayout(mDecor);</div><div class="line">          &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要关注<code>generateDecor</code>和<code>generateLayout(mDecor)</code>，这里顺便把上面的<code>mContentParent</code>的问题提到了一点，<code>mContentParent</code>就是在这里初始化的，先看上面的<code>mDecor = generateDecor();</code>进去看到这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected DecorView generateDecor() &#123;</div><div class="line">      return new DecorView(getContext(), -1);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这个<code>DecorView</code>是啥？他是<code>PhoneWindow</code>的一个静态内部类：</p>
<pre><code>private final class DecorView extends FrameLayout implements RootViewSurfaceTaker
</code></pre><p>看到吧，其实就是个继承<code>FrameLayout</code>的<code>ViewGroup</code>，看一张图,转自<a href="http://blog.csdn.net/yanbober/article/details/45970721" target="_blank" rel="external">工匠若水</a></p>
<p><img src="http://img.blog.csdn.net/20150604144532934" alt=""><br>先说个结论：<code>mContentParent</code>就是<code>DecorView</code>里面的那个<code>content</code>,我们平时写的布局都是扔到了这个里面，所以叫做<code>setContentView()</code>，而<code>DecorView</code>就是包裹在外面的一层更根的布局。。不信可以进去<code>generateLayout(mDecor)</code>方法里面看看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">protected ViewGroup generateLayout(DecorView decor) &#123;</div><div class="line">        // Apply data from current theme.</div><div class="line"></div><div class="line">        TypedArray a = getWindowStyle();</div><div class="line"></div><div class="line">        //......</div><div class="line">        //依据主题style设置一堆值进行设置</div><div class="line"></div><div class="line">        // Inflate the window decor.</div><div class="line"></div><div class="line">        int layoutResource;</div><div class="line">        int features = getLocalFeatures();</div><div class="line">        //......</div><div class="line">        //根据设定好的features值选择不同的窗口修饰布局文件,得到layoutResource值</div><div class="line"></div><div class="line">        //把选中的窗口修饰布局文件添加到DecorView对象里，并且指定contentParent值</div><div class="line">        View in = mLayoutInflater.inflate(layoutResource, null);//加载了我们平时写的XML文件</div><div class="line">        decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));//把我们写的文件加到DecorView中，并且设置为MATCH_PARENT，看吧，为什么默认都是MATCH_PARENT。</div><div class="line">        mContentRoot = (ViewGroup) in;</div><div class="line"></div><div class="line">        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);//这就是那个content</div><div class="line">        if (contentParent == null) &#123;</div><div class="line">            throw new RuntimeException(&quot;Window couldn&apos;t find content container view&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //......</div><div class="line">        //继续一堆属性设置，完事返回contentParent</div><div class="line">        return contentParent;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>总结一下<code>setContentView</code>的过程：</p>
<ol>
<li>创建一个DecorView的对象mDecor，该mDecor对象将作为整个应用窗口的根视图。</li>
<li>调用<code>generateLayout(DecorView decor)</code>依据Feature等style theme创建不同的窗口修饰布局文件，然后</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">View in = mLayoutInflater.inflate(layoutResource, null);</div><div class="line"></div><div class="line">decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); </div><div class="line"></div><div class="line">ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</div></pre></td></tr></table></figure>
<p>到这，<code>setContentView</code>就差不多走完了，这个工作我们一般是在<code>onCreate()</code>里面进行，但是还远没有到显示的地方，下面来简单说一下显示的过程，一个Activity的开始实际是<code>ActivityThread</code>的main方法(这个还没分析过Activity的启动过程，先就这么认为吧)，当启动Activity调运完<code>ActivityThread</code>的main方法之后，接着调用<code>ActivityThread</code>类<code>performLaunchActivity</code>来创建要启动的Activity组件，在创建Activity组件的过程中，还会为该Activity组件创建窗口对象和视图对象；接着Activity组件创建完成之后，通过调用ActivityThread类的<code>handleResumeActivity</code>将它激活。看一下这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">final void handleResumeActivity(IBinder token,</div><div class="line">            boolean clearHide, boolean isForward, boolean reallyResume) &#123;</div><div class="line"></div><div class="line">            //这个时候，Activity.onResume()已经调用了，但是现在界面还是不可见的</div><div class="line">            ActivityClientRecord r = performResumeActivity(token, clearHide);</div><div class="line"></div><div class="line">            if (r != null) &#123;</div><div class="line">                final Activity a = r.activity;</div><div class="line">                  if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</div><div class="line">                r.window = r.activity.getWindow();</div><div class="line">                View decor = r.window.getDecorView();</div><div class="line">                //decor对用户不可见</div><div class="line">                decor.setVisibility(View.INVISIBLE);</div><div class="line">                ViewManager wm = a.getWindowManager();</div><div class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</div><div class="line">                a.mDecor = decor;</div><div class="line">                //这里记住这个WindowManager.LayoutParams的type为TYPE_BASE_APPLICATION，后面介绍Window的时候会见到</div><div class="line">                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</div><div class="line"></div><div class="line">                if (a.mVisibleFromClient) &#123;</div><div class="line">                    a.mWindowAdded = true;</div><div class="line">                    //终于被添加进WindowManager了，但是这个时候，还是不可见的</div><div class="line">                    wm.addView(decor, l);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (!r.activity.mFinished &amp;&amp; willBeVisible</div><div class="line">                    &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123;</div><div class="line">                     //在这里，执行了重要的操作！</div><div class="line">                     if (r.activity.mVisibleFromClient) &#123;</div><div class="line">                            r.activity.makeVisible();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>其中的<code>makeVisible</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void makeVisible() &#123;</div><div class="line">        if (!mWindowAdded) &#123;</div><div class="line">            ViewManager wm = getWindowManager();</div><div class="line">            wm.addView(mDecor, getWindow().getAttributes());</div><div class="line">            mWindowAdded = true;</div><div class="line">        &#125;</div><div class="line">        mDecor.setVisibility(View.VISIBLE);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>到现在，整个界面才真正的显示出来，所以当调用了<code>onResume</code>方法，界面也不一定是显示的。这里还有几个问题，<code>mLayoutInflater.inflate(layoutResID, mContentParent)</code>这个到底是怎么把XML解析成view的，<code>findViewById</code>是怎么找view的，还有就是<code>WindowManager</code>是啥？他和前面提到的<code>Window</code>，<code>PhoneWindow</code>，<code>DecorView</code>啥关系？下面会再来扯一扯。</p>
<p>###findViewById<br>我们平时在<code>Activity</code>里面去使用，跟进去看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public View findViewById(@IdRes int id) &#123;</div><div class="line">        return getWindow().findViewById(id);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>好吧，熟悉吧，再进去看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Nullable</div><div class="line">   public View findViewById(@IdRes int id) &#123;</div><div class="line">       return getDecorView().findViewById(id);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>看，到了view的地方，再进去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public final View findViewById(@IdRes int id) &#123;</div><div class="line">        if (id &lt; 0) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        return findViewTraversal(id);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>再进去看看这个递归函数是怎么回事：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">protected View findViewTraversal(@IdRes int id) &#123;</div><div class="line">        if (id == mID) &#123;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>就是返回自己啊，但是仔细想想，还是得去<code>ViewGroup</code>去看，具体原因就不扯了，这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected View findViewTraversal(@IdRes int id) &#123;</div><div class="line">        if (id == mID) &#123;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final View[] where = mChildren;</div><div class="line">        final int len = mChildrenCount;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; len; i++) &#123;</div><div class="line">            View v = where[i];</div><div class="line"></div><div class="line">            if ((v.mPrivateFlags &amp; PFLAG_IS_ROOT_NAMESPACE) == 0) &#123;</div><div class="line">                v = v.findViewById(id);</div><div class="line"></div><div class="line">                if (v != null) &#123;</div><div class="line">                    return v;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>就是去遍历<code>ViewGroup</code>里面的<code>View</code>，然后去调用<code>View</code>的<code>findViewById</code>，所以我们的<code>findViewById</code>都是在<code>DecorView</code>这个<code>ViewGroup</code>里面去查找的。</p>
<p>###mLayoutInflater.inflate<br>当需要加载个XML布局文件的时候，一般这样使用<code>LayoutInflater.from(this).inflate()</code>，里面有一些函数的重载，但是最终都是走到了这里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">        final Resources res = getContext().getResources();</div><div class="line">        if (DEBUG) &#123;</div><div class="line">            Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;</div><div class="line">                    + Integer.toHexString(resource) + &quot;)&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final XmlResourceParser parser = res.getLayout(resource);</div><div class="line">        try &#123;</div><div class="line">            return inflate(parser, root, attachToRoot);</div><div class="line">        &#125; finally &#123;</div><div class="line">            parser.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>使用XML解析器去解析XML文件，关键是第10行，进去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">        ...</div><div class="line">        //返回值</div><div class="line">            View result = root;</div><div class="line">        ...</div><div class="line">                //merge的布局优化，root必须非空且attachToRoot为true，</div><div class="line">                if (TAG_MERGE.equals(name)) &#123;</div><div class="line">                    if (root == null || !attachToRoot) &#123;</div><div class="line">                        throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</div><div class="line">                                + &quot;ViewGroup root and attachToRoot=true&quot;);</div><div class="line">                    &#125;</div><div class="line">                    //递归解析</div><div class="line">                    rInflate(parser, root, inflaterContext, attrs, false);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // Temp is the root view that was found in the xml根据节点创建view</div><div class="line">                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);</div><div class="line"></div><div class="line">                    ViewGroup.LayoutParams params = null;</div><div class="line">。。。</div><div class="line">                        // Create layout params that match root, if supplied  生成合适的layout params</div><div class="line">                        params = root.generateLayoutParams(attrs);</div><div class="line">                        if (!attachToRoot) &#123;</div><div class="line">                            // Set the layout params for temp if we are not</div><div class="line">                            // attaching. (If we are, we use addView, below)</div><div class="line">                            temp.setLayoutParams(params);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    // Inflate all children under temp against its context. 继续递归</div><div class="line">                    rInflateChildren(parser, temp, attrs, true);</div><div class="line"></div><div class="line">                    // We are supposed to attach all the views we found (int temp)</div><div class="line">                    // to root. Do that now.</div><div class="line">                    if (root != null &amp;&amp; attachToRoot) &#123;</div><div class="line">                //root非空且attachToRoot=true则将xml文件的root view加到形参提供的root里</div><div class="line">                        root.addView(temp, params);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    // Decide whether to return the root that was passed in or the</div><div class="line">                    // top view found in xml.</div><div class="line">                    if (root == null || !attachToRoot) &#123;</div><div class="line">                    //这里就直接返回解析的view</div><div class="line">                        result = temp;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">        。。。</div><div class="line"></div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>所以从上面的代码可以总结一下：</p>
<ul>
<li><p>inflate(xmlId, null); 只创建temp的View，然后直接返回temp。</p>
</li>
<li><p>inflate(xmlId, parent); 创建temp的View，然后执行root.addView(temp, params);最后返回root。</p>
</li>
<li><p>inflate(xmlId, parent, false); 创建temp的View，然后执行temp.setLayoutParams(params);然后再返回temp。</p>
</li>
<li><p>inflate(xmlId, parent, true); 创建temp的View，然后执行root.addView(temp, params);最后返回root。</p>
</li>
<li><p>inflate(xmlId, null, false); 只创建temp的View，然后直接返回temp。</p>
</li>
<li><p>inflate(xmlId, null, true); 只创建temp的View，然后直接返回temp。</p>
</li>
</ul>
<p>这里也引出了一个问题，就是有时候我们通过View的<code>layout_width</code>和<code>layout_height</code>来设置view的大小，然后通过<code>inflate</code>解析之后发现并不管用，这里的代码就可以说明问题，其实这两个属性并不是用来设置view的大小的，而是用来设置view在ViewGroup中的大小，(有点晕？后面会有专门的一篇来说这个)，所以叫做<code>layout_width</code>而不是直接叫做<code>width</code>。简单举个例子说一下：</p>
<ul>
<li><code>mInflater.inflate(R.layout.textview_layout, null)</code>不能正确处理我们设置的宽和高是因为layout_width，layout_height是相对了父级设置的，而此temp的getLayoutParams为null。</li>
<li><code>mInflater.inflate(R.layout.textview_layout, parent)</code>能正确显示我们设置的宽高是因为我们的View在设置setLayoutParams时<code>params = root.generateLayoutParams(attrs)</code>不为空。 </li>
</ul>
<p>其他就不多说了，也就是说只有这是了父布局才能正确的显示宽和高，同时可以注意到，在<code>Activity</code>中指定布局宽高的时候是可以正确显示的，这不正好说明了还存在更底层的一层id为content的FrameLayout吗。</p>
<p>参考：</p>
<p><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/49681321" target="_blank" rel="external">【凯子哥带你学Framework】Activity界面显示全解析</a></p>
<p><a href="http://blog.csdn.net/yanbober/article/details/45970721" target="_blank" rel="external"> Android应用setContentView与LayoutInflater加载解析机制源码分析</a></p>
<p><a href="http://grepcode.com/file/repo1.maven.org/maven2/org.robolectric/android-all/5.0.0_r2-robolectric-1/com/android/internal/policy/impl/PhoneWindow.java#PhoneWindow.generateLayout%28com.android.internal.policy.impl.PhoneWindow.DecorView%29" target="_blank" rel="external">PhoneWindow源码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###背景&lt;br&gt;&amp;emsp;&amp;emsp;为什么要写这篇呢，其实想写一篇比较深入的文章很久了，只是一直比较懒和各种接口没去花精力去实施，正好有个元旦假期，花了点时间看了一些博客再加上自己的分析，然后想记录下来，不敢说多么的精彩和深入，就当个笔记。也算是&lt;code&gt;frameWork&lt;/code&gt;层的初步探索吧。开始吧。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>View的绘制过程</title>
    <link href="http://yoursite.com/2016/07/09/View%E7%9A%84%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/07/09/View的绘制过程/</id>
    <published>2016-07-09T15:33:41.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这次来说一说view的绘制过程，同样也算是个笔记的东西，梳理一下大致的过程，忽略了内部很多的条件判断等。上次说了<code>setcontentview</code>和<code>infalter</code>的一些简单过程，这个是用来把view从XML文件的格式解析和加载，但是具体view的怎么绘制到界面上的并没有提及，还有上次留下的问题，有时间学习了<code>activity</code>的启动流程再来说一下，现在开始吧。<a id="more"></a></p>
<p>&emsp;&emsp;网上有很多的文章说view的绘制，无非就是三个方法<code>onMeasure</code>,<code>onLayout</code>,<code>onDraw</code>，但是这仅仅是冰山一角，这三个方法的调用时机和内部的大致运行逻辑并没有说清楚，现在先从view开始的地方说起。</p>
<p>&emsp;&emsp;view从什么地方开始绘制呢，先说结论吧，因为没有一些铺垫即使从开始的地方说起也是云里雾里，说完整个的大致过程，再去看开始的地方也就顺其自然了。view的绘制是从<code>ViewRootImpl</code> 的<code>performTraversals</code>方法开始的，翻译就是递归调用，我们已经知道，view是嵌套存在的，所以要去绘制整个的view肯定要去嵌套调用一些方法，(ps:这个源码是在API22下看的，在23的时候又有一些改变，但是整个的逻辑是没有变化的)。我们找到这个方法，这是个非常长的方法，一共有782行，所以会去忽略很多的判断条件，只所我们关注的三个重点方法，首先找到这里：</p>
<p>###Measure<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</div><div class="line">int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</div><div class="line">// Ask host how big it wants to be</div><div class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</div></pre></td></tr></table></figure></p>
<p>这里就是进行view测绘的地方，先去<code>getRootMeasureSpec</code>方法里面看看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123;</div><div class="line">        int measureSpec;</div><div class="line">        switch (rootDimension) &#123;</div><div class="line"></div><div class="line">        case ViewGroup.LayoutParams.MATCH_PARENT:</div><div class="line">            // Window can&apos;t resize. Force root view to be windowSize.</div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</div><div class="line">            break;</div><div class="line">        case ViewGroup.LayoutParams.WRAP_CONTENT:</div><div class="line">            // Window can resize. Set max size for root view.</div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            // Window wants to be an exact size. Force root view to be that size.</div><div class="line">            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        return measureSpec;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这是个组装参数的地方，像我们平常说的<code>MATCH_PARENT</code>对应<code>EXACTLY</code>，<code>WRAP_CONTENT</code>对应<code>AT_MOST</code>这里就看的很清楚了，而且这个根视图，之前提到过的，肯定是走<code>MATCH_PARENT</code>，这就是我们根视图总是全屏的原因。</p>
<p>&emsp;&emsp;回到前面还有个<code>performMeasure</code>方法，看注释也知道是干啥的，进去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);</div><div class="line">        try &#123;</div><div class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">        &#125; finally &#123;</div><div class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看，来到了view的<code>measure</code>方法，也就是说<code>measure</code>方法的两个参数其实都是父view的，下面还可以看到，真正决定一个view的大小是这父view的两个参数和子view共同决定的。下面就进到了view里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * &lt;p&gt;</div><div class="line">    * This is called to find out how big a view should be. The parent</div><div class="line">    * supplies constraint information in the width and height parameters.</div><div class="line">    * &lt;/p&gt;</div><div class="line">    *</div><div class="line">    * &lt;p&gt;</div><div class="line">    * The actual measurement work of a view is performed in</div><div class="line">    * &#123;@link #onMeasure(int, int)&#125;, called by this method. Therefore, only</div><div class="line">    * &#123;@link #onMeasure(int, int)&#125; can and must be overridden by subclasses.</div><div class="line">    * &lt;/p&gt;</div><div class="line">    *</div><div class="line">    *</div><div class="line">    * @param widthMeasureSpec Horizontal space requirements as imposed by the</div><div class="line">    *        parent</div><div class="line">    * @param heightMeasureSpec Vertical space requirements as imposed by the</div><div class="line">    *        parent</div><div class="line">    *</div><div class="line">    * @see #onMeasure(int, int)</div><div class="line">    */</div><div class="line">   public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">   ...各种不明白的东西。。😂</div><div class="line">   </div><div class="line">      onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line">      </div><div class="line">    ...继续各种不明白的东西。。😂</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这里主要还是看注释，四级水平理解一下，这个方法调用用来测量view应该有多大，父布局在宽高里面提供限制信息，也就是前面说的view的大小由爹和儿子一起决定，还有就是实际的测量工作是在子类的<code>onMeasure</code>方法里面搞，因为<code>measure</code>是final的。这就是平时自定义view的时候要去从写这个方法的原因，别急，还没完，进去看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * &lt;p&gt;</div><div class="line">     * Measure the view and its content to determine the measured width and the</div><div class="line">     * measured height. This method is invoked by &#123;@link #measure(int, int)&#125; and</div><div class="line">     * should be overridden by subclasses to provide accurate and efficient</div><div class="line">     * measurement of their contents.</div><div class="line">     * &lt;/p&gt;</div><div class="line">     *</div><div class="line">     * &lt;p&gt;</div><div class="line">     * &lt;strong&gt;CONTRACT:&lt;/strong&gt; When overriding this method, you</div><div class="line">     * &lt;em&gt;must&lt;/em&gt; call &#123;@link #setMeasuredDimension(int, int)&#125; to store the</div><div class="line">     * measured width and height of this view. Failure to do so will trigger an</div><div class="line">     * &lt;code&gt;IllegalStateException&lt;/code&gt;, thrown by</div><div class="line">     * &#123;@link #measure(int, int)&#125;. Calling the superclass&apos;</div><div class="line">     * &#123;@link #onMeasure(int, int)&#125; is a valid use.</div><div class="line">     * &lt;/p&gt;</div><div class="line">     *</div><div class="line">     * &lt;p&gt;</div><div class="line">     * The base class implementation of measure defaults to the background size,</div><div class="line">     * unless a larger size is allowed by the MeasureSpec. Subclasses should</div><div class="line">     * override &#123;@link #onMeasure(int, int)&#125; to provide better measurements of</div><div class="line">     * their content.</div><div class="line">     * &lt;/p&gt;</div><div class="line">     *</div><div class="line">     * &lt;p&gt;</div><div class="line">     * If this method is overridden, it is the subclass&apos;s responsibility to make</div><div class="line">     * sure the measured height and width are at least the view&apos;s minimum height</div><div class="line">     * and width (&#123;@link #getSuggestedMinimumHeight()&#125; and</div><div class="line">     * &#123;@link #getSuggestedMinimumWidth()&#125;).</div><div class="line">     * &lt;/p&gt;</div><div class="line">     *</div><div class="line">     * @param widthMeasureSpec horizontal space requirements as imposed by the parent.</div><div class="line">     *                         The requirements are encoded with</div><div class="line">     *                         &#123;@link android.view.View.MeasureSpec&#125;.</div><div class="line">     * @param heightMeasureSpec vertical space requirements as imposed by the parent.</div><div class="line">     *                         The requirements are encoded with</div><div class="line">     *                         &#123;@link android.view.View.MeasureSpec&#125;.</div><div class="line">     *</div><div class="line">     * @see #getMeasuredWidth()</div><div class="line">     * @see #getMeasuredHeight()</div><div class="line">     * @see #setMeasuredDimension(int, int)</div><div class="line">     * @see #getSuggestedMinimumHeight()</div><div class="line">     * @see #getSuggestedMinimumWidth()</div><div class="line">     * @see android.view.View.MeasureSpec#getMode(int)</div><div class="line">     * @see android.view.View.MeasureSpec#getSize(int)</div><div class="line">     */</div><div class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以去读一读注释，简单说一下，这个方法是用来测量view和它的内容，而且一定要调用<code>setMeasuredDimension</code>把测量的结果穿进去，基类默认实现的背景的大小(这个在下面看到)。如果重写了这个方法，你得搞清楚这个view的大小至少比最小的大（后面会说）。好吧，蹩脚的英文。也就是说当我们测量完view之后，再<code>setMeasuredDimension</code>，我们的工作就结束了。那么这个方法是什么东西，去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static int getDefaultSize(int size, int measureSpec) &#123;</div><div class="line">        int result = size;</div><div class="line">        int specMode = MeasureSpec.getMode(measureSpec);</div><div class="line">        int specSize = MeasureSpec.getSize(measureSpec);</div><div class="line"></div><div class="line">        switch (specMode) &#123;</div><div class="line">        case MeasureSpec.UNSPECIFIED:</div><div class="line">            result = size;</div><div class="line">            break;</div><div class="line">        case MeasureSpec.AT_MOST:</div><div class="line">        case MeasureSpec.EXACTLY:</div><div class="line">            result = specSize;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到，默认的时候，当设置<code>wrap_content</code>和<code>march_parent</code>都是默认的父布局的大小，这里的size是进一步<code>getSuggestedMinimumWidth</code>传进来的,而这个的大小是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected int getSuggestedMinimumWidth() &#123;</div><div class="line">       return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>看有没有背景，这个默认是0，也可以在XML中设置,这样也说完了前面的两个问题。</p>
<p>&emsp;&emsp;到这里，似乎view的测量就完了，但是不要忘记，view是嵌套的，要去测量完整个的view，还得去<code>viewgroup</code>里面看看，<code>viewgroup</code>里面有三个方法：<code>measureChildren</code>, <code>measureChild</code>, <code>measureChildWithMargins</code>，一个个看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Ask all of the children of this view to measure themselves, taking into</div><div class="line">     * account both the MeasureSpec requirements for this view and its padding.</div><div class="line">     * We skip children that are in the GONE state The heavy lifting is done in</div><div class="line">     * getChildMeasureSpec.</div><div class="line">     *</div><div class="line">     * @param widthMeasureSpec The width requirements for this view</div><div class="line">     * @param heightMeasureSpec The height requirements for this view</div><div class="line">     */</div><div class="line">    protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class="line">        final int size = mChildrenCount;</div><div class="line">        final View[] children = mChildren;</div><div class="line">        for (int i = 0; i &lt; size; ++i) &#123;</div><div class="line">            final View child = children[i];</div><div class="line">            if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</div><div class="line">                measureChild(child, widthMeasureSpec, heightMeasureSpec);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>遍历所以的子view，去测量，如果是gone的，就跳过。然后进入<code>measureChild</code>，提醒一下，这里传进去的<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>都是父view的，用来在子view测量的时候共同决定大小用的。这里的<code>measureChild</code>只包含<code>Padding</code>，<code>measureChildWithMargins</code>还包含<code>Margin</code>，调复杂的看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">protected void measureChildWithMargins(View child,</div><div class="line">            int parentWidthMeasureSpec, int widthUsed,</div><div class="line">            int parentHeightMeasureSpec, int heightUsed) &#123;</div><div class="line">            //获取子的LayoutParams</div><div class="line">        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</div><div class="line">//看，子view的大小是由谁决定的，没错吧，这里竟然还直接获取到了lp.width，这个看下面解释吧。提示一下：这个参数是：How big the child wants to be in the current dimension</div><div class="line">        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</div><div class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</div><div class="line">                        + widthUsed, lp.width);</div><div class="line">        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</div><div class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</div><div class="line">                        + heightUsed, lp.height);</div><div class="line">       //调用view的measure进而调用onmeasure</div><div class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看注释，然后看重要的<code>getChildMeasureSpec</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</div><div class="line">        int specMode = MeasureSpec.getMode(spec);</div><div class="line">        int specSize = MeasureSpec.getSize(spec);</div><div class="line"></div><div class="line">        int size = Math.max(0, specSize - padding);</div><div class="line"></div><div class="line">        int resultSize = 0;</div><div class="line">        int resultMode = 0;</div><div class="line">        //父view的模式</div><div class="line">        switch (specMode) &#123;</div><div class="line">        // Parent has imposed an exact size on us</div><div class="line">        //父view是具体数值或者march_parent</div><div class="line">        case MeasureSpec.EXACTLY:</div><div class="line">            if (childDimension &gt;= 0) &#123;//子view为具体数值</div><div class="line">               //直接赋值具体数值</div><div class="line">                resultSize = childDimension;</div><div class="line">                //返回子view的模式设置为EXACTLY</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;//子view是MATCH_PARENT，数值为-1</div><div class="line">                // Child wants to be our size. So be it.</div><div class="line">                //直接赋值父view的大小</div><div class="line">                resultSize = size;</div><div class="line">                 //返回子view的模式设置为EXACTLY</div><div class="line">                resultMode = MeasureSpec.EXACTLY;</div><div class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;//子view是WRAP_CONTENT，数值为-2</div><div class="line">                // Child wants to determine its own size. It can&apos;t be</div><div class="line">                // bigger than us.</div><div class="line">                //设置子view的最大值不能超过父view</div><div class="line">                //这个一般还会在子view的onmeasure里面去重写，是吧</div><div class="line">                resultSize = size;</div><div class="line">                //返回子view的模式设置为AT_MOST</div><div class="line">                resultMode = MeasureSpec.AT_MOST;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line"></div><div class="line">     //。。。。</div><div class="line">     //过程差不多的两个模式AT_MOST和UNSPECIFIED</div><div class="line">       </div><div class="line">        &#125;</div><div class="line">        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注释已经很详细了，这就是我们见到的父view和子view的在某些关系下面的布局样式。这次明白了吧。整个逻辑大概说一下，rootview获得宽高和模式，通过<code>MeasureSpec</code>传给下一级，一般是<code>viewgroup</code>，然后<code>viewgroup</code>主要调用<code>getChildMeasureSpec</code>根据上面的<code>MeasureSpec</code>子view的<code>childDimension</code>来确定自己<code>viewgroup</code>的大小，如果还有子view，把计算出来的自己的<code>MeasureSpec</code>再传下去.在viewgroup中我们并没有看到调用<code>setMeasuredDimension</code>方法去把测量的值传递进去，这个是因为viewgroup是个抽象类，具体的测量方式需要我们自己去实现，比如可以去看看<code>LinearLayout</code>的实现，就在测量完成后调用了<code>setMeasuredDimension</code>方法。所以在一般自定义viewgroup的时候，可以先去调用<code>measureChildren</code>去测量完全部的子view，这样就可以去获取子view的宽高，然后再干什么就随你了，最后不要忘记去调用<code>setMeasuredDimension</code>方法。</p>
<p>###layout<br>&emsp;&emsp;现在整个view的测绘就差不多结束了，下一步就是开始layout的步骤。先去看viewgroup里面的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public final void layout(int l, int t, int r, int b) &#123;</div><div class="line">       if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123;</div><div class="line">           if (mTransition != null) &#123;</div><div class="line">               mTransition.layoutChange(this);</div><div class="line">           &#125;</div><div class="line">           super.layout(l, t, r, b);</div><div class="line">       &#125; else &#123;</div><div class="line">           // record the fact that we noop&apos;d it; request layout when transition finishes</div><div class="line">           mLayoutCalledWhileSuppressed = true;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>其实还是调用了view里面的<code>layout</code>方法，进去看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void layout(int l, int t, int r, int b) &#123;</div><div class="line">        ......</div><div class="line">        if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">            //回调onLayout</div><div class="line">            onLayout(changed, l, t, r, b);</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>和<code>measure</code>的过程差不多，还是去调用<code>onLayout</code>方法，看一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>空的，那viewgroup的呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected abstract void onLayout(boolean changed,</div><div class="line">            int l, int t, int r, int b);</div></pre></td></tr></table></figure>
<p>也是空的，还变成抽象的了，那总结一下：view的layuout方法并没有像<code>measure</code>方法一下是final的，但是也是不推荐去重写的，如果有需要还是去重写<code>onLayout</code>方法，而在viewgroup中，<code>layout</code>变成了final,<code>onLayout</code>方法变成抽象的了，这就要求子类必须去实现这个过程，也就是要去子类自己去决定里面的view怎么去排布，所以去找个子类看看，还是拿<code>LinearLayout</code>看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        if (mOrientation == VERTICAL) &#123;</div><div class="line">            layoutVertical(l, t, r, b);</div><div class="line">        &#125; else &#123;</div><div class="line">            layoutHorizontal(l, t, r, b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>看名字就知道了，不解释，选个<code>layoutVertical</code>看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">void layoutVertical(int left, int top, int right, int bottom) &#123;</div><div class="line">        final int paddingLeft = mPaddingLeft;</div><div class="line"></div><div class="line">        int childTop;</div><div class="line">        int childLeft;</div><div class="line">        //理解为父view提供给子view的宽度</div><div class="line">        // Where right end of child should go</div><div class="line">        final int width = right - left;</div><div class="line">        //子view在父view中的右边位置</div><div class="line">        int childRight = width - mPaddingRight;</div><div class="line">        </div><div class="line">        //子view的可用大小</div><div class="line">        // Space available for child</div><div class="line">        int childSpace = width - paddingLeft - mPaddingRight;</div><div class="line">        //子view的数量</div><div class="line">        final int count = getVirtualChildCount();</div><div class="line">        //主要的Gravity方式</div><div class="line">        final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</div><div class="line">        final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</div><div class="line"></div><div class="line">        switch (majorGravity) &#123;</div><div class="line">           case Gravity.BOTTOM://居底</div><div class="line">               // mTotalLength contains the padding already</div><div class="line">               childTop = mPaddingTop + bottom - top - mTotalLength;</div><div class="line">               break;</div><div class="line"></div><div class="line">               // mTotalLength contains the padding already</div><div class="line">           case Gravity.CENTER_VERTICAL:</div><div class="line">               childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;</div><div class="line">               break;</div><div class="line"></div><div class="line">           case Gravity.TOP:</div><div class="line">           default:</div><div class="line">               childTop = mPaddingTop;</div><div class="line">               break;</div><div class="line">        &#125;</div><div class="line">//开始遍历了</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            final View child = getVirtualChildAt(i);</div><div class="line">            if (child == null) &#123;</div><div class="line">                childTop += measureNullChild(i);</div><div class="line">                //忽略gone的</div><div class="line">            &#125; else if (child.getVisibility() != GONE) &#123;</div><div class="line">                final int childWidth = child.getMeasuredWidth();</div><div class="line">                final int childHeight = child.getMeasuredHeight();</div><div class="line">                </div><div class="line">                final LinearLayout.LayoutParams lp =</div><div class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</div><div class="line">                </div><div class="line">                int gravity = lp.gravity;</div><div class="line">                if (gravity &lt; 0) &#123;</div><div class="line">                    gravity = minorGravity;</div><div class="line">                &#125;</div><div class="line">                final int layoutDirection = getLayoutDirection();</div><div class="line">                final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</div><div class="line">                switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</div><div class="line">                    case Gravity.CENTER_HORIZONTAL:</div><div class="line">                        childLeft = paddingLeft + ((childSpace - childWidth) / 2)</div><div class="line">                                + lp.leftMargin - lp.rightMargin;</div><div class="line">                        break;</div><div class="line"></div><div class="line">                    case Gravity.RIGHT:</div><div class="line">                        childLeft = childRight - childWidth - lp.rightMargin;</div><div class="line">                        break;</div><div class="line"></div><div class="line">                    case Gravity.LEFT:</div><div class="line">                    default:</div><div class="line">                        childLeft = paddingLeft + lp.leftMargin;</div><div class="line">                        break;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (hasDividerBeforeChildAt(i)) &#123;</div><div class="line">                    childTop += mDividerHeight;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                childTop += lp.topMargin;</div><div class="line">                //其实还是调用view.layout</div><div class="line">                setChildFrame(child, childLeft, childTop + getLocationOffset(child),</div><div class="line">                        childWidth, childHeight);</div><div class="line">                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</div><div class="line"></div><div class="line">                i += getChildrenSkipCount(child, i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>整个的layout过程比measure好理解，还要提一下，平时使用的时候会遇到<code>getMeasuredWidth</code>和<code>getWidth</code>，这里就差不多可以理解了，第一个是在measure之后可以获取到，而第二个需要在layout之后才可以获取到，一般都是一样的。总结一下：<br>measure操作完成后得到的是对每个View经测量过的measuredWidth和<code>measuredHeight</code>，layout操作完成之后得到的是对每个View进行位置分配后的mLeft、mTop、mRight、mBottom，这些值都是相对于父View来说的。凡是<code>layout_XXX</code>的布局属性基本都针对的是包含子View的ViewGroup的，当对一个没有父容器的View设置相关<code>layout_XXX</code>属性是没有任何意义的，看前面的那篇。到这里，layout的过程也差不多了，该到了绘制的时候了。</p>
<p>###draw<br>view的绘制过程是比较复杂的，贴一张图，来自<a href="http://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="external">工匠若水</a><br><img src="http://img.blog.csdn.net/20150530154328068" alt=""><br>因为viewgroup没有去重写draw方法，直接去看view里面的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void draw(Canvas canvas) &#123;</div><div class="line">       ...</div><div class="line"></div><div class="line">       /*</div><div class="line">        * Draw traversal performs several drawing steps which must be executed</div><div class="line">        * in the appropriate order:</div><div class="line">        *</div><div class="line">        *      1. Draw the background</div><div class="line">        *      2. If necessary, save the canvas&apos; layers to prepare for fading</div><div class="line">        *      3. Draw view&apos;s content</div><div class="line">        *      4. Draw children</div><div class="line">        *      5. If necessary, draw the fading edges and restore layers</div><div class="line">        *      6. Draw decorations (scrollbars for instance)</div><div class="line">        */</div><div class="line">      ...</div></pre></td></tr></table></figure>
<p>注释写的很清楚了，一共分为6步，其中2，5可以省略，一步步来吧</p>
<p>####第一步，对View的背景进行绘制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private void drawBackground(Canvas canvas) &#123;</div><div class="line">//平时设置的setbackground,实质都转变为一个Drawable</div><div class="line">        final Drawable background = mBackground;</div><div class="line">        ...</div><div class="line">        //设置绘制范围</div><div class="line">        setBackgroundBounds();</div><div class="line">        ...</div><div class="line">        final int scrollX = mScrollX;</div><div class="line">        final int scrollY = mScrollY;</div><div class="line">        if ((scrollX | scrollY) == 0) &#123;//没有滚动</div><div class="line">            background.draw(canvas);</div><div class="line">        &#125; else &#123;</div><div class="line">            canvas.translate(scrollX, scrollY);</div><div class="line">            //最终使用了Drawable的draw</div><div class="line">            background.draw(canvas);</div><div class="line">            canvas.translate(-scrollX, -scrollY);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>####第二步，保存图层，执行渐变操作<br>主要调用<code>canvas.saveLayer</code>方法，不多说</p>
<p>####第三步，绘制内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Step 3, draw the content</div><div class="line">       if (!dirtyOpaque) </div><div class="line">       onDraw(canvas);</div></pre></td></tr></table></figure>
<p>而<code>onDraw</code>又是个空方法，因为具体绘制什么东西还得具体的view说了算</p>
<p>####第四步，绘制所有的子view</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> // Step 4, draw the children</div><div class="line">        dispatchDraw(canvas);</div><div class="line">        </div><div class="line">/**</div><div class="line">     * Called by draw to draw the child views. This may be overridden</div><div class="line">     * by derived classes to gain control just before its children are drawn</div><div class="line">     * (but after its own view has been drawn).</div><div class="line">     * @param canvas the canvas on which to draw the view</div><div class="line">     */</div><div class="line">    protected void dispatchDraw(Canvas canvas) &#123;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里看到<code>dispatchDraw</code>是个空方法，注释里面说，如果包含子view就需要去重写这个方法，去viewgroup里面看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   protected void dispatchDraw(Canvas canvas) &#123;</div><div class="line">       ......</div><div class="line">       final int childrenCount = mChildrenCount;</div><div class="line">       final View[] children = mChildren;</div><div class="line">       ......</div><div class="line">       for (int i = 0; i &lt; childrenCount; i++) &#123;</div><div class="line">           ......</div><div class="line">           if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123;</div><div class="line">               more |= drawChild(canvas, child, drawingTime);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       ......</div><div class="line">       // Draw any disappearing views that have animations</div><div class="line">       if (mDisappearingChildren != null) &#123;</div><div class="line">           ......</div><div class="line">           for (int i = disappearingCount; i &gt;= 0; i--) &#123;</div><div class="line">               ......</div><div class="line">               more |= drawChild(canvas, child, drawingTime);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       ......</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>还是去遍历所有的子view,然后去调用view.draw方法</p>
<p>####第五步，绘制渐变效果并且恢复图层<br>这个和第二部相对应，不说了</p>
<p>###第六步，绘制view的滚动条<br>也不分析了，所以其实所有的 view都是有滚动条的</p>
<p>到这里，整个view就差不多绘制完成了。</p>
<p>###View的invalidate<br>如果去查一查view的源码，你会发现这个方法出现的特别多，我们这个方法是用来在主线程中调用去重绘view的，但是为什么会出现这么多次，而且它是怎么去实现重绘的呢，而且开头的时候还有一个问题没有解决，简单的看一下。<br>view有多个重载的<code>invalidate</code>，但是最终都走到了<code>invalidateInternal</code>方法，看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,</div><div class="line">            boolean fullInvalidate) &#123;</div><div class="line">        ......</div><div class="line">            final AttachInfo ai = mAttachInfo;</div><div class="line">            final ViewParent p = mParent;</div><div class="line">            if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</div><div class="line">                final Rect damage = ai.mTmpInvalRect;</div><div class="line">                //设置刷新区域</div><div class="line">                damage.set(l, t, r, b);</div><div class="line">                //传递调运ViewParent， 一般是ViewGroup的invalidateChild方法</div><div class="line">                p.invalidateChild(this, damage);</div><div class="line">            &#125;</div><div class="line">            ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里主要是<code>p.invalidateChild(this, damage);</code>这个方法，</p>
<blockquote>
<p>View的invalidate（invalidateInternal）方法实质是将要刷新区域直接传递给了父ViewGroup的invalidateChild方法，在invalidate中，调用父View的invalidateChild，这是一个从当前向上级父View回溯的过程，每一层的父View都将自己的显示区域与传入的刷新Rect做交集 。</p>
</blockquote>
<p>而<code>ViewParent</code>是个接口，viewgroup和<code>ViewRootImpl</code>都实现了这个接口，所以先去viewgroup看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public final void invalidateChild(View child, final Rect dirty) &#123;</div><div class="line">       ViewParent parent = this;</div><div class="line">       final AttachInfo attachInfo = mAttachInfo;</div><div class="line">       ......</div><div class="line">       do &#123;</div><div class="line">           ......</div><div class="line">           //循环层层上级调运，直到ViewRootImpl会返回null</div><div class="line">           parent = parent.invalidateChildInParent(location, dirty);</div><div class="line">           ......</div><div class="line">       &#125; while (parent != null);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这里进行了了循环，最终还是去了<code>ViewRootImpl</code>，看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123;</div><div class="line">    ......</div><div class="line">    //View调运invalidate最终层层上传到ViewRootImpl后最终触发了该方法</div><div class="line">    scheduleTraversals();</div><div class="line">    ......</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里直接返回Null，退出上面的循环，而<code>scheduleTraversals</code>这个方法，最终会调用最初我们看到的<code>performTraversals</code>方法进行重新绘制。但是肯定是不会走最初的流程，经过一些判断之后只会去重绘需要重绘的地方。还是贴张图(来自<a href="">工匠若水</a>)<br><img src="http://img.blog.csdn.net/20150531111928069" alt="">,</p>
<blockquote>
<p>常见的引起invalidate方法操作的原因主要有：<br>直接调用invalidate方法.请求重新draw，但只会绘制调用者本身。<br>触发setSelection方法。请求重新draw，但只会绘制调用者本身。<br>触发setVisibility方法。 当View可视状态在INVISIBLE转换VISIBLE时会间接调用invalidate方法，继而绘制该View。当View的可视状态在INVISIBLE\VISIBLE 转换为GONE状态时会间接调用requestLayout和invalidate方法，同时由于View树大小发生了变化，所以会请求measure过程以及draw过程，同样只绘制需要“重新绘制”的视图。<br>触发setEnabled方法。请求重新draw，但不会重新绘制任何View包括该调用者本身。<br>触发requestFocus方法。请求View树的draw过程，只绘制“需要重绘”的View。</p>
</blockquote>
<p>最后再来去解释一下最初的那个view绘制入口的问题，还是接上一篇，在<code>setContentView</code>方法里面有这个<code>mContentParent.addView(view, params);</code>而在<code>addView</code>方法里面有这么一句话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void addView(View child, int index, LayoutParams params) &#123;</div><div class="line">        ......</div><div class="line">        invalidate(true);</div><div class="line">        ......</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这下明白了吧。</p>
<p>参考：</p>
<p><a href="http://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="external"> Android应用层View绘制流程与源码分析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这次来说一说view的绘制过程，同样也算是个笔记的东西，梳理一下大致的过程，忽略了内部很多的条件判断等。上次说了&lt;code&gt;setcontentview&lt;/code&gt;和&lt;code&gt;infalter&lt;/code&gt;的一些简单过程，这个是用来把view从XML文件的格式解析和加载，但是具体view的怎么绘制到界面上的并没有提及，还有上次留下的问题，有时间学习了&lt;code&gt;activity&lt;/code&gt;的启动流程再来说一下，现在开始吧。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Binder 浅析</title>
    <link href="http://yoursite.com/2016/07/09/Android%20Binder%20%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2016/07/09/Android Binder 浅析/</id>
    <published>2016-07-09T15:33:41.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>##开头废话<br>先说一下为什么要写这篇博客吧，起源于我对主席的书进行二周目的时候，看到了第二章IPC，然后去试着手写了一遍AIDL,再然后就有点困惑这里面是啥玩意，再然后就发现这里面的坑有点大了。。从<code>AIDL</code>到<code>Binder</code>，然后看到了Android系统里面那么多的binder使用，又去翻了一点<code>activity</code>的启动，从中又看到了<code>Binder</code>在进程间通讯的影子，从<code>AMS</code>到<code>activityThread</code>的通信等等。我觉得是很有必要写一些我的认识，可能还是有些云里雾里的，就当了解吧。<a id="more"></a></p>
<p>###从AIDL开始<br>先说一下平时写AIDL都是怎么写的，用主席的那个例子</p>
<ol>
<li>定义一个可序列化的实体类<br>这个就不多说了，这里选择实现<code>Parcelable</code>接口来进行序列化，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">package com.demos.aidl;</div><div class="line">public class Book implements Parcelable &#123;</div><div class="line">    public int bookId;</div><div class="line">    public String bookName;</div><div class="line">    ....</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个类有两个字段，明白意思就好了。</p>
<p>2.定义<code>Book</code>的aidl文件<br>虽然是在同一个包里面，但是还是要去声明一个这样的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">package com.demos.aidl;</div><div class="line">parcelable Book;</div></pre></td></tr></table></figure>
<p> 3.定义AIDL接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">package com.demos.aidl;</div><div class="line">import com.demos.aidl.Book;</div><div class="line">interface IBookManager &#123;</div><div class="line">     List&lt;Book&gt; getBookList();</div><div class="line">     void addBook(in Book book);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里注意<code>import</code>Book进来，虽然是一个包里面的。</p>
<p> 4.build一下，然后在<code>build/generated/source/aidl/debug/com.demos.aidl</code>x里面就有了个<code>IBookManager</code>这么一个JAVA文件了。这就是系统帮助我们生成的。<br> 5.使用</p>
<p> 在<code>client</code>端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private ServiceConnection mConnection = new ServiceConnection() &#123;</div><div class="line">      public void onServiceConnected(ComponentName className, IBinder service) &#123;</div><div class="line">          IBookManager bookManager = IBookManager.Stub.asInterface(service);</div><div class="line">           List&lt;Book&gt; list = bookManager.getBookList();</div><div class="line">           .....</div><div class="line">          &#125;</div><div class="line">Intent intent = new Intent(this, BookManagerService.class);</div><div class="line">      bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div></pre></td></tr></table></figure></p>
<p>然后在<code>Server</code>端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private Binder mBinder = new IBookManager.Stub() &#123;</div><div class="line">        @Override</div><div class="line">        public List&lt;Book&gt; getBookList() throws RemoteException &#123;</div><div class="line">            return mBookList;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void addBook(Book book) throws RemoteException &#123;</div><div class="line">            mBookList.add(book);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这样就基本是一个很简单的进程间通信了。前面是系统给我们自动生成的一个<code>IBookManager</code>接口，这个接口里面都是些什么东西呢。进去看看的话，刚开始看不出什么东西，(因为它的排版很烂啊)，下面来排个版简单的分析一下这东西。</p>
<p>###分析aidl生成接口<br>首先它是一个接口<code>public interface IBookManager extends android.os.IInterface</code>，要去进行进程间通信，都要去遵循<code>IInterface</code>这个接口，然后里面还有一个很重要的类<code>public static abstract class Stub extends android.os.Binder implements com.demos.aidl.IBookManager</code>这个内部类继承自<code>Binder</code>还实现了我们定义的aidl接口。回过头看在客户端是怎么获得<code>IBookManager</code>的？<code>IBookManager.Stub.asInterface(service);</code>下面就是实现的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static com.demos.aidl.IBookManager asInterface(android.os.IBinder obj)</div><div class="line">&#123;</div><div class="line">    if ((obj==null)) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">    if (((iin!=null)&amp;&amp;(iin instanceof com.demos.aidl.IBookManager))) &#123;</div><div class="line">        //如果客户端和服务端在同一个进程，就直接返回服务端的IBookManager，不用跨进程调用了</div><div class="line">        return ((com.demos.aidl.IBookManager)iin);</div><div class="line">    &#125;   //否则返回的是一个代理类</div><div class="line">    return new com.demos.aidl.IBookManager.Stub.Proxy(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面去看看这个代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//这个是运行在客户端进程</div><div class="line">private static class Proxy implements com.demos.aidl.IBookManager</div><div class="line">&#123;   //远程的IBinder对象</div><div class="line">    private android.os.IBinder mRemote;</div><div class="line">    Proxy(android.os.IBinder remote)&#123;</div><div class="line">        mRemote = remote;</div><div class="line">    &#125;</div><div class="line">   .....</div><div class="line">@Override public java.util.List&lt;com.demos.aidl.Book&gt; getBookList() throws android.os.RemoteException</div><div class="line">&#123;</div><div class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">    java.util.List&lt;com.demos.aidl.Book&gt; _result;</div><div class="line">    try &#123;</div><div class="line">        _data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">        //这个是把参数等信息传递给远程的IBinder</div><div class="line">        mRemote.transact(Stub.TRANSACTION_getBookList,_data, _reply, 0);</div><div class="line">        _reply.readException();</div><div class="line">        _result = _reply.createTypedArrayList(com.demos.aidl.Book.CREATOR);</div><div class="line">    &#125;</div><div class="line">    finally &#123;</div><div class="line">    _reply.recycle();</div><div class="line">    _data.recycle();</div><div class="line">    &#125;</div><div class="line">return _result;</div><div class="line">&#125;</div><div class="line">.....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这个东西什么正事没干，就是把参数什么的传递给远程真正干活的，真正干活的在哪？还是在前面的那个<code>Stub</code>类里面，有一个<code>onTransact</code>方法，参数和上面的<code>mRemote.transact</code>方法的参数相对应，看一下吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//这个是运行在服务端进程</div><div class="line">@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException</div><div class="line">&#123;   //根据code来进行判断执行哪个方法</div><div class="line">    switch (code)&#123;</div><div class="line">        case INTERFACE_TRANSACTION:&#123;</div><div class="line">            reply.writeString(DESCRIPTOR);</div><div class="line">            return true;</div><div class="line">    &#125;</div><div class="line">        case TRANSACTION_getBookList:&#123;</div><div class="line">            data.enforceInterface(DESCRIPTOR);</div><div class="line">            //调用了getBookList方法，这个方法是要自己在service里面去实现的</div><div class="line">            java.util.List&lt;com.demos.aidl.Book&gt; _result =               this.getBookList();</div><div class="line">            reply.writeNoException();</div><div class="line">            reply.writeTypedList(_result);</div><div class="line">            return true;</div><div class="line">    &#125;</div><div class="line">    ....</div><div class="line">    return super.onTransact(code, data, reply, flags);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样基本上就大概理清楚了，手写<code>AIDL</code>就不写了，写出来基本上是一样的。</p>
<p>##概述多进程<br>在Android中，打开一个APP可以认为是开启了一个进程，当然四大组件也可以再开新的进程，不同的进程之间是不同的虚拟机，所以可以认识他们互相不知道对方的存在，也就没法去直接的交流。那么如果想要跨进程通信，其实有很多的办法，比如管道，System V，Socket等，那么Android为什么还要去自己搞一个binder呢，既然自己费那么大劲搞了一个，肯定有无可比拟的优势，这里我只知道由于性能和安全的考虑，它就选择了binder😂。</p>
<p>###binder基本模型<br>既然两个进程之间无法直接通信，那么怎么办。在Linux中，内核是可以获取两个进程的全部信息的，那么就好办了，把进程a想说的话告诉内核，内核再告诉b就好了。。。其实实现起来还是很复杂的。好吧，正经点说，首先系统有一个<code>ServiceManager</code>的进程，简称SM,这个是负责管理<code>Service</code>的，当一个<code>Server</code>建立的时候，会去和SM通信，在SM里面进行注册，比如我是张三，我的地址是0x12138。当<code>Client</code>想要和<code>Server</code>进行通信的时候，先去询问SM,我怎么联系张三，SM告诉它这个号码，然后就去联系了。其实还是有点不恰当，，大概就这么理解吧。这里注意到，SM其实也是一个进程，一个<code>Server</code>想要和它进行通信就涉及到了跨进程通信的问题，这就成了鸡-蛋的问题，其实这两者之间也是使用了<code>Binder</code>,不过系统给我们预先造了一个”鸡”,和普通的跨进程通信还不太一样，这里理解就好。</p>
<p>###Binder跨进程原理<br>这里还是简单的说，因为我也不是特别的理解。就拿上面举的那个book的例子开始说，可以看到<code>Stub</code>是继承自<code>Binder</code>并且实现了<code>IBookManager</code>接口，而<code>Binder</code>是实现了<code>IBinder</code>接口，其实在<code>Binder</code>里面有一个内部类<code>BinderProxy</code>，它也是实现了<code>IBinder</code>接口。这样在来看在<code>Client</code>里面的使用，<code>public void onServiceConnected(ComponentName className, IBinder service)</code>这里的<code>service</code>是<code>sub</code>呢还是<code>BinderProxy</code>呢，在前面说了，如果是在同一个进程，就返回<code>Server</code>里面的<code>Binder</code>本体，否在就返回一个<code>BinderProxy</code>对象，在<code>asInterface(android.os.IBinder obj)</code>这个<code>obj</code>如果是跨进程的，肯定是一个<code>BinderProxy</code>对象了，然后就去调用这个对象的<code>transact</code>方法，把需要调用方法的code，数据，返回值，还有一个是不是双向RPC的flag位传进去，我们看一下在<code>BinderProxy</code>里面，这个方法是怎么实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</div><div class="line">       Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</div><div class="line">       return transactNative(code, data, reply, flags);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看到是调用了<code>Native</code>的方法，后面就是一些cpp的东西，我也看不太懂，也就是进去了<code>Binder</code>驱动里面去折腾东西，然后<code>Binder</code>驱动把那些参数什么的给<code>Server</code>的<code>onTransact</code>方法，然后在根据code去调用<code>Server</code>中重写的<code>IBookManager</code>中的方法。然后在<code>onTransact</code>方法中最后再把写好的返回参数在返回给<code>Binder</code>驱动，可以在最后看到<code>return super.onTransact(code, data, reply, flags);</code>，再然后就是<code>Binder</code>驱动把结果告诉等待的<code>Client</code>端。这样就基本完成了一次跨进程通信。</p>
<p>这里稍微总结一下，可以看到，无论是<code>sub</code>还是<code>BinderProxy</code>都是实现了<code>IBinder</code>接口，以至于客户端根本无法分辨出是不是在进行跨进程通信，也就是说<code>Client</code>看起来就和同进程的<code>Server</code>进行通信一样，只需要轻轻松松的调用<code>getBookList</code>就能获得想要的结果，也不用去在乎<code>Server</code>是在什么地方，底层了一切<code>Binder</code>驱动都给我们封装好了。还有就是在跨进程通信的时候，并没有把方法传过去，仅仅是传递了一个方法的code,然后在<code>Server</code>中根据这个code来调用对应的方法.</p>
<p>###在Android中的提现<br>在Android的源码中，使用<code>Binder</code>来进行进程间通讯也是很常见的，来看一个关于启动<code>activity</code>的东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class ActivityManagerProxy implements IActivityManager&#123;&#125;</div><div class="line"></div><div class="line">public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123;&#125;</div><div class="line"></div><div class="line">public final class ActivityManagerService extends ActivityManagerNative&#123;&#125;</div></pre></td></tr></table></figure>
<p>这个三个类的继承实现关系是不是有点眼熟，对，就和前面写的那个book例子一样的，<code>ActivityManagerProxy</code>就相当于那个内部类<code>Proxy</code>，<code>ActivityManagerNative</code>就相当于里面的<code>Stub</code>，而实现类<code>ActivityManagerService</code>简称AMS就是<code>Server</code>了。在细说一下，在执行<code>startActivity</code>的时候，会到<code>mInstrumentation.execStartActivity()</code>，就是凯子哥说的那个老板娘😂，然后就是<code>ActivityManagerNative.getDefault().startActivity</code>，这里<code>getDefault</code>返回一个<code>IActivityManager</code>对象，就是使用<code>asInterface(IBinder obj)</code>获得的，是不是更熟悉了，就是前面判断是不是同一个进程的地方，这里肯定是跨进程了，返回的是一个<code>ActivityManagerProxy</code>对象，然后在<code>ActivityManagerProxy</code>里面有<code>startActivity</code>方法，里面有这么一句<code>mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);</code>又熟悉了吧。好吧，就说到这里了。</p>
<p>##结尾<br>以上只是我自己了解的浅见，肯定有不合理的地方，也只是我自己的理解，以后还会继续学习这方面的东西，毕竟现在也只是一知半解的。</p>
<p>参考：</p>
<p><a href="http://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="external">《Binder学习指南》</a></p>
<p><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287" target="_blank" rel="external">【凯子哥带你学Framework】Activity启动过程全解析</a></p>
<p><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Bander设计与实现 - 设计篇</a>  没看太明白😂</p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external"> Android进程间通信（IPC）机制Binder简要介绍和学习计划</a>  老罗的也是经典</p>
<p><a href="https://github.com/70kg/Demos/tree/master/app/src/main/java/com/demos/aidl" target="_blank" rel="external">还有我的手写AIDL😂</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##开头废话&lt;br&gt;先说一下为什么要写这篇博客吧，起源于我对主席的书进行二周目的时候，看到了第二章IPC，然后去试着手写了一遍AIDL,再然后就有点困惑这里面是啥玩意，再然后就发现这里面的坑有点大了。。从&lt;code&gt;AIDL&lt;/code&gt;到&lt;code&gt;Binder&lt;/code&gt;，然后看到了Android系统里面那么多的binder使用，又去翻了一点&lt;code&gt;activity&lt;/code&gt;的启动，从中又看到了&lt;code&gt;Binder&lt;/code&gt;在进程间通讯的影子，从&lt;code&gt;AMS&lt;/code&gt;到&lt;code&gt;activityThread&lt;/code&gt;的通信等等。我觉得是很有必要写一些我的认识，可能还是有些云里雾里的，就当了解吧。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Volley源码解析</title>
    <link href="http://yoursite.com/2016/07/09/Volley%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/07/09/Volley源码解析/</id>
    <published>2016-07-09T15:26:17.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这篇博客想写挺久的了，因为之前接触到网络请求的第一个流行的库就是<code>Volley</code>，在使用的时候也感觉到它的功能和拓展性的强大，但是一直没有去探究他内部的流程，同时可以发现网上对<code>Volley</code>这个框架设计的评价都非常好，所以去了解内部的实现还是很有必要的。下面开始吧。<a id="more"></a></p>
<p>&emsp;&emsp;先从最开始怎么去使用说起，最常见的使用方式就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">RequestQueue queue = Volley.newRequestQueue(this);</div><div class="line"></div><div class="line">        StringRequest request = new StringRequest(&quot;http://70kg.info&quot;, new Response.Listener&lt;String&gt;() &#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onResponse(String response) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;, new Response.ErrorListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onErrorResponse(VolleyError error) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        queue.add(request);</div></pre></td></tr></table></figure>
<p>先去创建一个<code>RequestQueue</code>，然后在去创建一个<code>request</code>，最后加入到队列里面就可以了。使用也是相当的方便清晰。那就从<code>RequestQueue</code>入手，看看这个队列是什么样的。</p>
<p>###RequestQueue<br>这个类是在<code>toolbox</code>包里面，都是一下已经给我们实现一些功能的类，方便我们去使用。<code>Volley.newRequestQueue(this);</code>最终走到了这里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public static RequestQueue newRequestQueue(Context context, HttpStack stack) &#123;</div><div class="line">        //缓存目录</div><div class="line">        File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);</div><div class="line">        String userAgent = &quot;volley/0&quot;;</div><div class="line">        try &#123;</div><div class="line">            String packageName = context.getPackageName();</div><div class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);</div><div class="line">            userAgent = packageName + &quot;/&quot; + info.versionCode;</div><div class="line">        &#125; catch (NameNotFoundException e) &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (stack == null) &#123;</div><div class="line">            if (Build.VERSION.SDK_INT &gt;= 9) &#123;</div><div class="line">                stack = new HurlStack();</div><div class="line">            &#125; else &#123;</div><div class="line">                stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Network network = new BasicNetwork(stack);</div><div class="line"></div><div class="line">        RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);</div><div class="line">        queue.start();</div><div class="line"></div><div class="line">        return queue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里可以看到还有个<code>userAgent</code>，在使用使用<code>HttpClientStack</code>也就是API<9,使用`androidhttpclient`的时候使用，具体是什么会在下面的参考中给出，和本文关系不是很大，只要明白在>=9的时候使用了<code>HurlStack</code>，内部是<code>HttpURLConnection</code>就差不多了。下面还有个<code>Network</code>，是根据传进去的<code>stack</code>来选择不同的处理网络方式，后面会说。最重要的就是下面两行，真正的<code>new RequestQueue</code>，然后<code>star</code>,进去看看：</9,使用`androidhttpclient`的时候使用，具体是什么会在下面的参考中给出，和本文关系不是很大，只要明白在></p>
<p>经过各种重载构造函数，走到了这个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public RequestQueue(Cache cache, Network network, int threadPoolSize,</div><div class="line">           ResponseDelivery delivery) &#123;</div><div class="line">       //默认缓存</div><div class="line">       mCache = cache;</div><div class="line">       //处理网络的</div><div class="line">       mNetwork = network;</div><div class="line">       //一个NetworkDispatcher数组，默认大小4</div><div class="line">       mDispatchers = new NetworkDispatcher[threadPoolSize];</div><div class="line">       //一个ExecutorDelivery对象</div><div class="line">       mDelivery = delivery;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>然后就是去看<code>star</code>方法了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void start() &#123;</div><div class="line">        stop();  </div><div class="line">        //一个缓存调度线程</div><div class="line">        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</div><div class="line">        mCacheDispatcher.start();</div><div class="line">        //默认4个网络调度线程</div><div class="line">        for (int i = 0; i &lt; mDispatchers.length; i++) &#123;</div><div class="line">            NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork,</div><div class="line">                    mCache, mDelivery);</div><div class="line">            mDispatchers[i] = networkDispatcher;</div><div class="line">            networkDispatcher.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>所以当我们新建了一个<code>RequestQueue</code>之后，其实是启动了5个线程在跑。接下来就是<code>queue.add(request);</code>的时候了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public Request add(Request request) &#123;</div><div class="line">        //相当于设个tag为当前的queue</div><div class="line">        request.setRequestQueue(this);</div><div class="line">        synchronized (mCurrentRequests) &#123;</div><div class="line">        //private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;Request&lt;?&gt;&gt;();正在进行，尚未完成请求的集合</div><div class="line">            mCurrentRequests.add(request);</div><div class="line">        &#125;</div><div class="line">       //序列号 可以理解为加入的顺序</div><div class="line">        request.setSequence(getSequenceNumber());</div><div class="line">        //添加个标记</div><div class="line">        request.addMarker(&quot;add-to-queue&quot;);</div><div class="line"></div><div class="line">        //不缓存，就直接加入网络队列去请求网络</div><div class="line">        if (!request.shouldCache()) &#123;</div><div class="line">            mNetworkQueue.add(request);</div><div class="line">            return request;</div><div class="line">        &#125;</div><div class="line">        synchronized (mWaitingRequests) &#123;</div><div class="line">            String cacheKey = request.getCacheKey();</div><div class="line">            //维护了一个等待请求的集合，如果一个请求正在被处理并且可以被缓存，后续的相同 url 的请求，将进入此等待队列。</div><div class="line">            if (mWaitingRequests.containsKey(cacheKey)) &#123;</div><div class="line">            //前面有相同的了 等待</div><div class="line">                Queue&lt;Request&gt; stagedRequests = mWaitingRequests.get(cacheKey);</div><div class="line">                if (stagedRequests == null) &#123;</div><div class="line">                    stagedRequests = new LinkedList&lt;Request&gt;();</div><div class="line">                &#125;</div><div class="line">                stagedRequests.add(request);</div><div class="line">                mWaitingRequests.put(cacheKey, stagedRequests);</div><div class="line">            &#125; else &#123;</div><div class="line">                //否则加入缓存队列</div><div class="line">                mWaitingRequests.put(cacheKey, null);</div><div class="line">                mCacheQueue.add(request);</div><div class="line">            &#125;</div><div class="line">            return request;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>###CacheDispatcher<br>Volley默认都是可以缓存的，而处理缓存的是<code>CacheDispatcher</code>，这是一个线程，那就可以去<code>Run</code>方法看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public void run() &#123;</div><div class="line">        //线程优先级</div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        //初始化缓存</div><div class="line">        mCache.initialize();</div><div class="line">         //开启无限循环</div><div class="line">        while (true) &#123;</div><div class="line">            try &#123;</div><div class="line">                //从缓存队列中获取第一个</div><div class="line">                final Request request = mCacheQueue.take();</div><div class="line">                request.addMarker(&quot;cache-queue-take&quot;);</div><div class="line">               //取消了  不去处理</div><div class="line">                if (request.isCanceled()) &#123;</div><div class="line">             request.finish(&quot;cache-discard-canceled&quot;);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">               //从缓存中检所</div><div class="line">                Cache.Entry entry = mCache.get(request.getCacheKey());</div><div class="line">                if (entry == null) &#123;</div><div class="line">                    request.addMarker(&quot;cache-miss&quot;);</div><div class="line">                    //没找到  加入网络队列去请求</div><div class="line">                    mNetworkQueue.put(request);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                //缓存过期了 也是网络请求</div><div class="line">                if (entry.isExpired()) &#123;</div><div class="line">                    request.addMarker(&quot;cache-hit-expired&quot;);</div><div class="line">                    request.setCacheEntry(entry);</div><div class="line">                    mNetworkQueue.put(request);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                //获取到正常可用的缓存的request</div><div class="line">                request.addMarker(&quot;cache-hit&quot;);</div><div class="line">                //转换成一个NetworkResponse</div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(</div><div class="line">                        new NetworkResponse(entry.data, entry.responseHeaders));</div><div class="line">                request.addMarker(&quot;cache-hit-parsed&quot;);</div><div class="line">                if (!entry.refreshNeeded()) &#123;</div><div class="line">                    //mDelivery使用handler分发到主线程</div><div class="line">                    mDelivery.postResponse(request, response);</div><div class="line">                &#125; else &#123;</div><div class="line">                    //检验新鲜度 request.addMarker(&quot;cache-hit-refresh-needed&quot;);</div><div class="line">                    request.setCacheEntry(entry);</div><div class="line">                    response.intermediate = true;</div><div class="line">                   //分发  再去加入网络队列检验新鲜度</div><div class="line">                    mDelivery.postResponse(request, response, new Runnable() &#123;</div><div class="line">                        @Override</div><div class="line">                        public void run() &#123;</div><div class="line">                            try &#123;</div><div class="line">                                mNetworkQueue.put(request);</div><div class="line">                            &#125; catch (InterruptedException e) &#123;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">        </div><div class="line">                if (mQuit) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>整个过程差不多都注释了，再来个大招，非常棒的流程图：</p>
<p><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/CacheDispatcher-run-flow-chart.png" alt=""></p>
<p>###CacheDispatcher<br>说完缓存分发，还有网络分发，还是看run方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public void run() &#123;</div><div class="line">       //线程优先级</div><div class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        Request request;</div><div class="line">        //循环取</div><div class="line">        while (true) &#123;</div><div class="line">            try &#123;</div><div class="line">              //取一个</div><div class="line">                request = mQueue.take();</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                if (mQuit) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            try &#123;</div><div class="line">                request.addMarker(&quot;network-queue-take&quot;);</div><div class="line">                if (request.isCanceled()) &#123;                  request.finish(&quot;network-discard-cancelled&quot;);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Tag the request (if API &gt;= 14)</div><div class="line">                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</div><div class="line">                    TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // 执行网络请求</div><div class="line">                NetworkResponse networkResponse = mNetwork.performRequest(request);</div><div class="line">                request.addMarker(&quot;network-http-complete&quot;);</div><div class="line"></div><div class="line">                //返回304并且已经处理过这个，跳过</div><div class="line">                if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</div><div class="line">                    request.finish(&quot;not-modified&quot;);</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">               //解析成Response</div><div class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</div><div class="line">                request.addMarker(&quot;network-parse-complete&quot;);</div><div class="line">                //请求到之后缓存</div><div class="line">                if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123;</div><div class="line">                    mCache.put(request.getCacheKey(), response.cacheEntry);</div><div class="line">               request.addMarker(&quot;network-cache-written&quot;);</div><div class="line">                &#125;</div><div class="line">                request.markDelivered();</div><div class="line">                //分发到主线程</div><div class="line">                mDelivery.postResponse(request, response);</div><div class="line">            &#125; catch (VolleyError volleyError) &#123;</div><div class="line">                parseAndDeliverNetworkError(request, volleyError);</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString());</div><div class="line">                mDelivery.postError(request, new VolleyError(e));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>整个流程和缓存差不多，再来一个图：<br><img src="https://raw.githubusercontent.com/android-cn/android-open-project-analysis/master/tool-lib/network/volley/image/NetworkDispatcher-run-flow-chart.png" alt=""></p>
<p>###Network<br>在上面的网络分发中看到了主要就是<code>mNetwork.performRequest(request);</code>这句话执行了真正的网络请求操作，而<code>Network</code>是一个接口，实现类是在创建<code>RequestQueue</code>时候创建的<code>BasicNetwork</code>，看看这个里面的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class BasicNetwork implements Network &#123;</div><div class="line">       //...省略看不懂的网络操作</div><div class="line">         @Override</div><div class="line">    public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123;</div><div class="line">     //...</div><div class="line">     //这就是前面根据版本不同选择不同的网络处理方式</div><div class="line">     httpResponse = mHttpStack.performRequest(request, headers);</div><div class="line">    </div><div class="line">    //....</div><div class="line">    //组装返回值</div><div class="line">     networkResponse = new NetworkResponse(statusCode, responseContents,responseHeaders, false);</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">       </div><div class="line">       //省略</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到现在请求的结果也回来了，那么具体是怎么去分发<code>Response</code>的呢？主要是这句话<code>mDelivery.postResponse(request, response);</code><br>而<code>ResponseDelivery</code>是一个接口，实现类是创建<code>RequestQueue</code>的时候创建的<code>public class ExecutorDelivery implements ResponseDelivery</code>，看一下它的<code>postResponse</code>方法，主要就是<code>mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, null));</code>可以理解为向主线程发送了一个<code>Runnable</code>而在这个<code>Runnable</code>里面呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (mResponse.isSuccess()) &#123;</div><div class="line">              mRequest.deliverResponse(mResponse.result);</div><div class="line">          &#125; else &#123;</div><div class="line">              mRequest.deliverError(mResponse.error);</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>第一个方法是不是就比较熟悉了，就是自定义<code>Request</code>的时候要重写的两个方法之一，一般就直接<code>mListener.onResponse(response);</code>就可以了，而错误的分发<code>Request</code>基类已经实现完了。<br>到这，基本的过程差不多了，还有重试策略和缓存的具体没写，大概就这样吧。</p>
<p>参考：</p>
<p><a href="http://www.cnblogs.com/tianzhijiexian/p/4264468.html" target="_blank" rel="external">详细解读Volley（五）—— 通过源码来分析业务流程</a></p>
<p><a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">Volley 源码解析</a></p>
<p><a href="http://bxbxbai.github.io/2014/12/24/read-volley-source-code/" target="_blank" rel="external">Volley源码分析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这篇博客想写挺久的了，因为之前接触到网络请求的第一个流行的库就是&lt;code&gt;Volley&lt;/code&gt;，在使用的时候也感觉到它的功能和拓展性的强大，但是一直没有去探究他内部的流程，同时可以发现网上对&lt;code&gt;Volley&lt;/code&gt;这个框架设计的评价都非常好，所以去了解内部的实现还是很有必要的。下面开始吧。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
</feed>
