<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>70kg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-28T14:51:44.721Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>70kg</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring文档笔记</title>
    <link href="http://yoursite.com/2019/05/29/Spring%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/05/29/Spring文档笔记/</id>
    <published>2019-05-29T15:10:10.000Z</published>
    <updated>2019-05-28T14:51:44.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ioc容器"><a href="#Ioc容器" class="headerlink" title="Ioc容器"></a>Ioc容器</h2><ul>
<li><code>ApplicationContext</code>是<code>BeanFactory</code>的子接口，更好的与<code>spring</code>的<code>aop</code>集成，消息资源处理（用于国际化），事件发布，特定的<code>context</code>,like WebApplicationContext for use in web applications.</li>
<li><code>GenericApplicationContext</code>可以用来加载多种方式的配置，然后调用<code>refresh</code><a id="more"></a></li>
<li>在<code>Ioc</code>容器中，<code>bean</code>的定义被表示为<code>BeanDefinition</code>，包括但不限于<br>1，包限定类名，一般是实现类。<br>2，<code>bean</code>的行为配置，例如生命周期，作用域，回调等<br>3，所需要的其他<code>bean</code>的引用<br>4，创建<code>bean</code>的其他配置，例如对象池大小，连接等</li>
<li>可以使用<code>getBeanFactory::registerSingleton</code>动态注册<code>bean</code>，甚至可以覆盖已有的<code>bean</code>以及配置，但是很不推荐。</li>
<li><code>id</code>和<code>name</code>都要去在容器中唯一，不同的是前者只能设置一个，后者可以多个；</li>
<li>初始化<code>bean</code>有默认的构造方法，静态工厂，和工厂方法三种</li>
<li>依赖注入分为构造函数注入和set注入</li>
<li>构造函数注入时候，如果要使用<code>name</code>，要么使用debug,不然要在构造函数上加上<code>@ConstructorProperties</code>注解，因为java形参编译后不会保留；</li>
<li>推荐使用构造方法注入，1，有助于保持<code>immutable</code>;2，防止依赖项为<code>null</code>;3 会返回完整初始化的对象。</li>
<li>set注入应该仅用于类中可选在依赖注入，还有方便重新注入。</li>
<li><code>ApplicationContext</code>会预先实例化单例的<code>bean</code>而不是到使用的时候，为了让错误的配置信息尽早出现。可以配置这种行为。</li>
<li>推荐使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;property name=&quot;targetName&quot;&gt;</div><div class="line">    &lt;idref bean=&quot;theTargetBean&quot;/&gt;</div><div class="line">&lt;/property&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>而不是<code>&lt;property name=&quot;targetName&quot; value=&quot;theTargetBean&quot;/&gt;</code>，第一种会去校验<code>bean</code>是否存在，防止第二张名字写错了，运行时候才出现。</p>
<ul>
<li>使用<code>&lt;ref parent=&quot;accountService&quot;/&gt;</code>引用父容器中的<code>bean</code></li>
<li>使用<code>&lt;props merge=&quot;true&quot;&gt;</code>可以合并父，子<code>bean</code>的属性内容；</li>
<li>使用<code>depends-on</code>配置<code>bean</code>的依赖项；</li>
<li>使用<code>lazy-init</code>延迟初始化，<code>&lt;beans default-lazy-init=&quot;true&quot;&gt;</code>容器层级延迟初始化；</li>
<li>可以通过各种方式关闭自动注入。</li>
<li><code>&lt;bean autowire-candidate=&quot;false&quot;&gt;</code>禁止自动注入，或者<code>&lt;beans default-autowire-candidates=&quot;*xxxx&quot;</code>模式匹配禁止注入，但是不会阻止这些<code>bean</code>的自动装配时候的自动注入其他<code>bean</code>;</li>
<li>实现<code>ApplicationContextAware</code>获取<code>ApplicationContext</code>对象，进而做一些<code>getBean</code>之类的操作；</li>
<li><code>&lt;lookup-method</code>可以解决单例<code>bean</code>中含有非单例<code>bean</code>无法更新问题。还可以使用<code>ServiceLocatorFactoryBean</code>这个类来实现类似的功能，</li>
<li><code>&lt;replaced-method</code>实现任意方法的替换，本质还是<code>aop</code>。</li>
<li><code>singleton</code>用在无状态的<code>bean</code>，<code>prototype</code>用在有状态的<code>bean</code>;</li>
<li><code>prototype</code>的<code>bean</code>的<code>destruction</code>生命周期方法不会被调用。</li>
<li><code>&lt;aop:scoped-proxy</code>用在短生命周期<code>bean</code>注入长生命周期<code>bean</code>时候，可以获得短生命周期<code>bean</code>的更新。<a href="https://juejin.im/entry/5b440f026fb9a04fb614cea8" target="_blank" rel="external">Spring中的多例往单例里注入的方法</a></li>
<li><code>InitializingBean</code>和<code>DisposableBean</code>接口提供<code>bean</code>生命周期的回调，但是不推荐直接使用，可以使用<code>@PostConstruct</code>或者在<code>xml</code>中<code>&lt;init-methond&gt;</code>或者统一的<code>&lt;default-init-method&gt;</code>和<code>@PreDestroy</code>或在<code>xml</code>中<code>&lt;destroy-method&gt;</code>或者统一的<code>&lt;defaule-destory-method&gt;</code></li>
<li>有些实现了<code>AutoCloseable</code>或者<code>Closeable</code>等接口的<code>bean</code>，自动调用其方法。</li>
<li><code>SmartLifecycle</code>可以监听整个容器的生命周期；<a href="https://blog.csdn.net/catoop/article/details/71274561" target="_blank" rel="external">Spring SmartLifecycle 在容器所有bean加载和初始化完毕执行</a></li>
<li>直接在idea中点击停止是无法回调销毁方法；<a href="http://cxytiandi.com/blog/detail/15386" target="_blank" rel="external">研究优雅停机时的一点思考 </a></li>
<li>使用<code>&lt;parent</code>作为<code>bean</code>的模板，减少重复代码，类似继承，<code>parent</code>的<code>bean</code>一定要注明<code>abstract</code>，否则<code>spring</code>预初始化单例<code>bean</code>时候会有问题。<code>parent</code>的<code>bean</code>可以表明<code>class</code>也可以不表明；</li>
<li><code>BeanFactoryPostProcessor</code>是自定义配置<code>Bean</code>的元数据，<code>BeanPostProcessor</code>是自定义配置<code>bean</code>的。例如一个<code>BeanFactoryPostProcessor</code>的实现<code>PropertyPlaceholderConfigurer</code>就是把<code>xml</code>中定义的<code>${}</code>替换成在<code>.properties</code>中定义的真实属性。</li>
<li>使用<code>FactoryBean</code>可以自定义<code>bean</code>的创建。使用<code>getBean(&quot;&amp;xx&quot;)</code>可以获得<code>FactoryBean</code>自身实例，否则默认是返回<code>FactoryBean</code>创建的<code>bean</code>；是一种更加灵活创建<code>bean</code>的方式。</li>
<li><code>&lt;context:annotation-config/&gt;</code>是隐式的注入了一些<code>BeanPostProcessor</code>，类似<code>AutowiredAnnotationBeanPostProcessor</code></li>
<li><code>Autowired</code>这类注入注解是由<code>BeanPostProcessor</code>实现，因为无法在自定义的<code>BeanPostProcessor</code>中使用，可以使用<code>XML</code>的方式。</li>
<li><code>@Autowired</code>是按照类型注入，是<code>spring</code>的注解。<code>@Resource</code>是按照name注入，找不到再按照类型注入，是<code>jdk</code>提供的。</li>
<li><code>@Primary</code>和<code>@Qualifier(&quot;main&quot;)</code>来指定需要注入的<code>bean</code>。</li>
<li>还可以使用<code>@Qualifier</code>自定义注入注解；</li>
<li>加了<code>&lt;context:component-scan&gt;</code>就不用再加<code>&lt;context:annotation-config&gt;</code>，前者已经隐式开启了。</li>
<li>使用<code>includeFilters</code>和<code>excludeFilters</code>去控制<code>ComponentScan</code>扫码范围和条件；</li>
<li>可以使用<code>InjectionPoint</code>或者<code>DependencyDescriptor</code>来获取注入点的信息，一般用在<code>@Scope(&quot;prototype&quot;)</code>；</li>
<li>使用<code>BeanNameGenerator</code>接口自定义<code>bean</code>名称的生成规则</li>
<li><code>@bean</code>在<code>@Configuration</code>和<code>@Component</code>是有些不一样的，简单说带有<code>@Configuration</code>的是被<code>spring</code>代理增强的类，里面带有<code>@bean</code>调用其他带有<code>@bean</code>的方法，会返回和容器中同样的实例。<a href="https://blog.csdn.net/isea533/article/details/78072133" target="_blank" rel="external">Spring @Configuration 和 @Component 区别</a><ul>
<li>使用<code>ImportResource</code>将<code>xml</code>配置的<code>bean</code>到<code>@Configuration</code>中使用。</li>
<li>使用<code>@Profile</code>区分不同的环境，使用不同的配置，bean 或者方法。</li>
<li>使用<code>spring.profiles.active</code>指定使用的环境</li>
<li>使用<code>spring.profiles.default</code>指定缺省的环境；</li>
<li><code>System.getProperties()</code>获取系统 jvm 配置</li>
<li><code>System.getenv()</code>获取当前系统配置</li>
<li><code>@PropertySource</code>指定配置文件</li>
<li>在配置类上使用<code>@EnableLoadTimeWeaving</code>开启动态转换类？</li>
</ul>
</li>
</ul>
<hr>
<p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction" target="_blank" rel="external">https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-introduction</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Ioc容器&quot;&gt;&lt;a href=&quot;#Ioc容器&quot; class=&quot;headerlink&quot; title=&quot;Ioc容器&quot;&gt;&lt;/a&gt;Ioc容器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;是&lt;code&gt;BeanFactory&lt;/code&gt;的子接口，更好的与&lt;code&gt;spring&lt;/code&gt;的&lt;code&gt;aop&lt;/code&gt;集成，消息资源处理（用于国际化），事件发布，特定的&lt;code&gt;context&lt;/code&gt;,like WebApplicationContext for use in web applications.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GenericApplicationContext&lt;/code&gt;可以用来加载多种方式的配置，然后调用&lt;code&gt;refresh&lt;/code&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mysql原理简介</title>
    <link href="http://yoursite.com/2019/05/28/Mysql%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/05/28/Mysql原理简介/</id>
    <published>2019-05-28T15:00:10.000Z</published>
    <updated>2019-05-30T13:40:55.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h2><p><code>InnoDB</code>有四种行格式，或者是记录格式，分别是<code>Compact</code>，<code>Redundant</code>，<code>Dynamic</code>，<code>Compressed</code>，1，3，4是比较相似的，区别在于页溢出的处理方式。<a id="more"></a></p>
<p><img src="http://static.zybuluo.com/70kg/xrg1uza3x3z76ntlbub9wdai/169710e8fafc21aa.webp" alt="169710e8fafc21aa.webp-8.9kB"></p>
<table>
<thead>
<tr>
<th>c1(VARCHAR(10)</th>
<th style="text-align:right">c2(VARCHAR(10) NOT NULL)</th>
<th style="text-align:center">c3(CHAR(10))</th>
<th>c4(VARCHAR(10)) </th>
</tr>
</thead>
<tbody>
<tr>
<td>aaaa</td>
<td style="text-align:right">bbb</td>
<td style="text-align:center">cc</td>
<td>d</td>
</tr>
<tr>
<td>eeee</td>
<td style="text-align:right">fff</td>
<td style="text-align:center">NULL</td>
<td>NULL</td>
</tr>
</tbody>
</table>
<h4 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h4><p>在变长字段长度列表里面逆序存储 变长列的真实数据的字节长度。类似<code>VARCHAR(M)</code>这样的变长字段。<br>举例：</p>
<p>现在列中的内容长度比较短，长度可以使用一个字节来表示，如果长度很长，可以使用两个字节来表示。具体使用一个还是两个，you有具体的算法。<br>变长字段长度列表中不存储null 的列。</p>
<h4 id="Null-值列表"><a href="#Null-值列表" class="headerlink" title="Null 值列表"></a>Null 值列表</h4><p>如果表中没有允许存储 Null 的列，那么 Null 值列表也不存在。使用二进制按照列的顺序逆序排列，1:表示该列的值为 Null，0表示该列的值不为Null。同时必须是整数个字节的位，否则高位补0。<br>以第二条记录为例，011，逆序就是110，高位补5个0，十进制为6。</p>
<h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><p>包括改记录是否被删除，当前记录的类型，下一条记录的相对位置等等。</p>
<h4 id="真是数据"><a href="#真是数据" class="headerlink" title="真是数据"></a>真是数据</h4><p>会添加隐藏列，如果没有合适的作为主键的列，会添加 row_id,(先寻找自定义的主键，没有的话寻找非 null, nuique的键),transaction_id,roll_pointer 的三个隐藏列。<br><img src="http://static.zybuluo.com/70kg/k0esi8igherzbt9z9d31yx8k/169710e973b70372.webp" alt="169710e973b70372.webp-19kB"></p>
<p>如果使用的变长字符集，c3列也会加入到变长字段长度列表中。</p>
<h4 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h4><p>MySQL 对一条记录占用的最大存储空间是有限制的，除了<code>blob</code>或者<code>text</code>类型的列之外，其他的列占用的字节长度之和不能超过65535个字节。<br><img src="http://static.zybuluo.com/70kg/efi6s7lv06co8579eg45qww2/169710e9aab47ea5.webp" alt="169710e9aab47ea5.webp-25.9kB"></p>
<h2 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h2><p>页是 innodb 管理存储的基本单位，一个页的大小一般是16kb。为了不同的目的，设计了很多种不同的页。存放记录的页就 index 页，暂时称为数据页。</p>
<p><img src="http://static.zybuluo.com/70kg/tueek8acq1cn3w6i77kbpofy/16a95c0ff3068b29.webp" alt="16a95c0ff3068b29.webp-13.6kB"></p>
<h4 id="行记录"><a href="#行记录" class="headerlink" title="行记录"></a>行记录</h4><p>插入行记录时先去<code>free space</code>申请空间。每一行记录的记录头信息中包含<code>heap_no</code>：在页中的位置，在<code>infimum+supremum</code>中存储这自动生成的两个隐藏行，最小最大行，分别是0和1。<code>next_record</code>：下一条记录的真实数据的地址偏移量，可以简单的理解成链表。</p>
<h4 id="页目录"><a href="#页目录" class="headerlink" title="页目录"></a>页目录</h4><p>是为了更快的查找页中的记录，将页中的记录分组，在分组的最后一条记录的头信息中记录当前组的记录条数。最小组只能有1条记录，最大组在1-8条，剩下的在4-8条。<br><img src="http://static.zybuluo.com/70kg/5yeubd0eqerziynil5b90dtw/16a95c10f2e61ad5.webp" alt="16a95c10f2e61ad5.webp-18.9kB"><br>查找的时候使用二分查找查找槽，对比查找到的槽对应的记录的主键大小，决定查找的方向。因为页中的记录是单链表，所以找到槽之后，找上一个的槽，然后找这个槽对应的记录向下找。</p>
<h4 id="Page-Header页面头部"><a href="#Page-Header页面头部" class="headerlink" title="Page Header页面头部"></a><code>Page Header</code>页面头部</h4><p>数据页专属，记录存储了多少记录，多少槽，第一条记录的地址等。</p>
<h4 id="File-Header文件头部"><a href="#File-Header文件头部" class="headerlink" title="File Header文件头部"></a><code>File Header</code>文件头部</h4><p>页通用的部分，包括页校验和，页号(使用这个定位页),前一个页和后一个页的(页号)”指针”，页类型</p>
<h4 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a><code>File Trailer</code></h4><p>存储的时候校验页的完整性，和 header中的校验和进行对比</p>
<h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><p>非叶子节点使用的是和存放记录的页一样的数据页，但是其中的记录只有两列，对应子节点的最小主键和对应的子节点的页号。还有就是头信息中的<code>record_type</code>=1,正常的是0。</p>
<p><img src="http://static.zybuluo.com/70kg/aeqkmcr4pti5agc5y268aue4/16a01bd2a6c7a65f.webp" alt="16a01bd2a6c7a65f.webp-30.1kB"></p>
<p>查找的过程，先从根页面开始，在页面的槽中进行二分查找，找对对应的下一级页号，在循环执行上面的操作，找到叶子节点，在叶子节点中寻找真实的记录。页中的记录是按照主键大小从小到大。页与页之间形成了双向链表。这叫聚簇索引。</p>
<h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>非叶子节点也是类似聚餐索引，按照列的顺序，不过叶子节点中的记录只有对应列的值和主键，然后在进行回表，进行聚簇索引的查找。为了保证b+树的同一层内节点的目录项记录除了页号以外的唯一性，会加入主键作为一列。也就是会有三列，索引列，主键，页号。</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>规则也是类似上面，不过页中的记录存放的联合索引的所有列，按照索引中的顺序进行先后排序。这也能很好的理解联合索引中的最左匹配原则。因为页中的记录是要有序排列的。</p>
<p>建索引的时候，先创建根节点，然后随着记录的插入，进行页分裂。也就是索引一旦建立，根节点就确定了，不会再移动，这也方便了根节点的查找。根节点的页面信息存储在数据字典中。</p>
<h4 id="MyISAM的索引"><a href="#MyISAM的索引" class="headerlink" title="MyISAM的索引"></a>MyISAM的索引</h4><p>索引和数据是分开的，也就是所有的索引都相当于二级索引。先在索引文件中根据主键或索引列找到对应的行号，再去数据文件中根据行号找到完整的记录。</p>
<h4 id="索引使用注意"><a href="#索引使用注意" class="headerlink" title="索引使用注意"></a>索引使用注意</h4><p><img src="http://static.zybuluo.com/70kg/x14c027m7ghg3tuqydpus4hf/WX20190523-232842.png" alt="WX20190523-232842.png-138.1kB"></p>
<h2 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h2><p>区：连续的64个页<br>组：256个区</p>
<p>第一个组的前三个页面是固定的：<br><code>FSP_HDR</code>：表空间的整体属性和本组的所有区的属性，一个表空间就这一个<br><code>IBUF_BITMAP</code>：存放本组的区的所有页面关于<code>INSERT BUFFER</code>的信息<br><code>INODE</code>：存放<code>INODE</code>类型</p>
<p>每组最开始的两个页是固定的：<br><code>XDES</code>：记录本组区的熟悉<br><code>IBUF_BITMAP</code>：同上</p>
<p>区的概念的引入是为了让相邻的页尽可能的在一起，顺序<code>I/O</code>。当数据量很大的时候，以区为单位分配空间。</p>
<p>为了区分叶子节点和非叶子节点，提出了<code>段</code>的概念：叶子节点所在的区放在一个段里面，非叶子节点所在区放到一个段里面，也就是一个索引有两个段。</p>
<p>为了在数据量较少的时候节约空间，提出<code>碎片区</code>的概念，这里面的页面可以属于不同的段。碎片区属于表空间。先向碎片区中以页面为单位分配空间，当一个段中有32个碎片页面的时候，就以完整的区分配空间。后面再有数据来，就不在属于表空间的碎片区中找了，就去段的那三个链表中找页面。</p>
<p>为了管理区，设计了<code>XDES Entry</code>的结构，存储了区的信息。<br><img src="http://static.zybuluo.com/70kg/7fyurp3sjl2yjekp99sfdzbk/16a739f343654829.webp" alt="16a739f343654829.webp-17.8kB"><br><code>Page State Bitmap</code>存储区中的页面是否空闲</p>
<p>这个结构的双向链表的作用：空闲区组成一个链表，有空间的碎片区组成一个链表，满的碎片区组成一个链表。为了插入数据的时候更快的找个应该插入的区。</p>
<p>上面说的都是针对属于表空间的碎片区。为了更好的管理属于段的区，每个段也有三个链表。</p>
<p>也就是一个索引，有两个段，每个段有三个链表。还有属于表空间的三个链表。</p>
<p>为了找到这些链表的头结点或者尾节点，设计了<code>List Base Node</code>的结构。包括链表长度，首尾指针的位置。</p>
<p>类似区有对应的<code>XDES Entry</code>结构，段也有<code>INODE Entry</code>的结构用来表示段的信息。有段号，三个链表的<code>List Base Node</code>，碎片页面的信息。</p>
<p>前面说的，表空间的第一个页面<code>FSP_HDR</code>，存储了表空间的整体熟悉和第一个组的256个区对应的<code>XDES Entry</code>信息。<br><img src="http://static.zybuluo.com/70kg/a7a0fjhnowm9watdoeoopf1a/16a739f47508ede5.webp" alt="16a739f47508ede5.webp-27.6kB"><br>所以属于表空间的三个链表的基节点可以在这里找到。后两个是段对应的<code>INODE Entry</code>构成的链表的基节点。</p>
<p>而索引的根节点的头信息中有对应的段信息，所有就把根节点和段映射到了一起。</p>
<h4 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h4><p><img src="http://static.zybuluo.com/70kg/i4hxrvtq6guif2pq4u0rdxjo/WX20190524-214237.png" alt="WX20190524-214237.png-61.8kB"></p>
<h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><p><code>const</code>:通过主键或者唯一二级索引<br><code>ref</code>:使用普通二级索引进行等值比较<br><code>ref_or_null</code>:普通二级索引进行等值比较或者 null<br><code>range</code>:范围匹配<br><code>index</code>:匹配规则不是联合索引的最左索引列，可以遍历索引叶子节点。<br><code>all</code>:全表扫描</p>
<p>一般只能使用单个二级索引进行查询，也就是会选择最优的索引。</p>
<p>索引合并的情况可以使用到多个二级索引。(1，二级索引是等值匹配;2,主键列可以是范围匹配)<br><code>Intersection合并</code>:交集合并<br><code>Union合并</code>:并集合并<br><code>Sort-Union合并</code>:排序并集合并</p>
<h2 id="连接的原理"><a href="#连接的原理" class="headerlink" title="连接的原理"></a>连接的原理</h2><p>驱动表:首先查询的表<br>被驱动表:根据驱动表查询出来的数据进行查询的表<br>内连接:驱动表中找不到的数据不会加入结果集<br>外连接:驱动表中的找不到的数据仍然加入结果集<br>左外连接:左边的表作为驱动表<br>右外连接:右边的表作为驱动表<br><img src="http://static.zybuluo.com/70kg/1pl29r0ihquaodwhqvsms56b/WX20190525-225316.png" alt="WX20190525-225316.png-130.9kB"><br>1<code>嵌套循环连接</code>:最简单粗暴的循环查询，在被驱动表使用合适的索引加速<br>1<code>基于块的嵌套循环连接</code>:设计了内存的<code>join buffer</code>，将驱动表的结果集放到这里，搜索被驱动表的每一条记录时，在内存中与这些记录比较。</p>
<h2 id="基于成本的优化"><a href="#基于成本的优化" class="headerlink" title="基于成本的优化"></a>基于成本的优化</h2><p>读取一个页的成本:1.0<br>读取以及检测一条记录:0.2</p>
<p>找执行计划的步骤：<br>1.根据搜索条件，找出所有可能的使用的索引<br>2.计算全表扫描的代价<br>3.计算使用不同索引执行查询的代价<br>4.对比各种方案，找出陈本最低的那个</p>
<p>计算全表扫描的代价时，页面数和记录数是由<code>mysql</code>为每个表维护了一份统计数据。</p>
<p>当计算成本的代价很大时候，使用索引统计数据计算代价。</p>
<p>连接的查询成本，驱动表的访问成本+驱动表的扇出数*被驱动表的访问成本</p>
<p>外链接驱动表固定，方便计算。内连接需要将两个表分别作为驱动表计算成本。</p>
<h2 id="如何收集统计数据"><a href="#如何收集统计数据" class="headerlink" title="如何收集统计数据"></a>如何收集统计数据</h2><p>以表为单位收集和存储统计数据，数据可以持久化也可以只在内存中。</p>
<p>分为表统计数据和索引统计数据，分别保存在两个表中。</p>
<p>表有多少行记录的估计值。按照一定的算法选取几个叶子节点页面(默认20个)，计算每个页面中的主键值记录数，然后计算平均一个页面中主键值的记录数量乘以全部叶子节点的数量。</p>
<p>更新统计数据可以自动的异步更新，也可以手动触发更新</p>
<p>有个变量决定在统计索引列不重复值的数量时如何对待<code>Null</code>。最好不要在索引列放<code>Null</code></p>
<h2 id="基于规则的优化"><a href="#基于规则的优化" class="headerlink" title="基于规则的优化"></a>基于规则的优化</h2><ul>
<li>移除不必要的括号</li>
<li>常量传递</li>
<li>等值传递</li>
<li>移除没用的条件</li>
<li>表达式计算</li>
<li>HAVING子句和WHERE子句的合并</li>
<li>常量表检测</li>
<li>外连接消除(符合null值拒绝)<h4 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h4>标量子查询和行子查询就是想象的那样<br>in查询条件少时，也是类似上面，条件多的时候会创建临时表，叫做物化表。还有进一步的<code>semi-join</code>半连接(有规则限制)。</li>
</ul>
<h2 id="Explain-详解"><a href="#Explain-详解" class="headerlink" title="Explain 详解"></a>Explain 详解</h2><ul>
<li><code>table</code>表名</li>
<li><code>id</code>分配的唯一id。连接的时候，每个表对应一条记录，id相同；前面的驱动表，后面的被驱动表；当优化器重写了子查询，可能转换成连接，id也是一样。</li>
<li><code>select_type</code>查询的类型，有<code>SIMPLE</code>，<code>PRIMARY</code>等等</li>
<li><code>type</code>执行查询的访问方法。前面有介绍，有<code>const</code>，<code>ref</code>等等</li>
<li><code>possible_keys和key</code>可能用到的索引和实际使用的索引</li>
<li><code>key_len</code>使用的索引记录的最大长度，一般用在联合索引中</li>
<li><code>ref</code>当使用索引列等值匹配的条件去执行查询时，展示与索引列作等值匹配的东东是个啥</li>
<li><code>rows</code>全表扫描时表示要扫描的行数，索引时表示预计扫描的索引记录行数</li>
<li><code>filtered</code>单表查询没什么意义，用在连接查询中。</li>
<li><code>Extra</code>额外信息</li>
</ul>
<h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a><code>Buffer Pool</code></h2><p>从磁盘中加载记录是以页为单位。缓存池就是在内存中缓存从磁盘上加载的页。<br>为了控制缓存池中的页，每个页有对应的控制块。是连续的一块内存。</p>
<p>为了记录缓存池中那些页是可用的，设计了<code>free</code>链表。<br><img src="http://static.zybuluo.com/70kg/8v1dmn9ilvyn7cyk4gtl56pz/1693e86e300173c1.webp" alt="1693e86e300173c1.webp-26kB"></p>
<p>为了找到缓存池中的页，使用表空间号+页号作为 key，页作为 value，加入到哈希表中。</p>
<p>为了记录缓存池中那些页是脏页，也就是修改了的页，设计了<code>flush</code>链表，结构类似上面。</p>
<p>缓存池的大小有限制，设计了<code>lru</code>链表来控制页的淘汰。</p>
<p>因为<code>innodb</code>有线性预读和l随机预读的功能，为了防止预读的页加入到<code>lru</code>链表头部而降低缓存命中率，将<code>lru</code>链表分成了<code>toung</code>和<code>old</code>区域，比例是3/8。</p>
<p>当页第一次从磁盘加载到缓存中，放到<code>old</code>的头部。后面访问到再放到<code>jian&#39;gejiangey</code> young`的头部。</p>
<p>为了防止全表扫描时大量使用频率低的页加入到<code>young</code>的头部。规定在对处于<code>old</code>的页第一次访问时候，记录下访问时间，如果下次访问时间和第一次的在某个时间间隔以内，不会加入到<code>young</code>的头，否则加入。</p>
<p>脏页的刷新分为把<code>lru</code>的<code>old</code>中的一些脏页刷新到磁盘，定时/当缓存池不足的时候执行。</p>
<p>根据繁忙情况，将<code>flush</code>链表中的页刷新到磁盘。</p>
<p>为了更好支持多线程，设计了多个缓存池实例。</p>
<p>为了支持运行时调整缓存池大小，不再一次性的申请一大片连续的内存空间，而是以<code>chunk</code>为单位申请。默认128m。</p>
<p>使用<code>SHOW ENGINE INNODB STATUS</code>查看缓存池状态。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul>
<li>原子性(Atomicity)</li>
<li>隔离性(Isolation)</li>
<li>一致性(Consistency)</li>
<li>持久性(Durability)</li>
</ul>
<p>数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后保持符合所有既定的约束则是一种结果。</p>
<p>使用<code>SAVEPOINT</code>保存点，方便回滚到特定的地方。</p>
<h2 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h2><p>因为<code>innodb</code>是以页为单位来管理存储空间，在持久化时也是以页为单位刷新到磁盘。 但是刷新一个完整的页比较浪费，随机<code>io</code>刷新比较慢。为了解决这个保证事务的持久性，设计了<code>redo</code>日志。因为<code>redo</code>日志仅仅记录的改动的内容，占用的空间小，顺序存储，顺序<code>io</code>效率高。</p>
<p>有很多种不同类型的<code>redo</code>日志，大部分的有这样的格式<br><img src="http://static.zybuluo.com/70kg/wom1hahmd9xrb810ojn3hxz1/1694892fdec61898.webp" alt="1694892fdec61898.webp-5.6kB"></p>
<p>执行一条语句可能涉及修改多个页，所有会产生多个<code>redo</code>日志。将日志进行分组，以组的形式操作日志，保证日志的原子性。</p>
<p>分组的标记是在组最后插入一个特殊的<code>redo</code>日志。</p>
<p>事务，语句和日志的关系<br><img src="http://static.zybuluo.com/70kg/teynwelybswe87w94jrtgrlx/169489303b9e5c9f.webp" alt="169489303b9e5c9f.webp-5.4kB"></p>
<h3 id="日志的写入过程"><a href="#日志的写入过程" class="headerlink" title="日志的写入过程"></a>日志的写入过程</h3><p>把<code>mtr</code>生成的日志都放到一个页里面(block)。同时也存在一个日志的缓存池<code>redo log buffer</code>。</p>
<p>在<code>mtr</code>运行时生成的日志，先放到一个临时的地方，执行完之后，再一起复制到<code>log buffer</code>中。</p>
<h3 id="日志刷盘时机"><a href="#日志刷盘时机" class="headerlink" title="日志刷盘时机"></a>日志刷盘时机</h3><ul>
<li>缓存池空间不足时</li>
<li>事务提交时候候</li>
<li>后台线程自动刷新</li>
<li>正常关闭服务器时候。</li>
<li>等等</li>
</ul>
<p>日志文件可能有多个，一个一个写，写到最后一个再从头开始。</p>
<p>文件头2048个字节是管理数据，后面的存储缓存池中的<code>block</code>镜像。</p>
<p>每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早。</p>
<p>1<code>redo</code>日志只是为了系统崩溃后恢复脏页用的，当脏页已经刷新到磁盘，这些日志也就不需要了，也就是可以被覆盖了。</p>
<p>使用<code>checkpoint</code>记录脏页刷新到的位置。</p>
<h2 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a><code>undo</code>日志</h2><p><code>undo</code>日志是为了保证事务的原子性。为回滚设计。</p>
<p>在事务中，只有第一次对表进行增删改操作才会给这个事务分配一个事务 id.</p>
<p>记录的行格式，有<code>trx_id</code>，<code>roll_pointer</code>两个隐藏列。</p>
<p>在增删改之前要先记录<code>undo</code>日志。</p>
<h3 id="插入的日志"><a href="#插入的日志" class="headerlink" title="插入的日志"></a>插入的日志</h3><p>对应的日志类型是<code>TRX_UNDO_INSERT_REC</code>，主要记录表个主键信息。</p>
<h4 id="roll-pointer的含义"><a href="#roll-pointer的含义" class="headerlink" title="roll_pointer的含义"></a><code>roll_pointer</code>的含义</h4><p><img src="http://static.zybuluo.com/70kg/1dmxvyz9dxi0bpiya9h5t9w9/16a52ce7de875e53.webp" alt="16a52ce7de875e53.webp-13.8kB"></p>
<p>简单说就是指向<code>undo</code>日志的指针。</p>
<h3 id="删除对应的日志"><a href="#删除对应的日志" class="headerlink" title="删除对应的日志"></a>删除对应的日志</h3><p>删除一条记录分为两步：</p>
<ol>
<li>将记录头信息中的<code>delete_mask</code>置为1，这个阶段是<code>delete mark</code></li>
<li>当事务提交后，由专门的线程将这个记录从正常的链表中移除，加入到垃圾链表中。这个阶段是<code>purge</code>。<br>这么做主要是为了事务的<code>mvcc</code>。</li>
</ol>
<p>对应的日志类型<code>TRX_UNDO_DEL_MARK_REC</code>。</p>
<p>在进行<code>delete mark</code>之前，先把这个记录的当前的<code>trx_id</code>和<code>roll_pointer</code>记录到日志中，这样形成了一个版本链，也是为<code>mvcc</code>服务。类似的情况可以是先插入一个，再删除这个，那回滚的时候就会用到这个版本链。<br><img src="http://static.zybuluo.com/70kg/orm75cvjlqrewbjsaj7et7wy/16a52ce88f2eff73.webp" alt="16a52ce88f2eff73.webp-7kB"></p>
<h3 id="更新对应的日志"><a href="#更新对应的日志" class="headerlink" title="更新对应的日志"></a>更新对应的日志</h3><p>不更新主键的情况：<br>就地更新，也就是记录的各列的数据长度不变。<br>不能就地更新的，先删除旧记录，再插入新记录，这里的删除是直接移到垃圾链表中，而不是仅仅的标记，同时使用的同步剔除，而不是专门的线程。<br>使用的日志类型是<code>TRX_UNDO_UPD_EXIST_REC</code>；</p>
<p>更新主键的情况：<br>因为这时候主键变化了，在索引的中的位置也要改变。<br>先标记删除，这里仅仅的标记，是因为其他的事务也可能访问这个记录，如果直接移除到垃圾链表，别的事务就访问不到了，也是为了<code>mvcc</code><br>然后插入一条数据。</p>
<p>记录一条<code>TRX_UNDO_DEL_MARK_REC</code>类型的日志</p>
<h3 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h3><p>日志页是存储在<code>FIL_PAGE_UNDO_LOG</code>页中，这些页也是像之前一样，组成双向链表。<br>在这种页的页头信息中记录的当前页存储的两大类日志的类型：<br><code>TRX_UNDO_INSERT</code>:插入语句或者更新主键的时候产生<br><code>TRX_UNDO_UPDATE</code>:删除语句或者更新普通记录产生</p>
<p>一个页面只能存储一种大类型的日志，不能混存。之所以分为两大类，也是为了<code>mvcc</code>，第一类在事务提交后可以直接删除，第二类还有用处。</p>
<p>两种类型的的日志的链表分别组成了两个双向链表，同时还有临时表和普通表的区别，也就是一个事务中，最多会产生四条链表。</p>
<p>不同的事务的链表是隔离的。也就是不同的事务过程中产生的日志需要写入不同的日志页面链表中。</p>
<p>每个<code>undo</code>页面链表都对应一个段，叫做<code>Undo Log Segment</code>，也就是链表中的页面都是从这个段中申请的。在链表的第一个页面中有<code>Undo Log Segment Header</code>，记录了对应段的信息。存储了当前页面链表处在什么状态</p>
<p>有活跃状态：一个活跃的事务正在往这个链表里面写日志；<br>被缓存状态：等待被其他事务重用<br>等等</p>
<h3 id="重用undo页面"><a href="#重用undo页面" class="headerlink" title="重用undo页面"></a>重用<code>undo</code>页面</h3><p>因为有些事务占用的日志页面很少，也为其分配了新链表比较浪费空间。<br>判断能否重用：<br>该链表中只包含一个页面；(页面很多，维护也是成本)<br>该页面使用的空间小于整个页面空间的3/4;</p>
<p>1<code>insert undo链表</code>的重用：因为这种链表在事务提交后可以删除，所有直接覆盖写页面<br>1<code>update undo链表</code>的重用：因为这种不能直接删除，所有在页面后面继续写，也就是一个页面包含多组的日志。</p>
<h3 id="回滚段"><a href="#回滚段" class="headerlink" title="回滚段"></a>回滚段</h3><p>为了管理这些<code>undo</code>链表，设计了回滚段的概念，这是一个段，但是就一个页面，这个页面中存储了<code>undo</code>链表的第一个页面的地址(<code>undo slot</code>)。</p>
<p>初始的<code>undo slot</code>的值的<code>FIL_NULL</code>。当要开始分配<code>undo</code>链表时候，先看这个槽是不是初始状态，如果是，就在这个槽中记录链表的第一个页面地址；如果不是，看下一个槽是不是。一共有1024个槽，也就是并发支持的事务有上限，会抛出异常。</p>
<p>当事务提交后，槽指向的页面符合重用条件，加入到缓存链表中，再有新事务分配槽时候，先去这个缓存链表中查找，找不到再去回滚段中的槽查找。</p>
<p>如果不能重用，对于指向的是<code>insert undo</code>链表，直接释放，初始化状态。<code>update undo</code>链表，初始化状态，将这些<code>undo</code>日志放到<code>History链表</code>中。</p>
<p>为了支持更多的事务并发，设计了多个回滚段。为了管理这些回滚段，在系统表空间中的第5号页面设计了128个包含8字节的格子，每一个格子对应一个回滚段。</p>
<p>##事务隔离级别和MVCC(多版本并发控制)<br>因为事务并发执行的原因，为了最大可能的保持隔离性和性能，提出了<code>mvcc</code>。</p>
<p>脏写：</p>
<p>一个事务修改了另外一个未提交事务修改过的数据。这是一定要避免的。<br><img src="http://static.zybuluo.com/70kg/lskrogkzmq4ckpy1w9wquq6e/16a2f43405cb6e70.webp" alt="16a2f43405cb6e70.webp-12.8kB"></p>
<p>脏读：<br>li一个事务读到另外一个未提交事务修改过的数据。<br><img src="http://static.zybuluo.com/70kg/c5at9oodawhwizasmkhkrbia/16a2f79b4eacc05d.webp" alt="16a2f79b4eacc05d.webp-15kB"></p>
<p>不可重复读：<br>一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每次对这个数据进行一次修改并且提交后，该事务都能读取到最新值<br><img src="http://static.zybuluo.com/70kg/3t0qcigh8wh4ua4i4w1orvyy/16a2f5b32bc1f76b.webp" alt="16a2f5b32bc1f76b.webp-23.3kB"></p>
<p>幻读：<br>一个事务先根据某些条件查出一些数据，之后另一个书屋又向表中插入了符合这些条件的数据，原来的事务在此按照此条件查询时候，能把另一个事务插入的记录页读取出来<br><img src="http://static.zybuluo.com/70kg/bq9df1pujc6xe0knwt169m12/16a2f5b32d7b9ada.webp" alt="16a2f5b32d7b9ada.webp-16kB"></p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p><img src="http://static.zybuluo.com/70kg/0no60hso9jjlzfjzq6b7a8c6/WX20190530-204506.png" alt="WX20190530-204506.png-27.9kB"><br><img src="http://static.zybuluo.com/70kg/v4hbju6f9h1afhdt2nou1f6k/WX20190530-204552.png" alt="WX20190530-204552.png-64.9kB"><br><code>mysql</code>在<code>repeatable read</code>的隔离级别下是可以禁止幻读的发生。</p>
<h3 id="mvcc原理"><a href="#mvcc原理" class="headerlink" title="mvcc原理"></a>mvcc原理</h3><p>前面说的版本链。每一条记录的头有<code>trx_id</code>事务 id 和<code>roll_pointer</code>回滚点，也是指向<code>undo</code>日志。同时在<code>undo</code>日志中，也又指向前一个<code>undo</code>日志的指针，这就形成了一个版本链。<code>undo</code>日志中页记录了事务 id。</p>
<p>####<code>ReadView</code><br>对于<code>READ UNCOMMITTED</code>，每次读取最新的值就好了；对于<code>SERIALIZABLE</code>，使用加锁保证串行化。其他两个级别都要保证读取到已经提交的记录。也就是要判断版本链中哪个版本是对当前事务可见的。因此提出了<code>ReadView</code>的概念。一个<code>ReadView</code>包含下面四个重要内容：</p>
<p>1<code>m_ids</code>：在生成<code>ReadView</code>时，当前系统中活跃的读写事务的 id 列表<br>1<code>min_trx_id</code>：在生成<code>ReadView</code>时，当前活跃的读写事务 id的最小值，也是上面列表中的最小值<br>1<code>max_trx_id</code>：在生成<code>ReadView</code>时，系统应该分配给下一个事务的 id<br>1<code>creator_trx_id</code>:生成<code>ReadView</code>的事务 id。</p>
<p>当访问记录中的事务 id==当前的事务 id,说明是自己修改的，可以访问。</p>
<p>当访问版本的事务 id&lt; 最小事务 id。说明访问的这个记录已经提交了，可以访问。</p>
<p>当访问的版本的事务 id&gt;下一个事务 id。说明这个事务是在生成<code>ReadView</code>之后才开启的，不能访问。</p>
<p>如果访问的版本事务 id在 2，3之间，要判断事务 id在不在活跃的事务 id 列表中，如果在，不能访问。</p>
<p>如果当前版本的数据对当前事务不可见，就沿着版本链找，看能不能找到符合的版本。</p>
<p>1<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>的不同在于生成<code>ReadView</code>的时机不同，前一个是每次读取事务前就生成一个，后一个是事务中第一次读取数据时生成一个，后面就不生成了。所以前一个能读取到相对较多的数据，后一个读取的数据就是生成<code>ReadView</code>时能读的，后面的就读不到了。前一个还有可能读到，因为它是不断生成的。类似快照。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>为了禁止脏写的情况，也就是并发写要排队，提出了锁的概念。锁在 MySQL 中是一个在内存中的结构。</p>
<p>当想对一条记录进行修改时候，如果没有对应的锁结构，生成一个。</p>
<p>如果一个有了，要阻塞等待锁释放。<br><img src="http://static.zybuluo.com/70kg/j221dijvoov774xp5doqcnb2/16a680105e955d9a.webp" alt="16a680105e955d9a.webp-13.6kB"></p>
<p>实现<code>mvcc</code>一种是上面的版本链，还可以使用锁。</p>
<p>共享锁(s锁):<br>一个事务对一个记录加了 s 锁，另一个也可以加 s 锁。不能加 x 锁。</p>
<p>独占锁(x锁)：<br>一个事务对一个记录加了 x锁，其他事务不能加 s 锁也不能 x 锁。</p>
<p><code>SELECT ... LOCK IN SHARE MODE;</code>s 锁读<br><code>SELECT ... FOR UPDATE;</code>x锁 读</p>
<p>删除操作可以看成获取 x 锁的锁定读；<br>插入操作一般不加锁，提供隐私锁保护该记录在事务提交前被别的事务访问。<br>更新分三种：没修改主键且更新列的存储空间不变，就地更新，看成 x 锁的锁定读。<br>没修改主键但是更新列的存储空间变化了，要先删再插入，看成 x 锁的锁定读。</p>
<h3 id="多粒度锁"><a href="#多粒度锁" class="headerlink" title="多粒度锁"></a>多粒度锁</h3><p>表 s 锁：不能访问表 x锁和记录的 x 锁<br>表 x 锁：啥都不行。</p>
<p>当对表进行上锁时候，如何知道表中有没有被上行锁？因此设计了意向锁。</p>
<p>意向共享锁(IS)：当准备给一个记录上 s 锁，先对表上一个 IS 锁。<br>意向独占所(IX)：当准备给一个记录上 x 锁，先对表上一个 IX 锁。</p>
<p><code>MyISAM</code>等其他引擎只支持表锁。</p>
<h3 id="行级锁详情"><a href="#行级锁详情" class="headerlink" title="行级锁详情"></a>行级锁详情</h3><p>1<code>Record Locks</code>：皮称 正经记录锁，分 s 和 x 锁。就是理解中的锁。<br>1<code>Gap Locks</code>：gap 锁，给当前记录前面加锁。仅仅是为了防止插入幻读记录提出的。<br>1<code>Next-Key Locks</code>:next-key 锁，给当前记录以及记录前面加锁。<br>插入的时候可以不显式的加锁。当插入一个记录后，马上有事务访问这个记录，会自动帮这个新插入的记录生成一个x 锁，然后在给自己生成一个锁，进行阻塞等待。</p>
<p><a href="https://mp.weixin.qq.com/s/wSlNZcQkax-2KZCNEHOYLA" target="_blank" rel="external">超全面MySQL语句加锁分析（上篇）</a><br><a href="https://mp.weixin.qq.com/s/ODbju9fjB5QFEN8IIYp__A" target="_blank" rel="external">超全面MySQL语句加锁分析（中篇）</a><br><a href="https://mp.weixin.qq.com/s/9WWBXLNoUcTkS4DJnM5ViA" target="_blank" rel="external">超全面MySQL语句加锁分析（下篇）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;行格式&quot;&gt;&lt;a href=&quot;#行格式&quot; class=&quot;headerlink&quot; title=&quot;行格式&quot;&gt;&lt;/a&gt;行格式&lt;/h2&gt;&lt;p&gt;&lt;code&gt;InnoDB&lt;/code&gt;有四种行格式，或者是记录格式，分别是&lt;code&gt;Compact&lt;/code&gt;，&lt;code&gt;Redundant&lt;/code&gt;，&lt;code&gt;Dynamic&lt;/code&gt;，&lt;code&gt;Compressed&lt;/code&gt;，1，3，4是比较相似的，区别在于页溢出的处理方式。
    
    </summary>
    
    
      <category term="MySql" scheme="http://yoursite.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>撸一个简易 Stream</title>
    <link href="http://yoursite.com/2019/04/09/%E6%92%B8%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93Stream/"/>
    <id>http://yoursite.com/2019/04/09/撸一个简易Stream/</id>
    <published>2019-04-09T09:33:10.000Z</published>
    <updated>2019-04-09T09:47:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>从<code>jdk8</code>开始，<code>java</code>新增了<code>Stream</code>相关的<code>API</code>。配合<code>lambda</code>表达式，<code>java</code>也拥有了部分的函数式编程的能力。<a id="more"></a><br><code>Stream</code>的出现，使得<code>java</code>对集合的操作变得简单且意图明确，同时<code>parallel</code>方法也使得并行计算变得方便。下面仿照<code>jdk</code>的代码自己实现下面的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Stream.of(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line">               .map(x -&gt; String.valueOf(x + <span class="number">1</span>))</div><div class="line">               .sorted()</div><div class="line">               .map(Integer::parseInt)</div><div class="line">               .forEach(System.out::println);</div></pre></td></tr></table></figure>
<p>这一篇只是初步实现<code>stream</code>的简易串行版本，后面会再尝试实现简易的并行<code>API</code>。</p>
<p>在上面的代码中，包含四种操作</p>
<ul>
<li>创建<code>stream</code>操作，不包含其他的操作</li>
<li><code>map</code>这种无状态的操作，也就是不依赖上下文的操作</li>
<li><code>sorted</code>有状态的操作，需要得到全部的信息才能生效</li>
<li><code>foreach</code>终止操作，后面不能再有其他操作。</li>
</ul>
<p>上面这四种操作，分别在在代码中对应为<code>Head</code>,<code>StatelessOp</code>,<code>StatefulOp</code>以及<code>TerminalOp</code>。这些操作除了终止操作都是<code>referencePipeLine</code>的子类，也就是每一个操作都是流水线的一部分。为什么要设计成流水线的模式？因为在流水线的模式下，可以做到尽量在一次遍历中完成整个操作。下面来简单说一下这个流水线是怎么实现的。</p>
<p>上面的每个操作都是一个<code>op</code>,在<code>stream</code>中，一个完整的操作可以用<code>&lt;数据源,操作,回调函数&gt;</code>简单表示。而这个完整的操作在<code>stream</code>中用<code>stage</code>表示。上面的代码最终行程的流水线类似一个个<code>stage</code>组成的双向链表。至于为什么是双向的链表，是因为前面的<code>stage</code>要调用后面的<code>stage</code>，所以需要后面<code>stage</code>的引用。真正触发整个流水线工作的地方是在最后的终止操作，也就是前面的非终止操作都是惰性执行的。当终止操作开始，需要一层层的包装回去，包装成”一个操作”，执行这个操作就相当于执行整个流水线，所以当前的 <code>stage</code>需要有前一个<code>stage</code>的引用，也就形成了双线链表。同时两个<code>stage</code>之间的调用肯定也是有一个协议，也就是<code>sink</code>接口。<br>整个代码的设计还是很精巧的。下面的我写的简易的<code>stream</code>。<br><a href="https://dev.tencent.com/u/70kg/p/Spring-boot-Demo/git/tree/dev/src/main/java/com/example/demo/steam" target="_blank" rel="external">MyStream</a></p>
<p>参考：<br><a href="https://www.cnblogs.com/CarpenterLee/p/6637118.html" target="_blank" rel="external">深入理解Java Stream流水线</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从&lt;code&gt;jdk8&lt;/code&gt;开始，&lt;code&gt;java&lt;/code&gt;新增了&lt;code&gt;Stream&lt;/code&gt;相关的&lt;code&gt;API&lt;/code&gt;。配合&lt;code&gt;lambda&lt;/code&gt;表达式，&lt;code&gt;java&lt;/code&gt;也拥有了部分的函数式编程的能力。
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp 相关类</title>
    <link href="http://yoursite.com/2019/02/16/okhttp/"/>
    <id>http://yoursite.com/2019/02/16/okhttp/</id>
    <published>2019-02-16T08:17:26.000Z</published>
    <updated>2019-02-16T08:23:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h4><ul>
<li>RetryAndFollowUpInterceptor<br>用于重试和重定向，<code>StreamAllocation</code>也是在此初始化。主要是<code>while</code>拼装<code>followUpRequest</code>。</li>
<li>BridgeInterceptor<br>添加<code>Content-Type</code>，<code>&quot;Transfer-Encoding&quot;, &quot;chunked&quot;</code>，<code>gzip</code>等请求头和对应的相应解析。还有<code>cookie</code>的处理。</li>
<li>CacheInterceptor<br>根据<code>CacheStrategy</code>来处理获取缓存响应，通过<code>getCandidate</code>根据<code>If-None-Match</code>配合<code>etag</code>，<code>If-Modified-Since</code>配合<code>lastModified</code>等判断缓存是否有效。请求网络，是否<code>304</code>，更新相应缓存条件，组装响应。使用了<code>DiskLruCache</code>进行缓存的持久化，通过日志文件实现类似索引的功能，读写分离，写有类似事务的概念。定期清理。</li>
<li>ConnectInterceptor<br>负责链接的建立和复用，以及连接上流的管理。</li>
<li>CallServerInterceptor<br>连接建立后，与服务器进行数据交互，使用最终的<code>request</code>和最原始的<code>response</code>。<a id="more"></a>
</li>
</ul>
<h4 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h4><ul>
<li>StreamAllocation<br>连接和流的桥梁。持有<code>RealConnection</code>连接和<code>HttpCodec</code>流。通过<code>newStream</code>寻找合适的连接，产生合适的流。<code>findConnection</code>方法用于寻找合适的连接。</li>
<li>RealConnection<br>物理连接的封装。持有<code>rawSocket</code>(原始 <code>socket</code>),<code>socket</code>-<code>ssl</code>加密包装的<code>SSLSocket</code>。功能包括<code>tcp</code>的建立，协议的确定，<code>tls</code>连接的建立等。相应的握手也是由这两个对应平台的系统类实现。还实现了<code>CertificatePinner</code>，用于自定义证书指纹的验证。持有<code>List&lt;Reference&lt;StreamAllocation&gt;&gt; allocations</code>，表示该连接上有几条流，<code>http1.1</code>默认最大1.<code>http2</code>没限制。</li>
<li>Http1Codec/Http2Codec<br>分别代表<code>http1.x</code>和<code>http2</code>的解码器，也相对于代表流。负责请求头，请求体的写入和响应头，响应体的读取。</li>
<li>ConnectionPool<br>连接池，管理连接的缓存和复用。<code>cleanupRunnable</code>用于定期或者某些条件触发根据最大空闲连接和最大存活时间进行连接的清理。清理是根据有没有<code>StreamAllocation</code>还在引用<code>RealConnection</code>，也就是引用计数。当响应返回，在<code>RetryAndFollowUpInterceptor</code>中<code>streamAllocation.release()</code>，然后读取完<code>response</code>后，在<code>Http1Codec</code>中标记<code>streamFinished</code>，然后表示这个连接空闲。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Interceptor&quot;&gt;&lt;a href=&quot;#Interceptor&quot; class=&quot;headerlink&quot; title=&quot;Interceptor&quot;&gt;&lt;/a&gt;Interceptor&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;RetryAndFollowUpInterceptor&lt;br&gt;用于重试和重定向，&lt;code&gt;StreamAllocation&lt;/code&gt;也是在此初始化。主要是&lt;code&gt;while&lt;/code&gt;拼装&lt;code&gt;followUpRequest&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;BridgeInterceptor&lt;br&gt;添加&lt;code&gt;Content-Type&lt;/code&gt;，&lt;code&gt;&amp;quot;Transfer-Encoding&amp;quot;, &amp;quot;chunked&amp;quot;&lt;/code&gt;，&lt;code&gt;gzip&lt;/code&gt;等请求头和对应的相应解析。还有&lt;code&gt;cookie&lt;/code&gt;的处理。&lt;/li&gt;
&lt;li&gt;CacheInterceptor&lt;br&gt;根据&lt;code&gt;CacheStrategy&lt;/code&gt;来处理获取缓存响应，通过&lt;code&gt;getCandidate&lt;/code&gt;根据&lt;code&gt;If-None-Match&lt;/code&gt;配合&lt;code&gt;etag&lt;/code&gt;，&lt;code&gt;If-Modified-Since&lt;/code&gt;配合&lt;code&gt;lastModified&lt;/code&gt;等判断缓存是否有效。请求网络，是否&lt;code&gt;304&lt;/code&gt;，更新相应缓存条件，组装响应。使用了&lt;code&gt;DiskLruCache&lt;/code&gt;进行缓存的持久化，通过日志文件实现类似索引的功能，读写分离，写有类似事务的概念。定期清理。&lt;/li&gt;
&lt;li&gt;ConnectInterceptor&lt;br&gt;负责链接的建立和复用，以及连接上流的管理。&lt;/li&gt;
&lt;li&gt;CallServerInterceptor&lt;br&gt;连接建立后，与服务器进行数据交互，使用最终的&lt;code&gt;request&lt;/code&gt;和最原始的&lt;code&gt;response&lt;/code&gt;。
    
    </summary>
    
    
      <category term="Okhttp" scheme="http://yoursite.com/tags/Okhttp/"/>
    
  </entry>
  
  <entry>
    <title>Fresco浅析</title>
    <link href="http://yoursite.com/2017/11/30/Fresco%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2017/11/30/Fresco浅析/</id>
    <published>2017-11-30T14:19:14.000Z</published>
    <updated>2017-12-07T14:31:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SimpleDraweeView层级初始化"><a href="#SimpleDraweeView层级初始化" class="headerlink" title="SimpleDraweeView层级初始化"></a><code>SimpleDraweeView</code>层级初始化</h3><p><code>GenericDraweeHierarchyInflater</code> 从xml中解析<code>SimpleDraweeView</code>属性值，(收集属性),然后赋值给<code>GenericDraweeHierarchyBuilder</code>去创建，在G<code>enericDraweeView</code>的构造函数中去build,创建<code>GenericDraweeHierarchy</code>，也就是初始化XML中的属性。这个和代码创建一个效果。类似placeholderImage这些是按照层级放到Drawable[]中，根据这个创建<code>mTopLevelDrawable</code>，<code>mTopLevelDrawable</code>中可以做渐变，进度等操作。就是改变Drawable[]中不同的drawable实现的。然后setController时候会设置<code>mTopLevelDrawable</code>先显示。<a id="more"></a></p>
<p>判断<code>OldController</code>能不能复用是根据<code>DraweeHolder：：isControllerValid</code>判断，实际上是<code>mController.getHierarchy() == mHierarchy</code></p>
<p><code>PipelineDraweeController</code>是唯一实现的</p>
<h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><p>内存缓存包括已经解码（<code>BitmapMemoryCache</code>）的和未解码的（<code>EncodedMemoryCache</code>）。在源码中表示为<code>MemoryCache</code>，有两个实现类，<code>InstrumentedMemoryCache</code>可以做一些自定义的东西，<code>CountingMemoryCache</code>主要缓存类。缓存的节点是<code>Entry</code>，里面有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> K key;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> CloseableReference&lt;V&gt; valueRef;</div></pre></td></tr></table></figure>
<p>使用<code>CountingLruMap</code>来存放数据，其中起作用的是<code>LinkedHashMap&lt;K, V&gt; mMap</code>。很显然是LRU。</p>
<h3 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h3><p>会有<code>CONTENT_FILE_EXTENSION = &quot;.cnt&quot;;</code>的缓存文件和<code>TEMP_FILE_EXTENSION = &quot;.tmp&quot;;</code>临时缓存文件。文件储存主要是<code>DefaultDiskStorage</code>起作用。<code>DiskStorageCache</code>是实现文件缓存的主要类，在<code>maybeEvictFilesInCacheDir</code>也实现了LRU控制缓存。上面还有一层是<code>BufferedDiskCache</code>中的<code>StagingArea mStagingArea</code>，查找的现在这里面查找，找不到通过<code>getAsync</code>从<code>DiskStorageCache</code>中查找。写入的时候会先创建临时文件，然后在<code>endInsert</code>中使用<code>commit</code>完成缓存文件替换，写入。</p>
<h3 id="Pipeline流水线"><a href="#Pipeline流水线" class="headerlink" title="Pipeline流水线"></a>Pipeline流水线</h3><p>触发加载图片请求是在进入到<code>AbstractDraweeController</code>的<code>onAttach</code>，然后 <code>submitRequest();</code>请求图片操作。先去<code>getCachedImage()</code>获取缓存解码图片，根据<code>mCacheKey</code>从<code>mMemoryCache中</code>获取，<code>mCacheKey</code>中包含url和对图片的一些设置，例如<code>resize</code>,<code>rotation</code>等，都是从<code>imagerequest</code>中获取的。<code>mMemoryCache</code>是通过<code>mImagePipeline.getBitmapMemoryCache()</code>获得，是通过<code>BitmapCountingMemoryCacheFactory创建的CountingMemoryCache</code>，</p>
<p>获取到<code>CloseableReference&lt;CloseableImage&gt;</code>，然后包装成<code>drawable</code>，通过<code>GenericDraweeHierarchy</code>设置给<code>mActualImageWrapper</code>，这个也存在之前的drawable数组中，也就是<code>ACTUAL_IMAGE</code>。</p>
<p>层层<code>Producer</code>处理，责任链,每一层存在本层能否直接给<code>Consumer</code>提供数据，不能则将<code>Consumer</code>在本层包装一下交给下一层去获取数据。本层的<code>Consumer</code>做一些缓存数据等操作。</p>
<p>例如<code>BitmapMemoryCacheProducer</code>和<code>DecodeProducer</code>就是上下层的关系。首先先在<code>BitmapMemoryCacheProducer</code>的</p>
<pre><code>produceResults(
      final Consumer&lt;CloseableReference&lt;CloseableImage&gt;&gt; consumer,
      final ProducerContext producerContext)
</code></pre><p>方法中寻找解码的图片，如果有，返回给消费解码数据的<code>consumer</code>，如果没有则用本层的<code>wrapConsumer</code>包装一下消费解码图片的消费者传递给下面一层的<code>DecodeProducer</code>，调用<code>DecodeProducer</code>的<code>produceResults</code>方法。同理，<code>DecodeProduce</code>r本身不产生数据，他只处理图片的解码，所有把上层传来的<code>consumer</code>再包装一次，传给下面的生产者。例如在磁盘上找到了符合条件的图片，则会走消费这一条路，调用层层的<code>consumer</code>，例如到了<code>DecodeProducer</code>的<code>consumer</code>，会异步去解码，解码成功后再去调用上层的<code>Consumer</code>的<code>onNewResult</code>，内部会调用对应层的<code>onNewResultImpl</code>方法，例如<code>BitmapMemoryCacheProducer</code>中的<code>wrapConsumer</code>的<code>DelegatingConsumer</code>的<code>onNewResultImpl</code>，这里会在内存中缓存解码的图片了。然后再调用上层的<code>consumer</code>。最上层的<code>Consumer</code>是在<code>AbstractProducerToDataSourceAdapter</code>中<code>createConsumer</code>创建的。然后通过它的<code>setResult</code>方法通知所有的<code>dataSubscriber</code>，然后在主线程回调<code>dataSubscriber.onNewResult</code>，然后就是使用 <code>mSettableDraweeHierarchy.setImage</code>去给<code>mActualImageWrapper.setDrawable(drawable);</code>这就完成了图片的显示。<br>整个的producer的顺序是在<code>ProducerSequenceFactory::getDecodedImageProducerSequence</code>的方法里面确立的。</p>
<h3 id="Bitmap在内存的分配"><a href="#Bitmap在内存的分配" class="headerlink" title="Bitmap在内存的分配"></a>Bitmap在内存的分配</h3><p><a href="http://blog.csdn.net/chiefhsing/article/details/53899242" target="_blank" rel="external">谈谈fresco的bitmap内存分配</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SimpleDraweeView层级初始化&quot;&gt;&lt;a href=&quot;#SimpleDraweeView层级初始化&quot; class=&quot;headerlink&quot; title=&quot;SimpleDraweeView层级初始化&quot;&gt;&lt;/a&gt;&lt;code&gt;SimpleDraweeView&lt;/code&gt;层级初始化&lt;/h3&gt;&lt;p&gt;&lt;code&gt;GenericDraweeHierarchyInflater&lt;/code&gt; 从xml中解析&lt;code&gt;SimpleDraweeView&lt;/code&gt;属性值，(收集属性),然后赋值给&lt;code&gt;GenericDraweeHierarchyBuilder&lt;/code&gt;去创建，在G&lt;code&gt;enericDraweeView&lt;/code&gt;的构造函数中去build,创建&lt;code&gt;GenericDraweeHierarchy&lt;/code&gt;，也就是初始化XML中的属性。这个和代码创建一个效果。类似placeholderImage这些是按照层级放到Drawable[]中，根据这个创建&lt;code&gt;mTopLevelDrawable&lt;/code&gt;，&lt;code&gt;mTopLevelDrawable&lt;/code&gt;中可以做渐变，进度等操作。就是改变Drawable[]中不同的drawable实现的。然后setController时候会设置&lt;code&gt;mTopLevelDrawable&lt;/code&gt;先显示。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative是怎么在Android上跑起来的</title>
    <link href="http://yoursite.com/2017/09/08/ReactNative%E6%98%AF%E6%80%8E%E4%B9%88%E5%9C%A8Android%E4%B8%8A%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
    <id>http://yoursite.com/2017/09/08/ReactNative是怎么在Android上跑起来的/</id>
    <published>2017-09-08T15:56:12.000Z</published>
    <updated>2017-09-10T13:21:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>(源码版本：0.34，新版本(0.48)基本流程是不变的，建议跟着源码看看，哪个版本的倒影响不大)<br>这篇简单刨析一下<code>React Native</code>是怎么在<code>Android</code>上跑起来的，会从下面几个方面说说。<a id="more"></a></p>
<ul>
<li>启动流程</li>
<li>通信机制</li>
<li>事件驱动  </li>
<li>渲染原理 </li>
<li>脚本执行 </li>
</ul>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p><code>React Native</code>在<code>Android</code>上启动是从<code>ReactRootView.startReactApplication</code>触发的，而<code>ReactRootView</code>是继承<code>FrameLayout</code>的，所以<code>React Native</code>在<code>Android</code>的操作都是在这个<code>View</code>中进行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startReactApplication(ReactInstanceManager reactInstanceManager, String moduleName, <span class="meta">@Nullable</span> Bundle launchOptions)</div></pre></td></tr></table></figure>
<p>这个方法参数第一个<code>ReactInstanceManager</code>，实现是<code>XReactInstanceManagerImpl</code>，可以理解在应用层对<code>RN</code>的配置都是对这个类操作实现的。<code>moduleName</code>是要启动的<code>RN</code>的<code>Component</code>的<code>name</code>,是在<code>js</code>的<code>AppRegistry.registerComponent(&#39;xxx&#39;, () =&gt; App);</code>定义的。最后的<code>launchOptions</code>是传过去的参数，可以在<code>js</code>的<code>Component</code>的<code>props</code>中获取。</p>
<p>下一步到了<code>mReactInstanceManager.createReactContextInBackground();</code>是在后台线程中创建<code>RN</code>的<code>ReactContext</code>上下文对象，然后到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JavaScriptExecutor 默认就是jsc,如果的debug在chrome上时候，就是v8。</span></div><div class="line"><span class="comment">//JSBundleLoader 有AssetLoader FileLoader CachedBundleFromNetworkLoader RemoteDebuggerBundleLoader 从不同的地方加载bundle</span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recreateReactContextInBackground</span><span class="params">(</span></span></div><div class="line">      JavaScriptExecutor.Factory jsExecutorFactory,</div><div class="line">      JSBundleLoader jsBundleLoader) &#123;</div><div class="line">    UiThreadUtil.assertOnUiThread();</div><div class="line"></div><div class="line">    ReactContextInitParams initParams =</div><div class="line">        <span class="keyword">new</span> ReactContextInitParams(jsExecutorFactory, jsBundleLoader);</div><div class="line">    <span class="keyword">if</span> (mReactContextInitAsyncTask == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// No background task to create react context is currently running, create and execute one.</span></div><div class="line">      mReactContextInitAsyncTask = <span class="keyword">new</span> ReactContextInitAsyncTask();</div><div class="line">      mReactContextInitAsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, initParams);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// Background task is currently running, queue up most recent init params to recreate context</span></div><div class="line">      <span class="comment">// once task completes.</span></div><div class="line">      mPendingReactContextInitParams = initParams;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>主要的创建工作就转移到了<code>ReactContextInitAsyncTask</code>这个<code>AsyncTask</code>里面，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> Result&lt;ReactApplicationContext&gt; <span class="title">doInBackground</span><span class="params">(ReactContextInitParams... params)</span> </span>&#123;</div><div class="line">     ....</div><div class="line">      <span class="keyword">return</span> Result.of(createReactContext(jsExecutor, params[<span class="number">0</span>].getJsBundleLoader()));</div><div class="line">     ....</div><div class="line">   &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> ReactApplicationContext <span class="title">createReactContext</span><span class="params">(</span></span></div><div class="line">     JavaScriptExecutor jsExecutor,</div><div class="line">     JSBundleLoader jsBundleLoader) &#123;</div><div class="line">   ...</div><div class="line">    NativeModuleRegistry.Builder nativeRegistryBuilder = <span class="keyword">new</span> NativeModuleRegistry.Builder();<span class="comment">//NativeModule的注册表</span></div><div class="line">   JavaScriptModuleRegistry.Builder jsModulesBuilder = <span class="keyword">new</span> JavaScriptModuleRegistry.Builder();<span class="comment">//jsModules的注册表</span></div><div class="line">   ...打包定义的各种modules到上面的注册表...</div><div class="line">   </div><div class="line">       <span class="comment">//创建关键的CatalystInstanceImpl</span></div><div class="line">       CatalystInstanceImpl.Builder catalystInstanceBuilder = <span class="keyword">new</span> CatalystInstanceImpl.Builder()</div><div class="line">       ...</div><div class="line">       catalystInstance = catalystInstanceBuilder.build();</div><div class="line">   ....</div><div class="line">   <span class="comment">//扔到js线程中加载js脚本</span></div><div class="line">   catalystInstance.getReactQueueConfiguration().getJSQueueThread().callOnQueue(</div><div class="line">       <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">           <span class="comment">//让reactContext持有catalystInstance</span></div><div class="line">           reactContext.initializeWithInstance(catalystInstance);</div><div class="line">           ...</div><div class="line">           catalystInstance.runJSBundle();</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">         &#125;</div><div class="line">       &#125;).get();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在<code>CatalystInstanceImpl</code>的构造函数中有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">//native C++方法，用来初始化JNI相关状态然后返回mHybridData。具体在 OnLoad.cpp 的 JSCJavaScriptExecutorHolder 类中</span></div><div class="line">mHybridData = initHybrid();</div><div class="line">...</div><div class="line"><span class="comment">//初始化线程环境，包括和主线程绑定，JS线程，Native线程创建。</span></div><div class="line">mReactQueueConfiguration = ReactQueueConfigurationImpl.create(</div><div class="line">        ReactQueueConfigurationSpec,</div><div class="line">        <span class="keyword">new</span> NativeExceptionHandler());</div><div class="line">...</div><div class="line">initializeBridge(</div><div class="line">      <span class="keyword">new</span> BridgeCallback(<span class="keyword">this</span>),<span class="comment">//CatalystInstanceImpl内部类，用于native对java的一些回调</span></div><div class="line">      jsExecutor,<span class="comment">//jsc</span></div><div class="line">      mReactQueueConfiguration.getJSQueueThread(),<span class="comment">//js线程队列</span></div><div class="line">      mReactQueueConfiguration.getNativeModulesQueueThread(),<span class="comment">//native线程队列</span></div><div class="line">      mJavaRegistry.getModuleRegistryHolder(<span class="keyword">this</span>));<span class="comment">//nativemodules注册表</span></div><div class="line">    mMainExecutorToken = getMainExecutorToken();<span class="comment">//貌似是用于切换jsExecutor的标记，后面版本删掉了。</span></div></pre></td></tr></table></figure>
<p>然后就进入到了<code>cpp</code>层的<code>CatalystInstanceImpl.cpp</code>的<code>initializeBridge</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> CatalystInstanceImpl::initializeBridge(</div><div class="line">    jni::alias_ref&lt;ReactCallback::javaobject&gt; callback,</div><div class="line">    <span class="comment">// This executor is actually a factory holder.</span></div><div class="line">    JavaScriptExecutorHolder* jseh,</div><div class="line">    jni::alias_ref&lt;JavaMessageQueueThread::javaobject&gt; jsQueue,</div><div class="line">    jni::alias_ref&lt;JavaMessageQueueThread::javaobject&gt; moduleQueue,</div><div class="line">    ModuleRegistryHolder* mrh) &#123;</div><div class="line">    </div><div class="line">  instance_-&gt;initializeBridge(folly::make_unique&lt;JInstanceCallback&gt;(callback),</div><div class="line">                              jseh-&gt;getExecutorFactory(),</div><div class="line">                              folly::make_unique&lt;JMessageQueueThread&gt;(jsQueue),</div><div class="line">                              folly::make_unique&lt;JMessageQueueThread&gt;(moduleQueue),</div><div class="line">                              mrh-&gt;getModuleRegistry());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后有委托给了<code>Instance.cpp</code>的<code>initializeBridge</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Instance::initializeBridge(</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;InstanceCallback&gt; callback,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;JSExecutorFactory&gt; jsef,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MessageQueueThread&gt; jsQueue,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MessageQueueThread&gt; nativeQueue,</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ModuleRegistry&gt; moduleRegistry) &#123;</div><div class="line">  callback_ = <span class="built_in">std</span>::move(callback);</div><div class="line"></div><div class="line">  <span class="comment">//在js线程中包装nativeQueue和创建nativeToJsBridge_，后者在双向bridge起作用，不要仅仅看名字，内部还有一个JsToNativeBridge</span></div><div class="line">  jsQueue-&gt;runOnQueueSync(</div><div class="line">    [<span class="keyword">this</span>, &amp;jsef, moduleRegistry, jsQueue,</div><div class="line">     nativeQueue=folly::makeMoveWrapper(<span class="built_in">std</span>::move(nativeQueue))] () <span class="keyword">mutable</span> &#123;</div><div class="line">      nativeToJsBridge_ = folly::make_unique&lt;NativeToJsBridge&gt;(</div><div class="line">          jsef.get(), moduleRegistry, jsQueue, nativeQueue.move(), callback_);</div><div class="line">    &#125;);</div><div class="line">  CHECK(nativeToJsBridge_);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这就看没了，再回到上面的<code>catalystInstance.runJSBundle();</code>以<code>FileLoader</code>为例，最终走到<code>native void loadScriptFromFile(String fileName, String sourceURL);</code>进入<code>CatalystInstanceImpl.cpp</code>进而委托给<code>Instance.cpp</code>。预警。。下面是一大片的<code>cpp</code>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">void Instance::loadScriptFromFile(const std::string&amp; filename,</div><div class="line">                                  const std::string&amp; sourceURL) &#123;</div><div class="line">  ...检测文件合法性等...</div><div class="line">  loadScriptFromString(std::move(buf), sourceURL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Instance::loadScriptFromString(std::unique_ptr&lt;const JSBigString&gt; string,</div><div class="line">                                    std::string sourceURL) &#123;</div><div class="line">  callback_-&gt;incrementPendingJSCalls();//这个callback就是java层的CatalystInstanceImpl的BridgeCallback这个内部类。</div><div class="line">  ...</div><div class="line">  nativeToJsBridge_-&gt;loadApplicationScript(std::move(string), std::move(sourceURL));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void NativeToJsBridge::loadApplicationScript(std::unique_ptr&lt;const JSBigString&gt; script,</div><div class="line">                                             std::string sourceURL) &#123;</div><div class="line">  m_mainExecutor-&gt;loadApplicationScript(std::move(script), std::move(sourceURL));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void JSCExecutor::loadApplicationScript(std::unique_ptr&lt;const JSBigString&gt; script, std::string sourceURL) throw(JSException) &#123;</div><div class="line">    ...</div><div class="line">     //使用webkit JSC去真正解释执行Javascript了！</div><div class="line">     evaluateScript(m_context, jsScript, jsSourceURL);</div><div class="line">     //绑定桥，核心是通过getGlobalObject将JS与C++通过webkit JSC bind</div><div class="line">     bindBridge(); </div><div class="line">     flush();//这里算是通知java,加载完js脚本</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">void JSCExecutor::bindBridge() throw(JSException) &#123;</div><div class="line">  ...下面都是通过jsc 获取js的一下属性，方法等...</div><div class="line">  auto global = Object::getGlobalObject(m_context);</div><div class="line">  auto batchedBridgeValue = global.getProperty(&quot;__fbBatchedBridge&quot;);</div><div class="line">...</div><div class="line">  auto batchedBridge = batchedBridgeValue.asObject();</div><div class="line">  m_callFunctionReturnFlushedQueueJS = batchedBridge.getProperty(&quot;callFunctionReturnFlushedQueue&quot;).asObject();</div><div class="line">  m_invokeCallbackAndReturnFlushedQueueJS = batchedBridge.getProperty(&quot;invokeCallbackAndReturnFlushedQueue&quot;).asObject();</div><div class="line">  //这个比较重要 获取MessageQueue.js的flushedQueue 下面就用到</div><div class="line">  m_flushedQueueJS = batchedBridge.getProperty(&quot;flushedQueue&quot;).asObject();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//这个下面js-&gt;native的时候还会提到</div><div class="line">void JSCExecutor::flush() &#123;</div><div class="line">  ...真的烦，绕来绕去  m_flushedQueueJS看上面</div><div class="line">  callNativeModules(m_flushedQueueJS-&gt;callAsFunction(&#123;&#125;));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void JSCExecutor::callNativeModules(Value&amp;&amp; value) &#123;</div><div class="line">    ...</div><div class="line">  try &#123;</div><div class="line">    auto calls = value.toJSONString();</div><div class="line">    //class JsToNativeBridge : public react::ExecutorDelegate</div><div class="line">    m_delegate-&gt;callNativeModules(*this, std::move(calls), true);</div><div class="line">  &#125; catch (...) &#123;</div><div class="line">   ...</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">  void callNativeModules(</div><div class="line">      JSExecutor&amp; executor, std::string callJSON, bool isEndOfBatch) override &#123;</div><div class="line">    ExecutorToken token = m_nativeToJs-&gt;getTokenForExecutor(executor);</div><div class="line">    m_nativeQueue-&gt;runOnQueue([this, token, callJSON=std::move(callJSON), isEndOfBatch] &#123;</div><div class="line">      for (auto&amp; call : react::parseMethodCalls(callJSON)) &#123;</div><div class="line">        //快完了  这个是ModuleRegistry.cpp 是在initializeBridge间接创建包装nativemodule的</div><div class="line">        m_registry-&gt;callNativeMethod(</div><div class="line">          token, call.moduleId, call.methodId, std::move(call.arguments), call.callId);</div><div class="line">      &#125;</div><div class="line">      if (isEndOfBatch) &#123;</div><div class="line">        //又见到了这个callback</div><div class="line">        m_callback-&gt;onBatchComplete();</div><div class="line">        m_callback-&gt;decrementPendingJSCalls();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">void ModuleRegistry::callNativeMethod(ExecutorToken token, unsigned int moduleId, unsigned int methodId,</div><div class="line">                                      folly::dynamic&amp;&amp; params, int callId) &#123;</div><div class="line"> ...</div><div class="line"></div><div class="line">  modules_[moduleId]-&gt;invoke(token, methodId, std::move(params));</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到最后一句就是要去调用<code>nativeModule</code>里面的方法了，具体在<code>ModuleRegistryHolder.cpp</code>的<code>JavaNativeModule</code>类和<code>NewJavaNativeModule</code>类，对应<code>Java</code>的<code>JavaModuleWrapper.java</code>，就是<code>jni</code>调用。</p>
<p>说到这里，现在只完成了<code>bridge</code>环境的初步搭建，把<code>jsbundle</code>扔到<code>jsc</code>里面，还没真正拉起<code>React Native</code>应用。还是回到上面那个<code>AsyncTask</code>的<code>onPostExecute</code>方法。看看执行完这么一大堆准备代码之后，是怎么拉起来整个应用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Result&lt;ReactApplicationContext&gt; result)</span> </span>&#123;</div><div class="line">      ....</div><div class="line">       setupReactContext(result.get());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupReactContext</span><span class="params">(ReactApplicationContext reactContext)</span> </span>&#123;</div><div class="line">    ...各种listener回调，通知birdge就绪，reactContext创建完成</div><div class="line">    <span class="keyword">for</span> (ReactRootView rootView : mAttachedRootViews) &#123;</div><div class="line">      attachMeasuredRootViewToInstance(rootView, catalystInstance);</div><div class="line">    &#125;</div><div class="line">    ...各种listener回调，通知birdge就绪，reactContext创建完成</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attachMeasuredRootViewToInstance</span><span class="params">(ReactRootView rootView,CatalystInstance catalystInstance)</span> </span>&#123;</div><div class="line">   ....</div><div class="line">    UIManagerModule uiManagerModule = catalystInstance.getNativeModule(UIManagerModule.class);</div><div class="line">    <span class="keyword">int</span> rootTag = uiManagerModule.addMeasuredRootView(rootView);</div><div class="line">    rootView.setRootViewTag(rootTag);</div><div class="line">    <span class="meta">@Nullable</span> Bundle launchOptions = rootView.getLaunchOptions();</div><div class="line">    WritableMap initialProps = Arguments.makeNativeMap(launchOptions);</div><div class="line">    String jsAppModuleName = rootView.getJSModuleName();</div><div class="line"></div><div class="line">    WritableNativeMap appParams = <span class="keyword">new</span> WritableNativeMap();</div><div class="line">    appParams.putDouble(<span class="string">"rootTag"</span>, rootTag);</div><div class="line">    appParams.putMap(<span class="string">"initialProps"</span>, initialProps);</div><div class="line">    <span class="comment">//真正拉起react native 的地方</span></div><div class="line">    catalystInstance.getJSModule(AppRegistry.class).runApplication(jsAppModuleName, appParams);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>再来详细说一下最后一句，（大量代码预警）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="keyword">public</span> &lt;T extends JavaScriptModule&gt; <span class="function">T <span class="title">getJSModule</span><span class="params">(ExecutorToken executorToken, Class&lt;T&gt; jsInterface)</span> </span>&#123;</div><div class="line">    <span class="comment">//进入JSModuleRegistry中</span></div><div class="line">    <span class="keyword">return</span> Assertions.assertNotNull(mJSModuleRegistry)</div><div class="line">        .getJavaScriptModule(<span class="keyword">this</span>, executorToken, jsInterface);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//JavaScriptModuleRegistry.java</span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T extends JavaScriptModule&gt; <span class="function">T <span class="title">getJavaScriptModule</span><span class="params">(</span></span></div><div class="line">    CatalystInstance instance,</div><div class="line">    ExecutorToken executorToken,</div><div class="line">    Class&lt;T&gt; moduleInterface) &#123;</div><div class="line">    HashMap&lt;Class&lt;? extends JavaScriptModule&gt;, JavaScriptModule&gt; instancesForContext =</div><div class="line">        mModuleInstances.get(executorToken);</div><div class="line">    <span class="keyword">if</span> (instancesForContext == <span class="keyword">null</span>) &#123;</div><div class="line">      instancesForContext = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">      <span class="comment">//缓存一下 方便后面再使用</span></div><div class="line">      mModuleInstances.put(executorToken, instancesForContext);</div><div class="line">    &#125;</div><div class="line">    JavaScriptModule <span class="keyword">module</span> = instancesForContext.get(moduleInterface);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">//命中缓存  直接返回</span></div><div class="line">      <span class="keyword">return</span> (T) <span class="keyword">module</span>;</div><div class="line">    &#125;</div><div class="line">    JavaScriptModuleRegistration registration =</div><div class="line">      ...</div><div class="line">      <span class="comment">//很明显 动态代理 重点关注JavaScriptModuleInvocationHandler的invoke方法</span></div><div class="line">    JavaScriptModule interfaceProxy = (JavaScriptModule) Proxy.newProxyInstance(</div><div class="line">        moduleInterface.getClassLoader(),</div><div class="line">        <span class="keyword">new</span> Class[]&#123;moduleInterface&#125;,</div><div class="line">        <span class="keyword">new</span> JavaScriptModuleInvocationHandler(executorToken, instance, registration));</div><div class="line">    instancesForContext.put(moduleInterface, interfaceProxy);</div><div class="line">    <span class="keyword">return</span> (T) interfaceProxy;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">      ....</div><div class="line">      <span class="comment">//又跑到了CatalystInstanceImpl.java中。。。然后又桥接到了CatalystInstanceImpl.cpp中，同样会调用instance的对应方法，直接看吧</span></div><div class="line">      mCatalystInstance.callFunction(</div><div class="line">        executorToken,</div><div class="line">        mModuleRegistration.getName(),</div><div class="line">        method.getName(),</div><div class="line">        jsArgs</div><div class="line">      );</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line"><span class="keyword">void</span> Instance::callJSFunction(ExecutorToken token, std::string&amp;&amp; <span class="keyword">module</span>, std::string&amp;&amp; method,</div><div class="line">                              folly::dynamic&amp;&amp; params) &#123;</div><div class="line">  callback_-&gt;incrementPendingJSCalls();<span class="comment">//这个回调不多说</span></div><div class="line">  <span class="comment">//....接着跟吧</span></div><div class="line">  nativeToJsBridge_-&gt;callFunction(token, std::move(<span class="keyword">module</span>), std::move(method), std::move(params));</div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">//又会进入executor-&gt;callFunction(module, method, arguments);</span></div><div class="line"><span class="keyword">void</span> JSCExecutor::callFunction(<span class="keyword">const</span> std::string&amp; moduleId, <span class="keyword">const</span> std::string&amp; methodId, <span class="keyword">const</span> folly::dynamic&amp; arguments) &#123;</div><div class="line">    ....</div><div class="line">  auto result = [&amp;] &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//被桥接到MessageQueue.js的callFunctionReturnFlushedQueue方法</span></div><div class="line">      <span class="keyword">return</span> m_callFunctionReturnFlushedQueueJS-&gt;callAsFunction(&#123;</div><div class="line">        Value(m_context, String::createExpectingAscii(moduleId)),</div><div class="line">        Value(m_context, String::createExpectingAscii(methodId)),</div><div class="line">        Value::fromDynamic(m_context, std::move(arguments))</div><div class="line">      &#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</div><div class="line">      std::throw_with_nested(</div><div class="line">        std::runtime_error(<span class="string">"Error calling function: "</span> + moduleId + <span class="string">":"</span> + methodId));</div><div class="line">    &#125;</div><div class="line">  &#125;();</div><div class="line">  <span class="comment">//顺便还会调用一下native的 这个会在后面再说一下</span></div><div class="line">  callNativeModules(std::move(result));</div><div class="line">&#125;</div><div class="line"></div><div class="line"> callFunctionReturnFlushedQueue(<span class="keyword">module</span>, method, args) &#123;</div><div class="line">        guard(() =&gt; &#123;</div><div class="line">            <span class="comment">//执行js的function</span></div><div class="line">            <span class="keyword">this</span>.__callFunction(<span class="keyword">module</span>, method, args);</div><div class="line">            <span class="keyword">this</span>.__callImmediates();</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//取出积攒在queue中的action返回给上面的，最终在java中执行</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.flushedQueue();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">__callFunction(<span class="keyword">module</span>: string, method: string, args: any) &#123;</div><div class="line">       ...</div><div class="line">       <span class="comment">//根据module名，方法名和参数执行js方法</span></div><div class="line">        <span class="keyword">const</span> result = moduleMethods[method].apply(moduleMethods, args);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//那什么时候把js的module注册到moduleMethods中呢</span></div><div class="line"><span class="comment">//AppRegistry.js</span></div><div class="line">BatchedBridge.registerCallableModule(</div><div class="line">  <span class="string">'AppRegistry'</span>,</div><div class="line">  AppRegistry</div><div class="line">);</div><div class="line"><span class="comment">//BatchedBridge是啥？</span></div><div class="line"><span class="keyword">const</span> BatchedBridge = <span class="keyword">new</span> MessageQueue(</div><div class="line">  () =&gt; global.__fbBatchedBridgeConfig,</div><div class="line">  serializeNativeParams</div><div class="line">);</div><div class="line">registerCallableModule(name, methods) &#123;</div><div class="line">        <span class="keyword">this</span>._callableModules[name] = methods;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里就执行了<code>AppRegistry.js</code>的的<code>runApplication</code>方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> runApplication: <span class="function"><span class="keyword">function</span>(<span class="params">appKey: string, appParameters: any</span>): <span class="title">void</span> </span>&#123;</div><div class="line">  ...</div><div class="line">   runnables[appKey].run(appParameters);</div><div class="line"> &#125;,</div><div class="line"> <span class="comment">//而runnables是在什么时候被添加的？？下面</span></div><div class="line"> </div><div class="line"> registerComponent: <span class="function"><span class="keyword">function</span>(<span class="params">appKey: string, getComponentFunc: ComponentProvider</span>): <span class="title">string</span> </span>&#123;</div><div class="line">   runnables[appKey] = &#123;</div><div class="line">     <span class="attr">run</span>: <span class="function">(<span class="params">appParameters</span>) =&gt;</span></div><div class="line">       renderApplication(getComponentFunc(), appParameters.initialProps, appParameters.rootTag)</div><div class="line">   &#125;;</div><div class="line">   <span class="keyword">return</span> appKey;</div><div class="line"> &#125;,</div><div class="line"><span class="comment">//而registerComponent什么时候被调用的就不用说了吧</span></div></pre></td></tr></table></figure></p>
<p>到此真正执行到了<code>js</code>脚本，开始执行<code>Component</code>的逻辑渲染，最终映射到<code>Native</code>的<code>View</code>上。后面会再详细说渲染的原理。同时会发现在 <code>JSCExecutor</code> 中每次 <code>Java</code> 调用 <code>JS</code> 之后会进行 <code>Java</code> 端的一个回调（从 <code>JS</code> 层的 <code>MessageQueue.js</code> 中获得累积的 <code>JS Call</code>）。</p>
<h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h3><p>上面关于<code>java</code>-&gt;<code>js</code>已经体现的差不多了，实质就是 <code>Java</code> 与 <code>JS</code> 端都准备好一个 <code>Module</code> 映射表，然后当 <code>Java</code> 端调用 <code>JS</code> 代码时 <code>Java</code> 端通过查表动态代理创建一个与 JS 对应的 <code>Module</code> 对象，当调用这个 <code>Module</code> 的方法时 Java 端通过动态代理的 <code>invoke</code> 方法触发 <code>C++</code> 层，层层调用后通过 <code>JSCExecutor</code> 执行 <code>JS</code> 端队列中的映射查表找到 <code>JS</code> 端方法进行调用；<code>js</code>-&gt;<code>java</code>的调用会在渲染原理里面提到。</p>
<p>简单画了个图<br><img src="/images/init.png" alt="init"></p>
<p>btw:看完js-&gt;java原理之后，会发现其实所谓的双向通信，其实基本上(除了那个直接调用的java之外)都是<code>java</code>调用。这也体现了消息机制的两种实现方式，推和拉。推方式就是直接调用对应的方法，也可以理解为经典的观察者模式。而RN通信更像拉这种模式。双边的通信都是靠<code>java</code>端去拉队列中的<code>action</code>。拉比推有一个优势，就是可以解决背压的问题，不必去解决或者协调生产者生产事件的速度，而是根据消费者的速度去消费事件，而且这个消费的过程还是可以优化的，例如去压缩合并一些事件，一次执行。</p>
<h3 id="渲染原理"><a href="#渲染原理" class="headerlink" title="渲染原理"></a>渲染原理</h3><p>现在以一个<code>Image</code>如何渲染到<code>Native</code>为例，说一下简单的流程。<br>当执行<code>js</code>的脚本时候，是不知道<code>nativeModule</code>的注册表的，因为<code>nativeModule</code>的注册表只保存在<code>java</code>和<code>cpp</code>端，并没有直接传递到<code>js</code>端。所有当执行到</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    Image,</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div></pre></td></tr></table></figure>
<p>这时候<code>js</code>并不知道<code>Image</code>是什么，然后看一下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">const ReactNative = &#123;</div><div class="line">    ...</div><div class="line">    get Image() &#123; return require(&apos;Image&apos;); &#125;,</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">...</div><div class="line">module.exports = ReactNative;</div><div class="line"></div><div class="line">//Image.android.js</div><div class="line"></div><div class="line">var NativeModules = require(&apos;NativeModules&apos;);</div><div class="line"></div><div class="line">//NativeModules.js</div><div class="line"></div><div class="line">const NativeModules = &#123;&#125;;</div><div class="line">Object.keys(RemoteModules).forEach((moduleName) =&gt; &#123;</div><div class="line">  Object.defineProperty(NativeModules, moduleName, &#123;</div><div class="line">    configurable: true,</div><div class="line">    enumerable: true,</div><div class="line">    get: () =&gt; &#123;</div><div class="line">      let module = RemoteModules[moduleName];</div><div class="line">      if (module &amp;&amp; typeof module.moduleID === &apos;number&apos; &amp;&amp; global.nativeRequireModuleConfig) &#123;</div><div class="line">      //nativeRequireModuleConfig映射到JSCExecutor.cpp</div><div class="line">        const config = global.nativeRequireModuleConfig(moduleName);</div><div class="line">        module = config &amp;&amp; BatchedBridge.processModuleConfig(config, module.moduleID);</div><div class="line">        RemoteModules[moduleName] = module;</div><div class="line">      &#125;</div><div class="line">      Object.defineProperty(NativeModules, moduleName, &#123;</div><div class="line">        configurable: true,</div><div class="line">        enumerable: true,</div><div class="line">        value: module,</div><div class="line">      &#125;);</div><div class="line">      return module;</div><div class="line">    &#125;,</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = NativeModules;</div><div class="line"></div><div class="line">//cpp</div><div class="line">JSCExecutor::nativeRequireModuleConfig-&gt;JsToNativeBridge::getModuleConfig-&gt;ModuleRegistry::getConfig</div><div class="line"></div><div class="line">folly::dynamic ModuleRegistry::getConfig(const std::string&amp; name) &#123;</div><div class="line"></div><div class="line">...</div><div class="line">  NativeModule* module = modules_[it-&gt;second].get();</div><div class="line">...</div><div class="line">  //最终反射调用JavaModuleWrapper.java的getConstants</div><div class="line">  folly::dynamic constants = module-&gt;getConstants();</div><div class="line">...</div><div class="line">  //最终反射调用JavaModuleWrapper.java的getMethods</div><div class="line">  //返回对应module中所有@ReactMethod注解的方法</div><div class="line">  std::vector&lt;MethodDescriptor&gt; methods = module-&gt;getMethods();</div><div class="line">  </div><div class="line">//modules_在哪赋值？</div><div class="line">//ModuleRegistryHolder.cpp构造函数,这个类上面有提到，回去看看</div><div class="line">//registry_ = std::make_shared&lt;ModuleRegistry&gt;(std::move(modules));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后返回到<code>NativeModules.js</code>中，<code>BatchedBridge.processModuleConfig</code><br>-&gt;<code>_genModule</code>-&gt;<code>_genMethod</code>。进一步处理一下。所以到现在，<code>js</code>获取到了<code>Image</code>这个<code>module</code>中所有方法和属性。</p>
<p>然后当调用<code>Image</code>中相关方法时候，其实就是调用上面<code>_genMethod</code>中的方法，在这个方法中，分<code>promise</code>，<code>sync</code>，<code>其他</code>调用类型，最终都是调用了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">__nativeCall(module, method, params, onFail, onSucc) &#123;</div><div class="line">...</div><div class="line">        this._queue[MODULE_IDS].push(module);</div><div class="line">        this._queue[METHOD_IDS].push(method);</div><div class="line">        this._queue[PARAMS].push(preparedParams);</div><div class="line">...</div><div class="line">//如果5ms内有多个方法调用就先待在队列里防止过高频率，否则调用C++的nativeFlushQueueImmediate方法</div><div class="line"> if (global.nativeFlushQueueImmediate &amp;&amp;</div><div class="line">        now - this._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS) &#123;</div><div class="line">      global.nativeFlushQueueImmediate(this._queue);</div><div class="line">      this._queue = [[], [], [], this._callID];</div><div class="line">      this._lastFlush = now;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面把<code>MODULE_IDS</code>，<code>METHOD_IDS</code>，<code>PARAMS</code>放到<code>queue</code>中，等待<code>java</code>的调用，至于什么时候会触发<code>java</code>的调用和为什么要这么设计，会在下面的事件驱动解释。调用<code>JSCExecutor::flush()</code>。还有就是直接调用<code>cpp</code>的<code>nativeFlushQueueImmediate</code>，最终这两种方式都是调用了<code>callNativeModules</code>，这个上面也说了，不再赘述啦。</p>
<p>下面再说一下<code>Native</code>的<code>view</code>创建过程，这个过程中<code>View</code>的<code>tag</code>起标记<code>View</code>的作用，从<code>java</code>拉起<code>React Native</code>的<code>attachMeasuredRootViewToInstance</code>方法中可以看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">appParams.putDouble(<span class="string">"rootTag"</span>, rootTag);</div><div class="line">appParams.putMap(<span class="string">"initialProps"</span>, initialProps);</div></pre></td></tr></table></figure>
<p>把<code>rootTag</code>通过<code>bridge</code>带到了<code>js</code>端，<code>js</code>执行<code>React</code>逻辑后，要创建一个<code>Native</code>的<code>View</code>,同时也把这个<code>rootTag</code>带到<code>java</code>层，让<code>java</code>层知道，创建完一个<code>View</code>要添加到哪个根布局上。</p>
<p>这个<code>rootTag</code>的生成是有规则的，在<code>UIManagerModule.addMeasuredRootView</code>的时候会生成<code>RootViewTag</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> tag = mNextRootViewTag;<span class="comment">//默认是1</span></div><div class="line">mNextRootViewTag += ROOT_VIEW_TAG_INCREMENT;<span class="comment">//10</span></div></pre></td></tr></table></figure>
<p>也就是默认的<code>rootTag</code>是1，后面每多创建一个+10,也就是类似<code>1，11，21</code>这样都是根布局的<code>tag</code>。</p>
<p>再通过这个<code>rootTag</code>在<code>js</code>的传递简单说一下<code>React.js</code>的创建组件逻辑。从前面可以知道，拉起<code>js</code>后执行<code>AppRegistry.js ::runApplication</code>，进而执行到了<code>renderApplication(getComponentFunc(), appParameters.initialProps, appParameters.rootTag)</code>这个方法。这里可以看到从<code>java</code>传过来的两个参数，其中一个就是<code>rootTag</code>，这里默认就一个根布局，这里的<code>rootTag==1</code>，进而到了<code>renderApplication.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ReactNative.render(</div><div class="line">   &lt;AppContainer&gt;</div><div class="line">     &lt;RootComponent</div><div class="line">       &#123;...initialProps&#125;</div><div class="line">       rootTag=&#123;rootTag&#125;</div><div class="line">     /&gt;</div><div class="line">   &lt;/AppContainer&gt;,</div><div class="line">   rootTag</div><div class="line"> );</div></pre></td></tr></table></figure>
<p>这里的<code>AppContainer</code>也是一个组件，是包裹在根布局的外面，用于<code>debug</code>的红盒等工具布局。再到了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ReactNative.js</span></div><div class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params">element, mountInto, callback</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> ReactNativeMount.renderComponent(element, mountInto, callback);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里面的逻辑快到<code>React</code>的一些处理，这里不多赘述，其实还有很多关于<code>React Native</code>的处理，暂时忽略，分支太多太繁琐。简单说一下<code>React Native</code>组件可以分为两种</p>
<blockquote>
<p>元组件：框架内置的，可以直接使用的组件。例如：View、Image等。它在React Native中用ReactNativeBaseComponent来描述。<br>复合组件：用户封装的组件，一般可以通过React.createClass()来构建，提供render()方法来返回渲染目标。它在React Native中用ReactCompositeComponent来描述。</p>
</blockquote>
<p>具体组合的逻辑基本都在上面连个类里面。下面来到<code>ReactNativeBaseComponent.js</code>的<code>mountComponent</code>，根据上面的提示是可以跟到这里的。只挑简单的看，看这个方法里面的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var tag = ReactNativeTagHandles.allocateTag();<span class="comment">//给每个view生成一个唯一的tag</span></div><div class="line">...</div><div class="line">UIManager.createView(tag, <span class="keyword">this</span>.viewConfig.uiViewClassName, nativeTopRootTag, updatePayload);</div><div class="line"></div><div class="line"><span class="comment">//ReactNativeTagHandles.js</span></div><div class="line">allocateTag: function () &#123;</div><div class="line">    <span class="comment">//排除已经给分配给rootTag的  类似1，11，21</span></div><div class="line">    <span class="comment">//下面的就是简单的自增，初始化是1</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.reactTagIsNativeTopRootID(ReactNativeTagHandles.tagCount)) &#123;</div><div class="line">      ReactNativeTagHandles.tagCount++;</div><div class="line">    &#125;</div><div class="line">    var tag = ReactNativeTagHandles.tagCount;</div><div class="line">    ReactNativeTagHandles.tagCount++;</div><div class="line">    <span class="keyword">return</span> tag;</div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
<p>看名字也知道这里就到了创建<code>View</code>的地方，还有另外两个方法和这个差不多的，用来操作<code>View</code>,分别的<code>updateView</code>，<code>manageChildren</code>，<code>UIManager</code>通过<code>bridge</code>可以映射到<code>java</code>的<code>UIManagerModule.java</code>，可以在duiyiing这个类里面找到对应的用<code>@ReactMethod</code>注解的方法，这个注解是干啥的，看上面有提到。这里只看<code>createView</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ReactMethod</span></div><div class="line"> <span class="comment">//创建view的tag,对应native的组件类名，要加入的根布局tag,创建view需要的参数</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createView</span><span class="params">(<span class="keyword">int</span> tag, String className, <span class="keyword">int</span> rootViewTag, ReadableMap props)</span> </span>&#123;</div><div class="line">   mUIImplementation.createView(tag, className, rootViewTag, props);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在<code>UIImplementation.java</code>中把要创建的<code>view</code>包装成<code>CSSNode</code>，用于后面的在<code>CssLayout</code>中布局。然后会包装成一个<code>CreateViewOperation</code>加入到<code>UIViewOperationQueue.java</code>的<code>ArrayDeque&lt;UIOperation&gt; mNonBatchedOperations</code>这个队列中。最后还是通过<code>GuardedChoreographerFrameCallback</code>这个垂直同步的回调中出队，执行。关于事件驱动还是看下面。还有 <code>updateview</code> <code>setchilderen</code>就不说了，很复杂。</p>
<h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>在说<code>React Native</code>的事件驱动之前，先看一下这几篇<br><a href="http://www.jianshu.com/p/424918260fa9" target="_blank" rel="external">Android图形显示系统（一）</a><br><a href="http://www.jianshu.com/p/154c4fb85641" target="_blank" rel="external">React Native 分析（二）事件驱动</a><br><a href="http://www.jianshu.com/p/c046fcd125d2" target="_blank" rel="external">Android中的SurfaceFlinger和Choreographer</a><br>了解一下垂直同步和在<code>Android</code>上的<code>Choreographer</code>，正因为<code>React Native</code>使用了<code>Choreographer</code>这个类，而这个类是在4.1加入的，所以<code>RN-Android</code>的最低兼容是4.1，而<code>weex</code>是最低兼容到4.0，是在4.0使用了<code>handler</code>延时来模拟垂直同步的效果。当然这也是老版本<code>Android</code>的做法。这也是为啥总是吐槽<code>Android</code>显得很卡，当然在5.0又引入了<code>renderThread</code>就更上了一个台阶，还有<code>Android</code>的属性动画也是靠这个驱动的。</p>
<p>下面简单贴一下<code>Choreographer</code>的注释，看看为啥跨平台的框架都会用到这个类</p>
<blockquote>
<p>However, there are a few cases where you might want to use the functions of thechoreographer directly in your application.  Here are some examples.<br> <li>If your application does its rendering in a different thread, possibly using GL,or does not use the animation framework or view hierarchy at all and you want to ensure that it is appropriately synchronized with the display, then use<br> {@link Choreographer#postFrameCallback}.</li><br> <li>… and that’s about it.</li><br> Each {@link Looper} thread has its own choreographer.  Other threads can post callbacks to run on the choreographer but they will run on the {@link Looper}to which the choreographer belongs.</p>
</blockquote>
<p>再看一下<code>postFrameCallback</code>注释</p>
<blockquote>
<p>Posts a frame callback to run on the next frame.The callback runs once then is automatically removed.</p>
</blockquote>
<p>在<code>React Native</code>的使用主要在<code>EventDispatcher</code>的内部类<code>private class ScheduleDispatchFrameCallback implements Choreographer.FrameCallback</code>和<code>ReactChoreographer</code>与它的内部类<code>private class ReactChoreographerDispatcher implements Choreographer.FrameCallback</code>，还有用于<code>view</code>或者动画的就不说了。</p>
<p>现在举个例子，点击一下<code>view</code>，这个事件是怎么传递的，点击事件肯定发生在<code>java</code>端。在<code>ReactRootView</code>的<code>dispatchJSTouchEvent</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">  EventDispatcher eventDispatcher = reactContext.getNativeModule(UIManagerModule.class)</div><div class="line">      .getEventDispatcher();</div><div class="line">    mJSTouchDispatcher.handleTouchEvent(event, eventDispatcher);</div><div class="line">    </div><div class="line">//JSTouchDispatcher.java</div><div class="line">  public void handleTouchEvent(MotionEvent ev, EventDispatcher eventDispatcher) &#123;</div><div class="line">    //这里面分为down,up move 等事件类别</div><div class="line">    </div><div class="line">     mTargetTag = TouchTargetHelper.findTargetTagAndCoordinatesForTouch(</div><div class="line">        ev.getX(),</div><div class="line">        ev.getY(),</div><div class="line">        mRootViewGroup,</div><div class="line">        mTargetCoordinates,</div><div class="line">        null);</div><div class="line">      eventDispatcher.dispatchEvent(</div><div class="line">        TouchEvent.obtain(</div><div class="line">          mTargetTag,</div><div class="line">          TouchEventType.START,</div><div class="line">          ev,</div><div class="line">          mGestureStartTime,</div><div class="line">          mTargetCoordinates[0],</div><div class="line">          mTargetCoordinates[1],</div><div class="line">          mTouchEventCoalescingKeyHelper));</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终包装成一个<code>TouchEvent</code>调用<code>eventDispatcher.dispatchEvent</code>,这里面主要是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mEventStaging.add(event);<span class="comment">//ArrayList&lt;Event&gt;</span></div></pre></td></tr></table></figure>
<p>把事件添加到一个待发送的列表里面。那什么是去处发送？是在<code>ScheduleDispatchFrameCallback.doFrame</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">  ....</div><div class="line">    moveStagedEventsToDispatchQueue();</div><div class="line">  ...</div><div class="line">     mReactContext.runOnJSQueueThread(mDispatchEventsRunnable);</div><div class="line">  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用<code>moveStagedEventsToDispatchQueue</code>在这个方法里面会对<code>event</code>再做一些处理，例如压缩，合并事件等，然后又把处理完的事件放到<code>Event[] mEventsToDispatch = new Event[16];</code>中。而在<code>DispatchEventsRunnable</code>的<code>run</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> eventIdx = <span class="number">0</span>; eventIdx &lt; mEventsToDispatchSize; eventIdx++) &#123;</div><div class="line">            Event event = mEventsToDispatch[eventIdx];</div><div class="line">            ....</div><div class="line">            event.dispatch(mRCTEventEmitter);</div><div class="line">            event.dispose();</div><div class="line">            ...</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">-&gt;TouchEvent.dispatch-&gt;TouchesHelper.sendTouchEvent-&gt;rctEventEmitter.receiveTouches(</div><div class="line">        type.getJSEventName(),</div><div class="line">        pointers,</div><div class="line">        changedIndices);</div></pre></td></tr></table></figure>
<p>而<code>RCTEventEmitter extends JavaScriptModule</code>这个就是走上面的<code>java-&gt;js</code>的路子，动态代理-&gt;<code>cpp</code>-&gt;<code>flush()</code>-&gt;….</p>
<p>简单点就是<code>getJSModule</code>后对js的方法调用都会触发上面<code>MessageQueue.js</code>的出队</p>
<p><img src="/images/eventloop.png" alt="eventloop"></p>
<h2 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h2><p>这里简单说说<code>React Native</code>的<code>js引擎</code>选择，都是<code>webkit</code>的<code>JSC</code>,在<code>iOS</code>上是内置的，在<code>Android</code>上则是引入了一个完整的<code>JSC</code>，这也是为什么<code>Android</code>的<code>RN</code>会大这么多的很重要的原因，至于为什么要引入一个完整的<code>JSC</code>而不是使用内置的<code>js</code>引擎，<code>Android 4.4</code>之前的<code>android</code>系统浏览器内核是<code>WebKit</code>，<code>Android4.4</code>系统浏览器切换到了<code>Chromium</code>(内核是<code>Webkit</code>的分支<code>Blink</code>)。在<code>Android</code>平台已经启用V8作为JS引擎，<code>Android 4.0</code>以后只用到了<code>JavaScriptCore</code>中的WTF（Web Template Library）部分代码。</p>
<p>至于为啥不都使用<code>V8</code>,这个都是<code>iOS</code>的锅，看看<code>chrome</code>在<code>iOS</code>上就是个<code>WebView</code>套个壳。。。</p>
<p>还有其他的跨平台框架，例如<code>weex</code>,在<code>Android</code>上使用的是<code>V8</code>。现在网上也有对<code>RN</code>在<code>Android</code>上移植的<code>V8</code>版本。<br><a href="https://github.com/onesubone/react-native-android-v8/tree/0.46.4-v8" target="_blank" rel="external">onesubone/react-native-android-v8</a><br><a href="http://tsinstudio.github.io/media/React-Native-Meets-V8/" target="_blank" rel="external">React Native Android V8接入</a><br>这个是基于0.46的版本，还是可以跑起来的，但是<code>RN</code>的速度瓶颈貌似并不在<code>js引擎</code>。。</p>
<p>还有一点要吐槽就是每个<code>jsbundle</code>都包含了框架代码和业务代码，导致文件的有效利用率很低，看看隔壁的<code>weex</code>就做的很好，框架<code>js</code>代码直接包含在<code>sdk</code>中，只下发业务代码，这才是正常的做法。在<code>RN</code>这只能自己<code>hook</code>了。还有就是每个<code>RN</code>页面都是要重新初始化Bridge,但是这些bridge其实都是基本一样的，只需要把不同的<code>jsbundle</code>扔给<code>JSC</code>就好了，我测试了一下大概会快20%，但是因为缓存，也会造成一些内存泄露的问题(业务代码和具体页面过于绑定)。但是有时候甚至比重新初始化还慢，不知道为啥。。</p>
<p>最后再贴一下简单画的思维导图吧<br><a href="https://www.processon.com/view/link/599c14b8e4b0f2c6342a4f04" target="_blank" rel="external">思维导图在线地址</a><br><img src="/images/React Native启动.png" alt="React Native启动"></p>
<p>参考：</p>
<p><a href="https://github.com/facebook/react-native" target="_blank" rel="external">facebook/react-native</a><br><a href="http://blog.csdn.net/yanbober/article/details/53157456" target="_blank" rel="external"> React Native Android 源码框架浅析（主流程及 Java 与 JS 双边通信）</a><br><a href="https://github.com/guoxiaoxing/react-native" target="_blank" rel="external">ReactNative源码篇</a><br><a href="http://www.jianshu.com/u/640de10b6744" target="_blank" rel="external">吟游雪人</a></p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps:"></a>ps:</h2><p>因为本人能力实在有限，上面很多都是连蒙带猜，算是个笔记性质的流水账，有用就看看，没用就算了,欢迎指出错误。</p>
<h3 id="pps"><a href="#pps" class="headerlink" title="pps"></a>pps</h3><p>这篇本该在两星期之前完成的工作，一直拖到了现在。(<del>一是因为懒</del>)，二是因为不知道该怎么更好的表述出来，因为一直贴代码体验实在是不好。（<del>虽然现在还是这样的，但是源码分析的不贴代码怎么写</del>）。但是感觉再不写点出来，过段时间又忘了，索性写出来算了，也不管效果了。。。凑合看吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;(源码版本：0.34，新版本(0.48)基本流程是不变的，建议跟着源码看看，哪个版本的倒影响不大)&lt;br&gt;这篇简单刨析一下&lt;code&gt;React Native&lt;/code&gt;是怎么在&lt;code&gt;Android&lt;/code&gt;上跑起来的，会从下面几个方面说说。
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://yoursite.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>Fragment启动生命周期</title>
    <link href="http://yoursite.com/2017/09/08/Fragment%E5%90%AF%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2017/09/08/Fragment启动生命周期/</id>
    <published>2017-09-08T15:03:32.000Z</published>
    <updated>2017-09-10T03:40:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>源码版本：26.0.0-beta1</strong></p>
<p>Fragment 的生命周期是依赖Activity的，假设在Activity的onCreate中有如下代码，<a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SearchFragment searchFragment = <span class="keyword">new</span> SearchFragment();</div><div class="line">       getSupportFragmentManager().beginTransaction()</div><div class="line">               .replace(R.id.container, searchFragment)</div><div class="line">               .commitAllowingStateLoss();</div></pre></td></tr></table></figure></p>
<p>探究一下Fragment的生命周期是如何依附的。</p>
<p>思维导图</p>
<p><img src="/images/Fragment启动生命周期.png" alt="Fragment启动生命周期"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;源码版本：26.0.0-beta1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fragment 的生命周期是依赖Activity的，假设在Activity的onCreate中有如下代码，
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>LifecycleComponents问答</title>
    <link href="http://yoursite.com/2017/09/08/LifecycleComponents%E9%97%AE%E7%AD%94/"/>
    <id>http://yoursite.com/2017/09/08/LifecycleComponents问答/</id>
    <published>2017-09-08T15:00:06.000Z</published>
    <updated>2017-09-08T15:00:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么不直接使用ActivityLifecycleCallbacks而是使用一个non-UI-fragment-ReportFragment？"><a href="#为什么不直接使用ActivityLifecycleCallbacks而是使用一个non-UI-fragment-ReportFragment？" class="headerlink" title="为什么不直接使用ActivityLifecycleCallbacks而是使用一个non-UI fragment ReportFragment？"></a>为什么不直接使用<code>ActivityLifecycleCallbacks</code>而是使用一个<code>non-UI fragment ReportFragment</code>？<a id="more"></a></h4><p>因为在”创建”生命周期方法中(<code>onCreate</code>,<code>onStart</code>)，<code>ActivityLifecycleCallbacks</code>中方法调用是在<code>Activity</code>的生命周期方法之前。在”销毁”生命周期方法中(<code>onStop</code>,<code>onDestroy</code>),<code>ActivityLifecycleCallbacks</code>中方法调用是在<code>Activity</code>的生命周期方法之后。正常去订阅这里的生命周期，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_CREATE)</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ON_CREATE</span><span class="params">()</span> </span>&#123;</div><div class="line">                Log.e(MyObserver, <span class="string">"ON_CREATE"</span>);</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>更多的希望是在<code>Activity</code>的<code>onCreate</code>执行完成之后，而订阅<code>Lifecycle.Event.ON_DESTROY</code>则更希望在<code>Activity</code>的<code>onDestroy</code>之前。所有在<code>ActivityLifecycleCallbacks</code>中直接分发生命周期是不合适的。还要注意一下，在注册<code>ReportFragment</code>时候使用的是<code>manager.executePendingTransactions();</code>而不是常见的<code>commit</code>，是为了马上执行，更准确的去分发生命周期。通过这种方式，最终的生命周期类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建时</span></div><div class="line">ActivityLifecycleCallbacks.onActivityCreated-&gt;Activity.onCreate-&gt;ReportFragment.onActivityCreated-&gt;LifecycleObserver.ON_CREATE</div><div class="line"><span class="comment">//销毁时</span></div><div class="line">ReportFragment.onDestroy-&gt;LifecycleObserver.ON_DESTROY-&gt;Activity.onDestroy-&gt;ActivityLifecycleCallbacks.onActivityDestroyed</div></pre></td></tr></table></figure>
<p>上面是在<code>LifecycleActivity</code>中使用<code>getLifecycle().addObserver</code>的生命周期分发走向。<br>同理，在<code>LifecycleFragment</code>中<code>getLifecycle().addObserver</code>时， <code>FragmentCallback</code>和<code>DestructionReportFragment</code>也是完成类似上面<code>ActivityLifecycleCallbacks</code>和<code>ReportFragment</code>的工作。总结就是将<code>LifecycleObserver</code>的生命周期进一步限制在跟踪的<code>LifecycleRegistryOwner</code>生命周期范围之内。</p>
<h4 id="ProcessLifecycleOwner的作用？"><a href="#ProcessLifecycleOwner的作用？" class="headerlink" title="ProcessLifecycleOwner的作用？"></a><code>ProcessLifecycleOwner</code>的作用？</h4><p>在<code>LifecycleRuntimeTrojanProvider</code>中有两个类进行了初始化，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LifecycleDispatcher.init(getContext());</div><div class="line">ProcessLifecycleOwner.init(getContext());</div></pre></td></tr></table></figure>
<p>第一个是为每个组件进行生命周期分发，例如<code>Activity</code>,<code>Fragment</code>。<code>ProcessLifecycleOwner</code>则是为整个app进程的生命周期进行分发，例如使用<code>ProcessLifecycleOwner.get().getLifecycle().addObserver();</code>就可以监控整个进程的生命周期。注意一点，在销毁时，最多只会分发到<code>ON_STOP</code>，而没有<code>ON_DESTROY</code>事件。</p>
<p>更多分析可以看这篇 <a href="http://chaosleong.github.io/2017/05/27/How-Lifecycle-aware-Components-actually-works/" target="_blank" rel="external">Lifecycle-aware Components 源码分析</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;为什么不直接使用ActivityLifecycleCallbacks而是使用一个non-UI-fragment-ReportFragment？&quot;&gt;&lt;a href=&quot;#为什么不直接使用ActivityLifecycleCallbacks而是使用一个non-UI-fragment-ReportFragment？&quot; class=&quot;headerlink&quot; title=&quot;为什么不直接使用ActivityLifecycleCallbacks而是使用一个non-UI fragment ReportFragment？&quot;&gt;&lt;/a&gt;为什么不直接使用&lt;code&gt;ActivityLifecycleCallbacks&lt;/code&gt;而是使用一个&lt;code&gt;non-UI fragment ReportFragment&lt;/code&gt;？
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Fragment Can not perform this action after onSaveInstanceState</title>
    <link href="http://yoursite.com/2017/09/08/onSaveInstanceState/"/>
    <id>http://yoursite.com/2017/09/08/onSaveInstanceState/</id>
    <published>2017-09-08T14:59:09.000Z</published>
    <updated>2017-09-10T13:16:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了这个异常，记录一下解决办法。<a id="more"></a></p>
<p>首先看一下这个异常是从哪里抛出来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//FragmentManager</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueAction</span><span class="params">(OpGenerator action, <span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (!allowStateLoss) &#123;</div><div class="line">           checkStateLoss();</div><div class="line">       &#125;</div><div class="line">       ....</div><div class="line">   &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkStateLoss</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (mStateSaved) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                   <span class="string">"Can not perform this action after onSaveInstanceState"</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (mNoTransactionsBecause != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                   <span class="string">"Can not perform this action inside of "</span> + mNoTransactionsBecause);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>也就是在对fragment进行commit的时候，如果这时候<code>mStateSaved</code>那就会抛出这个异常，而<code>mStateSaved</code>是在<code>saveAllState</code>也就是<code>onSaveInstanceState</code>和<code>dispatchStop</code>也就是<code>Activity::onStop</code>中。也就是说如果在这两个生命周期方法之中或者之后对<code>Fragment</code>进行<code>Commit</code>就会出现这个异常。特别是<code>DialogFragment</code>，一般的<code>Fragment</code>还可以使用<code>commitAllowingStateLoss</code>来进行”丑陋的”避免，而<code>DialogFragment</code>的默认<code>show</code>方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(FragmentManager manager, String tag)</span> </span>&#123;</div><div class="line">        mDismissed = <span class="keyword">false</span>;</div><div class="line">        mShownByMe = <span class="keyword">true</span>;</div><div class="line">        FragmentTransaction ft = manager.beginTransaction();</div><div class="line">        ft.add(<span class="keyword">this</span>, tag);</div><div class="line">        ft.commit();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>根本不给机会。</p>
<p>上面说到抛出这个异常的原因，引申出什么情况下容易出现这种情况，就是异步回调的时候进行<code>commit</code>。因为这个时候你无法知道当前的状态，碰巧这个时候应用进入后台，执行了<code>onStop</code>或者被杀死<code>onSaveInstanceState</code>,就挂了。使用<code>Fragment</code>有好处，就是比<code>Activity</code>轻，跳转不用进行IPC。但是真的不怎么好用，到处的坑。再说这里，例如使用<code>MVP</code>，在<code>onDestroyView</code>对<code>View</code>进行清空，(这个是在<code>Activity</code>的<code>onDestroy</code>调用)，也就是在这之前对<code>View</code>操作都是安全的，但是<code>Fragment</code>在<code>onStop</code>之后就不能再进行<code>commit</code>了。使用<code>View==null</code>判断根本不行，真的防不胜防🤣🤣🤣。</p>
<p>解决办法：<br><a href="http://www.jianshu.com/p/d9143a92ad94" target="_blank" rel="external">Fragment全解析系列（一）：那些年踩过的坑</a>。至于为什么前面说<code>commitAllowingStateLoss</code>是个”丑陋”的解决办法，这里有更详细的说明<a href="http://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html" target="_blank" rel="external">Fragment Transactions &amp; Activity State Loss</a>，早在13年就提及这个问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到了这个异常，记录一下解决办法。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2线程切换流程</title>
    <link href="http://yoursite.com/2017/09/08/RxJava2%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/09/08/RxJava2线程切换流程/</id>
    <published>2017-09-08T14:57:26.000Z</published>
    <updated>2017-09-08T14:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下面代码为例：<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"HELLO WORLD"</span>)</div><div class="line">          .map(<span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(@NonNull String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                  s = s.toLowerCase();</div><div class="line">                  <span class="keyword">return</span> s;</div><div class="line">              &#125;</div><div class="line">          &#125;)</div><div class="line">          .subscribeOn(Schedulers.computation())</div><div class="line">          .map(<span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</div><div class="line"></div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                  s = s + <span class="string">"map"</span>;</div><div class="line">                  <span class="keyword">return</span> s;</div><div class="line">              &#125;</div><div class="line">          &#125;)</div><div class="line">          .observeOn(Schedulers.newThread())</div><div class="line">          .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</div><div class="line">              <span class="meta">@Override</span></div><div class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(@NonNull String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                  System.out.println(s);</div><div class="line">              &#125;</div><div class="line">          &#125;);</div></pre></td></tr></table></figure>
<p>简单分析一下代码执行流程</p>
<ol>
<li>从上到下，建立上下依赖关系，初始化线程</li>
<li>从<code>.subscribe</code>为调用起点，自下向上开始准备调用，这个过程<code>subscribeOn</code>起作用，<code>observeOn</code>不起切换线程作用。</li>
<li>从上到下执行，类似<code>map</code>中的代码，这时候<code>observeOn</code>起切换线程作用。</li>
</ol>
<p>调用流程简化如下：<br><img src="http://static.zybuluo.com/70kg/hipkw6etxfxnmpr0mzu2mujc/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-05%20%E4%B8%8B%E5%8D%884.18.45.png" alt="屏幕快照 2017-09-05 下午4.18.45.png-163.6kB"></p>
<p> 涉及的相关类：<br> <img src="http://static.zybuluo.com/70kg/br63lmpohxuoccg3fxgoy0zz/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-05%20%E4%B8%8B%E5%8D%884.26.43.png" alt="屏幕快照 2017-09-05 下午4.26.43.png-100kB"></p>
<p> 这也是为什么<code>subscribeOn</code>只有第一次起作用，<code>observeOn</code>每次都起作用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下面代码为例：
    
    </summary>
    
    
      <category term="RxJava" scheme="http://yoursite.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Handler</title>
    <link href="http://yoursite.com/2017/07/07/Handler/"/>
    <id>http://yoursite.com/2017/07/07/Handler/</id>
    <published>2017-07-07T00:28:33.000Z</published>
    <updated>2017-07-08T06:59:13.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="sendMessage的message保存在哪？"><a href="#sendMessage的message保存在哪？" class="headerlink" title="sendMessage的message保存在哪？"></a><code>sendMessage</code>的<code>message</code>保存在哪？</h4><p>保存在<code>MessageQueue</code>的<code>Message mMessages</code>成员变量中，通过<code>message</code>中的<code>next</code>维护一个单向链表。<code>message</code>本身一直在java层，和<code>native</code>的message没有直接操作关系。<code>looper</code>分发的消息都是通过<code>messagequeue.mMessages</code>间接获取的。当<code>sendMessage</code>时，进入<code>messagequeue</code>的<code>enqueueMessage</code>方法，<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Message p = mMessages;</div><div class="line">           <span class="keyword">boolean</span> needWake;</div><div class="line">           <span class="comment">//代表MessageQueue没有消息，或者msg的触发时间是队列中最早的</span></div><div class="line">           <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">               <span class="comment">// New head, wake up the event queue if blocked.</span></div><div class="line">               msg.next = p;</div><div class="line">               mMessages = msg;</div><div class="line">               <span class="comment">//mBlocked在空消息为true</span></div><div class="line">               needWake = mBlocked;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake up the event queue unless there is a barrier at the head of the queue and the message is the earliest asynchronous message in the queue.</span></div><div class="line">               needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">               Message prev;</div><div class="line">               <span class="comment">//遍历mMessages  找到合适位置插入msg</span></div><div class="line">               <span class="keyword">for</span> (;;) &#123;</div><div class="line">                   prev = p;</div><div class="line">                   p = p.next;</div><div class="line">                   <span class="comment">//当p==null 说明是链表的最后一个的next 要将msg插入到链表的最后，当when &lt; p.when说明后面还有时间没到的在排队，插入到这些的前面</span></div><div class="line">                   <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                       needWake = <span class="keyword">false</span>;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">               prev.next = msg;</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<p>接受消息在<code>messagequeue.next()</code>中，<code>nativePollOnce(ptr, nextPollTimeoutMillis);</code>方法是陷入到<code>native</code>层，一般<code>nextPollTimeoutMillis</code>都为0，说明要马上处理<code>message</code>，就会执行下面的语句。当没有消息时，<code>nextPollTimeoutMillis</code>为-1，表示无限阻塞，直到mEpollFd所监控的文件描述符发生了要监控的IO事件后或者监控时间超时后，线程就从epoll_wait返回了，也就会执行下面的操作，说明有新的message可以处理了。也就是说没消息的阻塞是在<code>nativePollOnce</code>实现的（具体是在native looper ::pollInner），但是这个阻塞不是忙等待，而是闲等待，让出CPU时间。</p>
<blockquote>
<p>A. Android应用程序的消息处理机制由消息循环、消息发送和消息处理三个部分组成的。</p>
<p>B. Android应用程序的主线程在进入消息循环过程前，会在内部创建一个Linux管道（Pipe），这个管道的作用是使得Android应用程序主线程在消息队列为空时可以进入空闲等待状态，并且使得当应用程序的消息队列有消息需要处理时唤醒应用程序的主线程。</p>
<p>C. Android应用程序的主线程进入空闲等待状态的方式实际上就是在管道的读端等待管道中有新的内容可读，具体来说就是是通过Linux系统的Epoll机制中的epoll_wait函数进行的。</p>
<p>D. 当往Android应用程序的消息队列中加入新的消息时，会同时往管道中的写端写入内容，通过这种方式就可以唤醒正在等待消息到来的应用程序主线程。</p>
<p>E. 当应用程序主线程在进入空闲等待前，会认为当前线程处理空闲状态，于是就会调用那些已经注册了的IdleHandler接口，使得应用程序有机会在空闲的时候处理一些事情。<br>—-&gt;<a href="http://blog.csdn.net/luoshengyang/article/details/6817933" target="_blank" rel="external">Android应用程序消息处理机制（Looper、Handler）分析</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;sendMessage的message保存在哪？&quot;&gt;&lt;a href=&quot;#sendMessage的message保存在哪？&quot; class=&quot;headerlink&quot; title=&quot;sendMessage的message保存在哪？&quot;&gt;&lt;/a&gt;&lt;code&gt;sendMessage&lt;/code&gt;的&lt;code&gt;message&lt;/code&gt;保存在哪？&lt;/h4&gt;&lt;p&gt;保存在&lt;code&gt;MessageQueue&lt;/code&gt;的&lt;code&gt;Message mMessages&lt;/code&gt;成员变量中，通过&lt;code&gt;message&lt;/code&gt;中的&lt;code&gt;next&lt;/code&gt;维护一个单向链表。&lt;code&gt;message&lt;/code&gt;本身一直在java层，和&lt;code&gt;native&lt;/code&gt;的message没有直接操作关系。&lt;code&gt;looper&lt;/code&gt;分发的消息都是通过&lt;code&gt;messagequeue.mMessages&lt;/code&gt;间接获取的。当&lt;code&gt;sendMessage&lt;/code&gt;时，进入&lt;code&gt;messagequeue&lt;/code&gt;的&lt;code&gt;enqueueMessage&lt;/code&gt;方法，
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>部署阿里云</title>
    <link href="http://yoursite.com/2017/06/28/%E9%83%A8%E7%BD%B2%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    <id>http://yoursite.com/2017/06/28/部署阿里云/</id>
    <published>2017-06-28T12:54:10.000Z</published>
    <updated>2017-06-28T12:54:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近搞了台阿里云的服务器，倒腾了半天，现在写点折腾的坑吧。<a id="more"></a></p>
<p>我之前是没点部署运维的经验，绝大部分时间都是在不停的Google。。目前上面部署了一个<code>node.js</code>写的<code>RESTful</code> 服务，当然还有配套的<code>mongoDb</code>等,一个<code>python</code>写的微信机器人，用的是图灵机器人的接口，还有几个脚本，都可以通过微信指令去调用，也是挺方便的。还有就是把博客从<code>GitHub</code>迁移到阿里云上面去了，速度提升杠杠的，因为迁移到了国内，备案是肯定的，好在阿里云有个代办备案的系统，除了等的时间长了点也没什么毛病(<del>除了备案本身</del>)。还有就是上面部署了个<code>git</code>服务器，这样也算是有个私人仓库了。这里面最折腾人的算是<code>nginx</code>了，因为之前对反向代理没点认识，一点不知道这玩意是干嘛的，只是按照教程一步步来，实在是累。后面慢慢理解点了，其实坑都是自己挖的，也只能自己去填了。下面随便说几个还记得的几点吧。</p>
<p>阿里云默认是root用户，权限太大，太危险。首先要去新建用户，以后都在这个用户下面操作。</p>
<p>刚登录的时候，是<code>Ubuntu</code>裸机，先使用<code>sudo apt-get update</code>更新一下，不然后面很多软件都装不上。</p>
<p>阿里云默认是不开放80和443端口的，所以你再怎么折腾也是连不上的，要先去控制台的安全组里面添加端口，后来我索性把全部端口都开放了，以后也懒得再来修改添加。</p>
<p>使用Mac通过<code>ssh</code>连到服务器之后，有时候会遇到中文乱码，<a href="https://blog.fazero.me/2015/09/04/Mac-iTerm2--chinese/" target="_blank" rel="external">https://blog.fazero.me/2015/09/04/Mac-iTerm2--chinese/</a> 看这个解决吧，后面我装了zsh之后，好像也不再需要上面的步骤了。</p>
<p>遇到<code>nginx</code>老是启动不了，也停止不了，搜了半天也解决不了，还是直接尝试<code>pkill nginx &amp;&amp; service nginx restart</code>吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近搞了台阿里云的服务器，倒腾了半天，现在写点折腾的坑吧。
    
    </summary>
    
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP简单理解</title>
    <link href="http://yoursite.com/2017/06/26/TCP-IP%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/06/26/TCP-IP简单理解/</id>
    <published>2017-06-26T14:38:46.000Z</published>
    <updated>2017-06-26T14:40:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近把《计算机网络》大致翻了一遍，主要是看了网络层往上的部分，包括网络层，运输层，应用层的一些协议和实现，还有一些网络安全，流媒体服务，无线网络等的介绍。对于应用开发，再往下的数据链路层和物理层也没太大的意义去研究。<a id="more"></a></p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层向上提供无连接的，尽最大努力交付的数据报服务。<br>网络层负责端到端的。<br>网络层主要是围绕IP来进行的，与IP协议配套使用的包括ARP:地址解析协议,ICMP：网际控制报文协议，IGMP:网际组管理协议。<br>IP地址的编码方式主要有：分类的IP地址，子网划分(CIDR)，构成超网。<br>网络层通过ARP协议将IP转换为数据链路层使用的物理mac地址。<br>IP数据报的首部包括源地址，目的地址，总长度，生存时间等信息。<br>路由器选择协议主要有RIP和OSPF,前者是基于距离向量的选择协议，间隔具体时间和相邻路由器交换路由信息，信息包括当前路由表(最短距离)和下一跳地址。OSPF是分布式链路状态协议，只有链路状态改变才使用泛洪法发送与所有相邻路由器的链路状态信息，信息包括本路由器于哪些路由器相邻和连接的”代价”。</p>
<h4 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h4><p>运输层负责端口到端口的通信。<br>熟悉的TCP/UDP是运输层的重要协议。<br><strong>UDP</strong></p>
<ul>
<li>无连接</li>
<li>尽最大努力交付，不保证可靠交付</li>
<li>面向报文:应用层交给UDP多大的报文，保留边界发送，如果过长，IP层负责分片。</li>
<li>没有拥塞控制</li>
<li>支持一对多，多对一，一对一的交互通信</li>
<li>部首小(源端口，目的端口，长度，检验和)</li>
</ul>
<p><strong>TCP</strong></p>
<ul>
<li>面向连接(建立连接-通信-释放连接)</li>
<li>只能是点对点</li>
<li>提供可靠交付(无差错，不丢失，不重复，按序到达)</li>
<li>提供全双工通信</li>
<li>面向字节流</li>
</ul>
<p>为保证可靠传输，使用以下协议:</p>
<ul>
<li>停止等待协议(效率低)</li>
<li>连续ARQ和滑动窗口</li>
</ul>
<p>部首：</p>
<ul>
<li>源端口和目的端口</li>
<li>序号:面向字节流，每一个字节都按顺序编号</li>
<li>确认号：期望收到对方下一个报文段的第一个字节的序号</li>
<li>数据偏移：也就是首部长度</li>
<li>紧急URG：尽快发送</li>
<li>确认ACK</li>
<li>推送PSH</li>
<li>复位RST</li>
<li>同步SYN</li>
<li>终止FIN</li>
<li>窗口：接收方允许对方发送的数据量</li>
<li>校验和</li>
<li>紧急指针</li>
<li>选项<br>以字节为单位的滑动窗口，三个指针描述<br>拥塞控制：慢开始，拥塞避免，快重传。<br>TCP建立连接的三次握手，最后一次确认是为了防止已失效的连接建立请求。<br>释放连接的四次握手</li>
</ul>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>面向应用进程<br>DNS域名解析：递归查询，迭代查询<br>FTP文件传输协议<br>TELNET远程终端协议<br>HTTP协议<br>SMTP简单邮件传送协议<br>等</p>
<h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><p>被动攻击和主动攻击</p>
<p>对称密钥<br>DES，IDEA<br>公钥密码<br>数字签名：报文鉴别，报文完整性，不可否认<br>SSL/TLS连接建立</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近把《计算机网络》大致翻了一遍，主要是看了网络层往上的部分，包括网络层，运输层，应用层的一些协议和实现，还有一些网络安全，流媒体服务，无线网络等的介绍。对于应用开发，再往下的数据链路层和物理层也没太大的意义去研究。
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Tinker补丁构建走读</title>
    <link href="http://yoursite.com/2017/05/23/Tinker%E8%A1%A5%E4%B8%81%E6%9E%84%E5%BB%BA%E8%B5%B0%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/05/23/Tinker补丁构建走读/</id>
    <published>2017-05-23T00:18:44.000Z</published>
    <updated>2017-05-23T00:19:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tinker简单问答"><a href="#Tinker简单问答" class="headerlink" title="Tinker简单问答"></a>Tinker简单问答</h2><h4 id="为什么要替换-Application"><a href="#为什么要替换-Application" class="headerlink" title="为什么要替换 Application"></a>为什么要替换 Application</h4><p>看上一篇和 Instant Run 的对比，可能考虑不全</p>
<ul>
<li>确保 Multidex 开启</li>
<li>保证应用 Application 类可修复</li>
<li>7.0 混合编译的影响，要去替换掉原始 PathClassLoader 的加载功能<a id="more"></a></li>
</ul>
<h4 id="为什么还要在-dexElements-前面插入而不是直接替换？"><a href="#为什么还要在-dexElements-前面插入而不是直接替换？" class="headerlink" title="为什么还要在 dexElements 前面插入而不是直接替换？"></a>为什么还要在 dexElements 前面插入而不是直接替换？</h4><p>因为 Tinker 是全量合成 dex ，比如在补丁前dex顺序是这样的：oldDex1 -&gt; oldDex2 -&gt; oldDex3..，那么假如修改了dex1中的文件，那么补丁顺序是这样的newDex1 -&gt; oldDex1 -&gt; oldDex2… 那为什么不直接使用newDex1去替换调oldDex呢？我觉得:</p>
<ul>
<li>运行期去替换调正在使用的dex是有风险的(也是我瞎猜)</li>
<li>考虑到版本回退和以后的增量升级，在前面插入确实比替换更加方便安全</li>
</ul>
<h2 id="Tinker补丁构建走读"><a href="#Tinker补丁构建走读" class="headerlink" title="Tinker补丁构建走读"></a>Tinker补丁构建走读</h2><p>Tinker的补丁加载网上资料很多了，读起来也没太大难度，这里就不多说了。关于补丁构建的整个过程倒是不多，这里简单走读一下。</p>
<h4 id="TinkerPatchSchemaTask"><a href="#TinkerPatchSchemaTask" class="headerlink" title="TinkerPatchSchemaTask"></a>TinkerPatchSchemaTask</h4><p>关于代码的变动  dex的patch  资源的patch</p>
<p>这个 Task 主要是用于 oldApk和 newApk 的差分，生成patch，包括dex,res,so的差分，主要起作用的类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ManifestDecoder manifestDecoder;<span class="comment">//检测是否增加了四大组件  关于dexMode的检测提示</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UniqueDexDiffDecoder dexPatchDecoder;<span class="comment">//dex 的patch</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BsDiffDecoder soPatchDecoder;<span class="comment">//so 的patch</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResDiffDecoder resPatchDecoder;<span class="comment">//资源的patch</span></div></pre></td></tr></table></figure>
<p>这个 Task 也是最关键的，可以从 <code>ApkDecoder</code> 这个类开始，首先会先把两个apk解压到<code>build/outputs/tinkerPatch/{variant}/apkName</code>目录下，在打patch 过程中<code>tinkerPatch</code> 目录下会生成很多过程文件，类似最终的patch apk,用于查看资源合成结果的 <code>resources_out.zip</code>，还有一下log.txt。关键的patch从</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Files.walkFileTree(mNewApkDir.toPath(), <span class="keyword">new</span> ApkFilesVisitor(config, mNewApkDir.toPath(), mOldApkDir.toPath(), dexPatchDecoder, soPatchDecoder, resPatchDecoder));</div></pre></td></tr></table></figure>
<p>这里开始，遍历newApk解压后的目录，根据<code>Pattern</code>去匹配使用上面四个中哪个<code>Decoder</code>去处理这两个新旧文件。</p>
<ul>
<li>dex查分</li>
</ul>
<p>从<code>UniqueDexDiffDecoder dexPatchDecoder;</code>处理dex开始，这里假如我们oldApk只有一个classes.dex,来到<code>DexDiffDecoder.patch</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不是为了对比 是为了检查dex的一些规则</span></div><div class="line">           excludedClassModifiedChecker.checkIfExcludedClassWasModifiedInNewDex(oldFile, newFile);</div></pre></td></tr></table></figure>
<p>这里去检查一下第一个dex中的一些限制，例如tinker的一些loader类一定要在第一个dex中等限制。<br>如果新增了一个dex<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//new add file 在new apk中多了一个dex 直接复制</span></div><div class="line">        <span class="keyword">if</span> (oldFile == <span class="keyword">null</span> || !oldFile.exists() || oldFile.length() == <span class="number">0</span>) &#123;</div><div class="line">            hasDexChanged = <span class="keyword">true</span>;</div><div class="line">            copyNewDexAndLogToDexMeta(newFile, newMd5, dexDiffOut);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>然后正常的修改了dex</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Before starting real diff works, we collect added class descriptor</div><div class="line">     * and deleted class descriptor for further analysing in &#123;<span class="doctag">@code</span> checkCrossDexMovingClasses&#125;.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectAddedOrDeletedClasses</span><span class="params">(File oldFile, File newFile)</span></span></div></pre></td></tr></table></figure>
<p>把对应的dex保存在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// collect current old dex file and corresponding new dex file for further processing.</span></div><div class="line">       oldAndNewDexFilePairList.add(<span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(oldFile, newFile));</div></pre></td></tr></table></figure></p>
<p>然后走到<code>dexPatchDecoder.onAllPatchesEnd();//开始生成 保存patch文件</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (config.mIsProtectedApp) &#123;<span class="comment">//仅仅在加固的时候使用 只将变化的类合成补丁</span></div><div class="line">            generateChangedClassesDexFile();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            generatePatchInfoFile();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>然后来到这个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">            DexPatchGenerator dexPatchGen = <span class="keyword">new</span> DexPatchGenerator(oldDexFile, newDexFile);</div><div class="line">            dexPatchGen.setAdditionalRemovingClassPatterns(config.mDexLoaderPattern);<span class="comment">//查分时候排除dex.loader闭包中的类</span></div><div class="line"></div><div class="line">            logWriter.writeLineToInfoFile(</div><div class="line">                    String.format(</div><div class="line">                            <span class="string">"Start diff between [%s] as old and [%s] as new:"</span>,</div><div class="line">                            getRelativeStringBy(oldDexFile, config.mTempUnzipOldDir),</div><div class="line">                            getRelativeStringBy(newDexFile, config.mTempUnzipNewDir)</div><div class="line">                    )</div><div class="line">            );</div><div class="line"></div><div class="line">            dexPatchGen.executeAndSaveTo(dexDiffOut);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerPatchException(e);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>这里就是具体的dexDiff算法了，我也看不懂，就当个黑盒，反正会生产处一个查分dex保存，然后后面还会在合成一个全量dex用来查看，保存一下log日志之类的，大致的dex查分就完成了。</p>
<ul>
<li>res 查分<br>回到遍历newApk目录的地方，还是根据<code>Pattern</code>去匹配资源文件，在这个方法中进行查分</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//处理修改的资源</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dealWithModeFile</span><span class="params">(String name, String newMd5, File oldFile, File newFile, File outputFile)</span></span></div></pre></td></tr></table></figure>
<p>还是使用了BSD进行差分，输出log，修改的文件复制到tinker_result的目录下。然后到<code>onAllPatchesEnd</code>，和dex一样，还是会生成全量的<code>resources_out.zip</code>去查看合成结果，还有log输出。</p>
<ul>
<li>so查分<br>这个也是使用了BSD查分，没太多好说的。</li>
</ul>
<h4 id="TinkerManifestTask"><a href="#TinkerManifestTask" class="headerlink" title="TinkerManifestTask"></a>TinkerManifestTask</h4><p>自动添加/修改tinker_id，运行时检查补丁版本</p>
<h4 id="TinkerResourceIdTask"><a href="#TinkerResourceIdTask" class="headerlink" title="TinkerResourceIdTask"></a>TinkerResourceIdTask</h4><p>R.txt 的保存 ids.xml public.xml的处理，用于处理资源改变时ID变动问题，将基础包的R.txt处理成ids.xml，public.xml，保存到<code>intermediates/res/merged/{variant}/values/</code>下，用于打包时候的资源ID分配。保证资源ID的不变动。</p>
<h4 id="TinkerProguardConfigTask"><a href="#TinkerProguardConfigTask" class="headerlink" title="TinkerProguardConfigTask"></a>TinkerProguardConfigTask</h4><p>混淆的处理，主要的作用是将tinker中默认的混淆信息和基准包的mapping信息加入混淆列表。</p>
<h4 id="TinkerMultidexConfigTask"><a href="#TinkerMultidexConfigTask" class="headerlink" title="TinkerMultidexConfigTask"></a>TinkerMultidexConfigTask</h4><p>主要将dex.loader中配置的class也keep进main dex.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Tinker简单问答&quot;&gt;&lt;a href=&quot;#Tinker简单问答&quot; class=&quot;headerlink&quot; title=&quot;Tinker简单问答&quot;&gt;&lt;/a&gt;Tinker简单问答&lt;/h2&gt;&lt;h4 id=&quot;为什么要替换-Application&quot;&gt;&lt;a href=&quot;#为什么要替换-Application&quot; class=&quot;headerlink&quot; title=&quot;为什么要替换 Application&quot;&gt;&lt;/a&gt;为什么要替换 Application&lt;/h4&gt;&lt;p&gt;看上一篇和 Instant Run 的对比，可能考虑不全&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保 Multidex 开启&lt;/li&gt;
&lt;li&gt;保证应用 Application 类可修复&lt;/li&gt;
&lt;li&gt;7.0 混合编译的影响，要去替换掉原始 PathClassLoader 的加载功能
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>由View.post引发的问题</title>
    <link href="http://yoursite.com/2017/05/14/%E7%94%B1View-post%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/05/14/由View-post引发的问题/</id>
    <published>2017-05-14T12:31:42.000Z</published>
    <updated>2017-05-14T12:36:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到<a href="http://www.jianshu.com/p/571e9b4f4b89" target="_blank" rel="external">记一次错误的使用View.post(Runnable)</a>这篇的时候，自己去实验了一下，当时是在 Activity 的 onDestory 中做的，以为到了 onDestory View 肯定是 Detach 的，结果并不是这样的。。后来发现在 API 24的时候，关于 View.Post 这部分的代码有重写，所有就捋了捋关于这部分的东西，简单记录一下。<a id="more"></a></p>
<h4 id="View-Detach"><a href="#View-Detach" class="headerlink" title="View Detach"></a>View Detach</h4><p>View 什么时候才会 Detach ？当 View 中 mAttachInfo 这个变量置空的时候，就 Detach 了，是在 dispatchDetachedFromWindow 这个方法中置空的，这方法是在 ViewRootImpl.dispatchDetachedFromWindow() 中调用的，ViewRootImpl 可以看做是在 View 和 WindowManager 中间一个类 ，WMS 通过 IWindow 进行 ipc 通信控制通知客户端的 WindowManager， WindowManager 还要稍微使用 WindowManagerGlobal 中转处理一下，然后再去调用 ViewRootImpl 中的一些方法，而 ViewRootImpl 是持有 DecorView ，DecorView 中又有 WindowCallBack ，其实就是 Activity ,因为 Activity 实现了 WindowCallBack。这样再去调用 Activity 中关于 Window 相关的回调。回到问题，什么时候Detach？ 当然还是在 Activity 销毁的时候，简单说下情形，A 启动 B ,在 B 中调用 finish。B finish-&gt; B onPause-&gt;A onResume-&gt;B onStop-&gt;B onDestroy-&gt;B onDetachedFromWindow 。大致的流程是ActivityManagerNative通知AMS,AMS通过IApplicationThread调用ActivityThread.H去sendMessage，然后再去ActivityThread某个类似performPauseActivity，然后Instrumentation，然后就是activity生命周期。在最后调用handleDestroyActivity中，先调用ondestory 然后调用wm的removeViewImmediate，[ActivityThread.handleDestroyActivity() –&gt;<br>WindowManager.removeViewImmediate() –&gt;<br>WindowManagerGlobal.removeViewLocked()方法 —&gt;<br>ViewRootImpl.die() –&gt; doDie() –&gt;<br>ViewRootImpl.dispatchDetachedFromWindow()],这个时候view.attachInfo 置空，所以当回调 Activity 的 onDestory 的时候，还没去调用 dispatchDetachedFromWindow ，当然还没 Detach 。关于 View 什么时候 Attached ，是在 onResume 之后，具体就不说了，和上面差不多。</p>
<h4 id="View-post"><a href="#View-post" class="headerlink" title="View.post"></a>View.post</h4><p>说一下现象，当在 Attached 的时候，使用 View.post 就是走 handler 那一套，使用的 handelr 是 ViewRootImpl 中的 ViewRootHandler ，looper 就是 mainLooper ，这个没什么好分析的，这个时候怎么post都是有回调的。当在 Detach 的时候，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</div><div class="line">        <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> attachInfo.mHandler.post(action);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Postpone the runnable until we know on which thread it needs to run.</span></div><div class="line">        <span class="comment">// Assume that the runnable will be successfully placed after attach.</span></div><div class="line">        getRunQueue().post(action);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>走下面的 <code>getRunQueue().post(action);</code> 这个在24 以前 看开头那篇分析，是用 ThreadLocal 来进行的线程隔离，在 24 的时候，getRunQueue 变成了view的私有变量 mRunQueue:HandlerActionQueue ,当post 到这个里面去的时候，基本上是不会在调用了，因为它的 <code>mRunQueue.executeActions(info.mHandler);</code>是在 <code>dispatchAttachedToWindow</code> 中调用的。。一个activity生命周期只会调一次，也基本上用不到什么自行车了。。</p>
<h4 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h4><p>看下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.onDestroy();</div><div class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">              button.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                  <span class="meta">@Override</span></div><div class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                      Log.e(<span class="string">"ssssss"</span>, <span class="string">"onDestroy"</span>);</div><div class="line">                  &#125;</div><div class="line">              &#125;);</div><div class="line">          &#125;</div><div class="line">      &#125;).start();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里面的Log会不会调用？？说实话，看缘分。。。不信自己去试试</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到&lt;a href=&quot;http://www.jianshu.com/p/571e9b4f4b89&quot;&gt;记一次错误的使用View.post(Runnable)&lt;/a&gt;这篇的时候，自己去实验了一下，当时是在 Activity 的 onDestory 中做的，以为到了 onDestory View 肯定是 Detach 的，结果并不是这样的。。后来发现在 API 24的时候，关于 View.Post 这部分的代码有重写，所有就捋了捋关于这部分的东西，简单记录一下。
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Instant-Run与Tinker中Application替换</title>
    <link href="http://yoursite.com/2017/05/08/Instant-Run%E4%B8%8ETinker%E4%B8%ADApplication%E6%9B%BF%E6%8D%A2/"/>
    <id>http://yoursite.com/2017/05/08/Instant-Run与Tinker中Application替换/</id>
    <published>2017-05-08T14:58:02.000Z</published>
    <updated>2017-05-16T01:02:21.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>为什么要替换application</li>
</ul>
<p>因为5.0以下开始只会去加载第一个dex,如果appliaction不在第一个dex,则无法启动。如果把自己的appliaction放在第一个dex中，而自己的application没有使用multidex,则只会去加载原始加载生成的dex,也是会报错。所以办法就是去代理掉原始的application，将app启动的application设置为这个代理的application，在这个代理的application中可以确保使用multidex功能。</p>
<p>还有因为补丁是在appliaction中加载，这样会导致无法对appliaction的修复，还有因为 Android N 的混合编译的影响 ，Tinker 使用了类似 Instant-run 中 IncrementalClassLoader （具体实现过程还是有差距），新建一个classLoader，去 “替换”掉原始的 PathClassLoader 去加载所有dex。这些都需要在appliaction中进行修改。<br><a id="more"></a></p>
<ul>
<li>替换操作的差异</li>
</ul>
<p>Instant run 是在attachBaseContext的时候再去反射创建原始的application，然后再反射替换掉Framework中已经初始化的application(这个时候还是代理的application),还原回去我们原始的application。接下来就是正常的流程，在app中去get application也不会有问题。</p>
<p>Tinker使用的是静态代理，使用代理方案代码会更复杂一些，因为要去模拟出一个applicationLike的接口，在tinker中，我们真正的application只需要实现这个接口，并不需要去继承Android中的application，因为会在代理的application中反射调用我们的application生命周期方法。也就是说tinker中只有一个真正的application。</p>
<ul>
<li>优缺点</li>
</ul>
<p>在instant run中application的替换的透明的，两个application都是真正的Android application。好处就是透明，坏处也是使用了反射替换运行期的application，兼容性不如静态代理好，类似tinker中反射插入dex就分了好多个版本实习，这个会更复杂。tinker更加稳定。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;为什么要替换application&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为5.0以下开始只会去加载第一个dex,如果appliaction不在第一个dex,则无法启动。如果把自己的appliaction放在第一个dex中，而自己的application没有使用multidex,则只会去加载原始加载生成的dex,也是会报错。所以办法就是去代理掉原始的application，将app启动的application设置为这个代理的application，在这个代理的application中可以确保使用multidex功能。&lt;/p&gt;
&lt;p&gt;还有因为补丁是在appliaction中加载，这样会导致无法对appliaction的修复，还有因为 Android N 的混合编译的影响 ，Tinker 使用了类似 Instant-run 中 IncrementalClassLoader （具体实现过程还是有差距），新建一个classLoader，去 “替换”掉原始的 PathClassLoader 去加载所有dex。这些都需要在appliaction中进行修改。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Express + React 搭建简易web微博</title>
    <link href="http://yoursite.com/2017/03/02/%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93web%E5%BE%AE%E5%8D%9A/"/>
    <id>http://yoursite.com/2017/03/02/搭建简易web微博/</id>
    <published>2017-03-02T00:47:52.000Z</published>
    <updated>2017-07-28T13:33:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近用 React 写了个简单的web微博，因为js的跨域问题，无法直接请求web Weibo的API，所以只能使用Node来中转一下，这样玩法也更丰富，随便处理数据。目前的功能只包括看微博和查看大图。<a id="more"></a></p>
<p>微博的自动登录使用的是<a href="https://github.com/ruansongsong/nodejs-weibo-login" target="_blank" rel="external">nodejs-weibo-login</a>,但是这个库是为了pc端微博设计的，最初还是可以兼容web版的微博登录，后来估计是新浪修改了规则，不再兼容了，所以目前只能手动传 cookie 了。<br>基本没用第三方的react类库，就是个很简单的东西。</p>
<p><a href="https://coding.net/u/70kg/p/express/git" target="_blank" rel="external">服务端代码</a><br><a href="https://coding.net/u/70kg/p/React/git" target="_blank" rel="external">Weibo</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近用 React 写了个简单的web微博，因为js的跨域问题，无法直接请求web Weibo的API，所以只能使用Node来中转一下，这样玩法也更丰富，随便处理数据。目前的功能只包括看微博和查看大图。
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》笔记</title>
    <link href="http://yoursite.com/2016/12/31/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/12/31/《深入理解Java虚拟机》笔记/</id>
    <published>2016-12-31T08:54:38.000Z</published>
    <updated>2017-07-28T13:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自动内存管理机制"><a href="#自动内存管理机制" class="headerlink" title="自动内存管理机制"></a>自动内存管理机制</h2><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul>
<li>通过改变这个计数器的指决定执行的下一条指令</li>
<li>线程私有 每条线程独立</li>
<li>不会 oom <a id="more"></a><h4 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h4>存放基本类型和引用和   returnAddress类型(指向了一条字节码指令的地址）<br>描述 Java 方法执行的内存模型<h4 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h4></li>
<li>存放对象实例</li>
<li>线程共享，内存最大</li>
<li>GC 的主要区域</li>
<li>基于分代回收，大致分为新生代和老年代<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4></li>
<li>线程共享</li>
<li>类信息，常量，静态变量<h2 id="虚拟机对象"><a href="#虚拟机对象" class="headerlink" title="虚拟机对象"></a>虚拟机对象</h2><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4>new指令的参数是否能在常量池中定位到一个类的符号引用-&gt;是否已经加载，解析初始化-&gt;分配内存(指针碰撞，空闲列表)-&gt;初始化为零值-&gt;为对象进行必要设置-&gt;&lt; init &gt; 方法。(ps：new 关键字其实为new和init两个方法)</li>
</ul>
<h3 id="对象的内存分布"><a href="#对象的内存分布" class="headerlink" title="对象的内存分布"></a>对象的内存分布</h3><ul>
<li>对象头<br>1.分用于存储对象自身的运行时数据,e.g.哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时 间戳等<br>2.类型指针,对象指向它的类元数据的指针,虚拟机通过这个指 针来确定这个对象是哪个类的实例.</li>
<li>实例数据</li>
<li>对其填充</li>
</ul>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>使用栈上的引用去操作堆上的实例。</p>
<ol>
<li>句柄<br>在堆中有一块内存区域作为句柄池，栈中的引用存储的是对象的句柄地址，句柄中包括对象的实例数据(实例池)和类型数据(方法区)。<br>好处：GC 时只会改变句柄中实例指针，不会影响栈中的指向。<ol>
<li>直接指针<br>栈中的引用直接指向对象地址。<br>好处：速度快，省一次指针定向</li>
</ol>
</li>
</ol>
<p>ps: <code>String.intern</code>的问题 <a href="http://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="external">点这里</a></p>
<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p>先标记需要回收的对象，然后统一回收。缺点是效率不高，会产生内存碎片问题。</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>1：1分割内存，只用一半，回收时把存活的复制到另一半，清除原来一半。<br>实际使用在新生代，适合回收频率高的。朝生夕死。每次清理都有大量对象死亡。<code>HotSpot</code>默认为8:1:1,浪费10%的内存空间，使用8和1，当回收时候，复制到另一个1中。空间不够时候，需要依赖老年代。</p>
<h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h3><p>先标记，把存活的移动到一端，清除。适合老年代</p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>通过使用一组<code>OopMap</code>的数据结构知道哪些地方存放对象引用。在类加载完成时，<code>HotSpot</code>就把对象内什么偏移量上是什么类型的数据计算出来，在<code>JIT</code>编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，这样GC扫描时就可以直接得知。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>上面特定的位置是安全点，只有在安全点处暂停。主要使用主动式中断让所有线程都跑到安全点再停顿。不直接对线程操作，设置一个标志，各个线程主动去轮训，发现中断标志true就自己中断挂起。</p>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>安全区域用来解决在程序没有CPU时间，例如线程sleep或者block的时候进入GC。安全区域是指在一段代码之后，引用关系不会发生变化，在这个区域任何地方GC都是安全的。当程序执行到安全区域，首先标识进入，然后GC可以随时进行。当程序要离开安全区域时，先去检查GC是否完成，是-&gt;继续执行，否-&gt;等待完成。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>最基本最久远的收集器，单线程,STW。没有线程切换的开销，简单。复制算法</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>Serial收集器的多线程版本。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>和ParNew收集器类似，关注吞吐量</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial收集器的的老年代版本。标记-整理</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Scavenge收集器的老年代版本，标记-整理。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><ol>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）<br>1，3步骤STW。1只标记GC roots能直接关联对象，很快。并发标记阶段就是进行GC RootsTracing 的过程,而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变 动的那一部分对象的标记记录,这个阶段的停顿时间一般会比初始标记阶段稍长一些,但远 比并发标记的时间短。整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作<img src="http://7xjlmz.com1.z0.glb.clouddn.com/Java%E8%99%9A%E6%8B%9F%E6%9C%BAcms.png" alt=""><br>优点：<br>并发收集，低停顿<br>缺点：<br>对CPU资源敏感，默认回收线程(cpu数量+3)/4<br>cms无法处理”浮动垃圾”（当并发收集同时产生的垃圾）<br>标记-清除算法内存碎片问题</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>特点：</p>
<ul>
<li>分代收集</li>
<li>并行与并发</li>
<li>空间整合</li>
<li>可预测的停顿<br>将整个Java堆划分 为多个大小相等的独立区域(Region)<br>大致过程：<ol>
<li>初始标记(Initial Marking)</li>
<li>并发标记(Concurrent Marking)</li>
<li>最终标记(Final Marking)</li>
<li>筛选回收(Live Data Counting and Evacuation)<br>4-&gt;筛选回收阶段首先对各个Region的回收价值和成本进行排序, 根据用户所期望的GC停顿时间来制定回收计划</li>
</ol>
</li>
</ul>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下,对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时,虚拟 机将发起一次Minor GC</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对 象年龄(Age)计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活,并且能被 Survivor容纳的话,将被移动到Survivor空间中,并且对象年龄设为1。对象在Survivor区中 每“熬过”一次Minor GC,年龄就增加1岁,当它的年龄增加到一定程度(默认为15岁),就 将会被晋升到老年代中。</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>如果在Survivor空间中相同年龄所有对象大小的总 和大于Survivor空间的一半,年龄大于或等于该年龄的对象就可以直接进入老年代,无须等 到MaxTenuringThreshold中要求的年龄。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC之前,虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有 对象总空间,如果这个条件成立,那么Minor GC可以确保是安全的。如果不成立,则虚拟机 会查看HandlePromotionFailure设置值是否允许担保失败。如果允许,那么会继续检查老年代 最大可用的连续空间是否大于历次晋升到老年代对象的平均大小,如果大于,将尝试着进行 一次Minor GC,尽管这次Minor GC是有风险的;如果小于,或者HandlePromotionFailure设置 不允许冒险,那这时也要改为进行一次Full GC。</p>
<h1 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h1><p>略</p>
<h1 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h1><p>略</p>
<h1 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h1><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>Class文件格式采用一种类似C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表<br>无符号数属于基本类型，有u1,u2,u4,u8表示几个字节，可以用来描述数字，索引引用，数据值或者按照UTF-8编码的字符串<br>表是由多个无符号数或者其他表作为数据结构的复合数据结构，表习惯以_info结尾。<br>整个Class本质上就是一个表<br>Class文件格式：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" alt=""></p>
<h3 id="魔数-u4"><a href="#魔数-u4" class="headerlink" title="魔数 u4"></a>魔数 u4</h3><p><code>0xCAFFBABE</code></p>
<h3 id="次版本号-u2"><a href="#次版本号-u2" class="headerlink" title="次版本号 u2"></a>次版本号 u2</h3><h3 id="主版本号-u2"><a href="#主版本号-u2" class="headerlink" title="主版本号 u2"></a>主版本号 u2</h3><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>u2的常量池大小 index从1开始，第0项空出<br>常量池中主要存放两大类常亮：字面量和符号引用<br>字面量类似Java的常量<br>符号引用包括：</p>
<ol>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ol>
<p>常量池中每一项都是一个表(都对应一个Class)。一共14种表，表开始的第一位u1代表当前这个常量属于哪种常量类型<br>具体如下：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%B1%BB%E5%9E%8B.jpg" alt=""></p>
<h3 id="访问标志-u2"><a href="#访问标志-u2" class="headerlink" title="访问标志 u2"></a>访问标志 u2</h3><p>用于标识一些类或者接口成次的访问信息<br>具体如下：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.jpg" alt=""></p>
<h3 id="类索引、父类索引与接口索引集合-u2-u2-List"><a href="#类索引、父类索引与接口索引集合-u2-u2-List" class="headerlink" title="类索引、父类索引与接口索引集合 u2,u2,List"></a>类索引、父类索引与接口索引集合 u2,u2,List<u2></u2></h3><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>用于描述接口或类中的变量<br>字段包括类级变量(static)和实例级变量 不包括方法内部的局部变量</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>对方法的描述</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>用于描述某些场景专用信息。下面的必备的9个属性:<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class%E5%B1%9E%E6%80%A7%E8%A1%A8.png" alt=""></p>
<h4 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h4><p>简单理解就是方法体,具体的结构如下：<br><img src="http://7xjlmz.com1.z0.glb.clouddn.com/class_code%E5%B1%9E%E6%80%A7.jpg" alt=""></p>
<p>Code属性是Class文件中最重要的属性，如果把Java程序中信息分为代码（Code）和元数据(类，字段，方法定有以及其他信息)两部分。Code属性属于描述代码，所有的其他数据项目都用于描述元数据</p>
<h2 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h2><h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><p>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输<br>Tload -&gt; 将一个局部变量加载到操作栈<br>Tstore -&gt; 将一个数值从操作数栈存储到局部变量表<br>Tipush -&gt; 将一个变量加载到操作数栈<br>wide -&gt; 扩充局部变量表的访问索引指令</p>
<h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><p>用于对两个操作数栈上的值进行某种特定的运算，并把结果重新存入到操作栈顶。<br>算术运算大致分为对整形数据进行运算的指令和对浮点数进行运算的指令</p>
<p>加法指令 ：Tadd<br>减法指令: Tsub<br>乘法指令： Tmul<br>除法指令：Tdiv<br>求余指令：Trem<br>取反指令：Tneg<br>位移指令：Tshl,Tshr,Tushr<br>按位或指令：Tor<br>按位与指令：Tand<br>按位异或指令：Txor<br>局部变量自增指令：Tinc<br>比较指令：Tcmpg,Rcmpl</p>
<h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><p>用于将两种不同的数值类型进行相互转换，一般用于实现用户代码中的显式类型转换或者用于处理字节码指令集中数据类型相关指令无法一一对应的问题<br>i2b,i2c…</p>
<h3 id="对象创建和访问指令"><a href="#对象创建和访问指令" class="headerlink" title="对象创建和访问指令"></a>对象创建和访问指令</h3><p>Java虚拟机对类实例和数组的创建于操作用了不同的字节码指令。<br>创建类实例 -&gt; new<br>创建数组 -&gt; newarray,anewarray,multianewarray<br>访问类字段和实例字段 -&gt; getfield,putfield,getstatic,putstatic<br>把一个数组元素加载到操作数栈 -&gt; Taload<br>将一个操作数栈的值存储到数组元素中 -&gt;Tastore<br>取数组长度 -&gt; arraylength<br>检查类实例类型 -&gt; instanceof,checkcast</p>
<h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><p>直接操作操作数栈的指令<br>将操作数栈的栈顶一个或两个元素出栈 -&gt;pop,pop2<br>复制栈顶两个数值并将双份复制值从新压入栈顶 -&gt; dup2,dup2_x1,dup2_x2<br>栈顶两个数值交换 -&gt; swap</p>
<h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><p>条件分支，复合条件分支，无条件分支<br>各种类型的比较最终都会转化成int类型的比较操作，所以Java虚拟机提供的int类型的条件分支指令是最丰富和强大的</p>
<h3 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h3><p>invokevirtual -&gt;调用实例方法，最常见的<br>invokeinterface -&gt;调用接口方法，会在运行时搜索一个实现了这个接口方法的对象，找到合适的方法进行调用<br>invokespecial -&gt; 调用一些需要特殊处理的实例方法，包括实例初始化方法，私有方法和父类方法<br>invokestatic -&gt; 调用类方法<br>invokedynamic -&gt; 在运行时动态解析出调用点限定符所引用的方法，并执行该方法？？？？</p>
<p>方法调用指令与数据类型无关，返回指令是根据返回值的类型区分的.Treturn</p>
<h3 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h3><p>显示抛出异常(throw)都是由athrow指令实现。<br>处理异常不是由字节码指令实现的，采用异常表完成。</p>
<h3 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h3><p>支持方法级同步和方法内部一段指令序列的同步，是使用管程(Monitor)支持。</p>
<p>方法级的同步是隐式的,即无须通过字节码指令来控制,它实现在方法调用和返回操作 之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个 方法是否声明为同步方法。当方法调用时,调用指令将会检查方法的ACC_SYNCHRONIZED 访问标志是否被设置,如果设置了,执行线程就要求先成功持有管程,然后才能执行方法, 最后当方法完成(无论是正常完成还是非正常完成)时释放管程。在方法执行期间,执行线 程持有了管程,其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出 了异常,并且在方法内部无法处理此异常,那么这个同步方法所持有的管程将在异常抛到同 步方法之外时自动释放。</p>
<p>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的,Java虚拟机的 指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义,正确实现 synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自动内存管理机制&quot;&gt;&lt;a href=&quot;#自动内存管理机制&quot; class=&quot;headerlink&quot; title=&quot;自动内存管理机制&quot;&gt;&lt;/a&gt;自动内存管理机制&lt;/h2&gt;&lt;h4 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;程序计数器&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;通过改变这个计数器的指决定执行的下一条指令&lt;/li&gt;
&lt;li&gt;线程私有 每条线程独立&lt;/li&gt;
&lt;li&gt;不会 oom
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从零撸一个Redux</title>
    <link href="http://yoursite.com/2016/12/25/Redux-2/"/>
    <id>http://yoursite.com/2016/12/25/Redux-2/</id>
    <published>2016-12-25T13:53:53.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="扯一扯"><a href="#扯一扯" class="headerlink" title="扯一扯"></a>扯一扯</h4><p>这段时间在看 <code>Redux</code> 的东西，稍微梳理一下整个框架的流程。其实整个 <code>Redux</code> 的代码很少，现在我也不能理解很多它的思想，反正先撸出个简单的 <code>Redux</code> 吧。目标是照着它的流程写一个最简单的，也要支持异步 <code>Action</code>。也算是个笔记性的东西。<a id="more"></a></p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a><code>Action</code></h4><p>这里把 <code>Action</code> 放到了 <code>Store</code> 中，这样在 <code>Component</code> 中使用的时候只要导入 <code>store</code> 就可以，不用导入很多的 <code>Action</code>, <del>就是懒</del>。当然也可以使用 <code>React-Redux</code> 之类的进行绑定，但是这个库主要不是干这个的。。这个后面会提到一些。因为 <code>Actions</code> 都是提前定义的，所有写在了一个 <code>StoreConfig</code> 中，在创建 <code>Store</code> 的时候就可以把 <code>actions</code> 注入到 <code>Store</code> 中了。当然你也可以不这么做。先贴一下完整的代码吧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> createStore <span class="keyword">from</span> <span class="string">'./createStore'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> store = createStore(&#123;</div><div class="line">    <span class="comment">//把所有的action都放在了store中</span></div><div class="line">    actions: &#123;</div><div class="line">        <span class="comment">//同步的action</span></div><div class="line">        <span class="string">'printText'</span>: createRequest(<span class="function">(<span class="params">text</span>)=&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> &#123;<span class="attr">text</span>: text + <span class="string">"我想修改"</span>&#125;;</div><div class="line">        &#125;),</div><div class="line">        <span class="comment">//异步的action，async await可以看上一篇</span></div><div class="line">        <span class="string">'testAsync'</span>: createRequest(<span class="keyword">async</span>()=&gt; &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">await</span> Longtime();</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">initState</span>: &#123;&#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">//测试的代码不用说吧</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Longtime</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            resolve(&#123;<span class="attr">text</span>: <span class="string">'success'</span>&#125;);</div><div class="line">            <span class="comment">// reject('error');</span></div><div class="line">        &#125;, <span class="number">2000</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//这个是个actionCreater 之前有写过在项目中的使用 这里也不多说</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRequest</span>(<span class="params">actionCreator</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> finalActionCreator = <span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span></div><div class="line">        ? actionCreator</div><div class="line">        : <span class="function">(<span class="params">t</span>) =&gt;</span> t;</div><div class="line">    <span class="keyword">const</span> actionHandler = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">const</span> action = &#123;</div><div class="line">            <span class="attr">type</span>: actionHandler.toString()</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//真正的action都放在payload中，同步则是数据，异步是Promise。</span></div><div class="line">        <span class="keyword">const</span> payload = finalActionCreator(...args);</div><div class="line">        <span class="keyword">if</span> (!(payload === <span class="literal">null</span> || payload === <span class="literal">undefined</span>)) &#123;</div><div class="line">            action.payload = payload;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (action.payload <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</div><div class="line">            action.error = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> action;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> actionHandler;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</div></pre></td></tr></table></figure>
<h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a><code>Reducer</code></h4><p>这里的 <code>Reducer</code> 只创建了一个，就是直接把成功的数据更新到 <code>Store</code> 中，也没什么好看的，关于异步的 <code>Promise</code> 会在结果返回之后再去通知 <code>Reducer</code>去更新 <code>Store</code>，当然这就不是这个 <code>Reducer</code> 的工作了。代码很简单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">acceptSuccessActionReducer</span>(<span class="params">state, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!action.error &amp;&amp; action.payload) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, action.payload);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a><code>Store</code></h4><p>我觉得 <code>Redux</code> 的最重要的东西就是 <code>Store</code> 了。所有的 <code>Action</code> 都要经过 <code>Store</code> 分发，当结果返回之后也要通知 <code>Store</code> 去更新，<code>Component</code> 的数据也是从 <code>Store</code> 中获取。先贴一下 <code>CreateStore</code> 代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;handleActions&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</div><div class="line"><span class="keyword">import</span> &#123;applyMiddleware&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> promiseMiddleware <span class="keyword">from</span> <span class="string">'redux-promise'</span>;</div><div class="line"><span class="keyword">import</span> acceptSuccessActionReducer <span class="keyword">from</span> <span class="string">'../reducers/SuccessReducer'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> actions = config.actions;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> initState = config.initState;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> reducersDict = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="built_in">Object</span>.keys(actions).forEach(<span class="function"><span class="params">key</span>=&gt;</span> &#123;</div><div class="line">        <span class="keyword">var</span> action = actions[key];</div><div class="line">        action.toString = <span class="function"><span class="params">()</span>=&gt;</span>key;</div><div class="line">        reducersDict[key] = acceptSuccessActionReducer;<span class="comment">//将action与reducer绑定</span></div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//这个reducers应该是个类似arrays.reduce的function   果然--&gt; @see 'reduce-reducers'   what's means??</span></div><div class="line">    <span class="keyword">var</span> reducers = handleActions(reducersDict, initState);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> store = generateStore(reducers, applyMiddleware(promiseMiddleware));</div><div class="line"></div><div class="line">    store.actions = &#123;&#125;;</div><div class="line">    <span class="built_in">Object</span>.assign(store.actions, actions);</div><div class="line"></div><div class="line">    store.subscribe(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'这是修改后的===&gt;'</span>, store.getState());</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> store;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</div><div class="line">        enhancer = preloadedState;</div><div class="line">        preloadedState = <span class="literal">undefined</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> enhancer(generateStore)(reducer, preloadedState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> currentState = preloadedState;</div><div class="line">    <span class="keyword">let</span> currentReducer = reducer;</div><div class="line">    <span class="keyword">let</span> listeners = [];</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        getState() &#123;</div><div class="line">            <span class="keyword">return</span> currentState;<span class="comment">//返回当前 state</span></div><div class="line">        &#125;,</div><div class="line">        subscribe(listener) &#123;</div><div class="line">            <span class="keyword">let</span> index = listeners.length;</div><div class="line">            listeners.push(listener); <span class="comment">//缓存 listener</span></div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> listeners.splice(index, <span class="number">1</span>); <span class="comment">//返回删除该 listener 的函数</span></div><div class="line">        &#125;,</div><div class="line">        dispatch(action) &#123;</div><div class="line">            currentState = currentReducer(currentState, action);</div><div class="line">            listeners.slice().forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener());</div><div class="line">            <span class="keyword">return</span> action;<span class="comment">//返回 action 对象</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里偷懒用了一些库，但是仅仅是很简单的几个方法，例如 <code>import {handleActions} from &#39;redux-actions&#39;;</code> 这个里面的代码我没看的懂，但是知道返回一个类似<code>arrays.reduce</code>的<code>function</code>，这个可以理解返回一个 <code>rootReducer</code> ，也就是会迭代累加调用所有的 <code>Reducer</code> 。<code>generateStore</code> 也是抄了一部分的源码，大致的原理应该差不多。从这个也会发现一个问题，每当 <code>dispatch</code> 一个 <code>action</code> 都会去遍历所有的 <code>listeners</code> ，我们一般都是在 <code>listener</code> 中去做更新 <code>UI</code> 的工作，这样就会造成很多次无用的刷新。这个就可以使用上面提到过的 <code>React-Redux</code> 的 <code>mapStateToProps</code> 在某个 <code>Component</code> 中只去接受自己感兴趣的 <code>State</code> 的更新，然后再使用类似 <code>Immutable</code> 的库进去比较就可以很好的控制更新。当然这里不会多去说这个，因为我也没具体去理解过，以后可以多去学习学习。<br>这里还偷懒直接用了 <code>redux</code> 中的 <code>applyMiddleware</code>。我觉得这是我学习 <code>Redux</code> 中看到的最精彩的代码，贴一下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, middlewares = <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) &#123;</div><div class="line">    middlewares[_key] = <span class="built_in">arguments</span>[_key];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);</div><div class="line">      <span class="keyword">var</span> _dispatch = store.dispatch;</div><div class="line">      <span class="keyword">var</span> chain = [];</div><div class="line"></div><div class="line">      <span class="keyword">var</span> middlewareAPI = &#123;</div><div class="line">        <span class="attr">getState</span>: store.getState,</div><div class="line">        <span class="attr">dispatch</span>: <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> _dispatch(action);</div><div class="line">        &#125;</div><div class="line">      &#125;;</div><div class="line">      chain = middlewares.map(<span class="function"><span class="keyword">function</span> (<span class="params">middleware</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> middleware(middlewareAPI);</div><div class="line">      &#125;);</div><div class="line">      _dispatch = _compose2[<span class="string">'default'</span>].apply(<span class="literal">undefined</span>, chain)(store.dispatch);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> _extends(&#123;&#125;, store, &#123;</div><div class="line">        <span class="attr">dispatch</span>: _dispatch</div><div class="line">      &#125;);</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过和上面的 <code>generateStore</code> 一起看，特别是 <code>applyMiddleware</code> 返回的匿名<code>Function</code>，真是精彩的代码。再去试想一下如果使用 <code>Java</code> 这样的强类型语言去实现得是多麻烦的事情。还有就是 <code>Function</code> 的一等公民地位的体现。真的值得多去读一读，很赞。不得不去佩服写这段代码的人。甚至有点自举的感觉。在还没创建 <code>store</code> 的时候就可以去使用 <code>Store.dispatch</code>，(这句话是有问题的，意会即可)。还有就是 <code>applyMiddleware</code> 的整个过程其实没有完全的弄明白，这里也不班门弄斧，等明白了会再来更新的。</p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>最后就是使用了，没什么好说的<code>store.dispatch(store.actions.testAsync());</code>就可以了。使用手动的 <code>subscribe</code> 或者 <code>React-redux</code> 的 <code>connect</code> 都能实现 <code>UI</code> 的更新，当然更推荐后者。后面还会去学习一个 <code>React-Redux</code> 这个东西，毕竟又使用 <code>React</code> 又使用 <code>Redux</code> 肯定也少不了这个东西。<br>先说到这吧，有什么想说的再来补一补。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;扯一扯&quot;&gt;&lt;a href=&quot;#扯一扯&quot; class=&quot;headerlink&quot; title=&quot;扯一扯&quot;&gt;&lt;/a&gt;扯一扯&lt;/h4&gt;&lt;p&gt;这段时间在看 &lt;code&gt;Redux&lt;/code&gt; 的东西，稍微梳理一下整个框架的流程。其实整个 &lt;code&gt;Redux&lt;/code&gt; 的代码很少，现在我也不能理解很多它的思想，反正先撸出个简单的 &lt;code&gt;Redux&lt;/code&gt; 吧。目标是照着它的流程写一个最简单的，也要支持异步 &lt;code&gt;Action&lt;/code&gt;。也算是个笔记性的东西。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Asncy await Promise的使用</title>
    <link href="http://yoursite.com/2016/12/15/Promise%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/12/15/Promise的使用/</id>
    <published>2016-12-15T03:53:56.000Z</published>
    <updated>2017-02-03T10:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> fetch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="comment">// resolve('success');</span></div><div class="line">            reject(<span class="string">'error'</span>);</div><div class="line">        &#125;, <span class="number">2000</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> testAsync = <span class="keyword">async</span>() =&gt; &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">await</span> fetch();</div><div class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">testAsync().then(<span class="function">(<span class="params">result</span>)=&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'这是成功的---&gt;'</span> + result);</div><div class="line">&#125;).catch(<span class="function">(<span class="params">error</span>)=&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'这是失败的---&gt;'</span> + error);</div><div class="line">&#125;);;</div></pre></td></tr></table></figure>
<p><code>async</code>函数返回的一个 <code>Promise</code>， 调用耗时函数前面加 <code>await</code> 关键字，返回成功的值，可以使用 <code>try..catch</code> 来进行捕获错误。上面的代码可以模拟一次请求的过程，最基本用法差不多都包括了<a id="more"></a></p>
<p><a href="http://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=true&amp;presets=latest,react,stage-2&amp;code=const%20fetch%20=%20%28%29%20=%3E%20%7B%0A%20%20%20%20return%20new%20Promise%28%28resolve,%20reject%29%20=%3E%20%7B%0A%20%20%20%20%20%20%20%20setTimeout%28%28%29%20=%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20//%20resolve%28%27success%27%29;%0A%20%20%20%20%20%20%20%20%20%20%20%20reject%28%27error%27%29;%0A%20%20%20%20%20%20%20%20%7D,%202000%29;%0A%20%20%20%20%7D%29;%0A%7D;%0A%0Aconst%20testAsync%20=%20async%28%29%20=%3E%20%7B%0A%20%20%20%20try%20%7B%0A%20%20%20%20%20%20%20%20%20return%20await%20fetch%28%29;%0A%20%20%20%20%7D%20catch%20%28error%29%20%7B%0A%20%20%20%20%20%20%20%20return%20Promise.reject%28error%29;%0A%20%20%20%20%7D%0A%7D;%0A%0AtestAsync%28%29.then%28%28result%29=%3E%20%7B%0A%20%20%20%20console.log%28%27%E8%BF%99%E6%98%AF%E6%88%90%E5%8A%9F%E7%9A%84---%3E%27%20%2b%20result%29;%0A%7D%29.catch%28%28error%29=%3E%20%7B%0A%20%20%20%20console.log%28%27%E8%BF%99%E6%98%AF%E5%A4%B1%E8%B4%A5%E7%9A%84---%3E%27%20%2b%20error%29;%0A%7D%29;;&amp;experimental=false&amp;loose=false&amp;spec=false&amp;playground=true" target="_blank" rel="external">点我运行</a></p>
<h4 id="Promise-then是异步的"><a href="#Promise-then是异步的" class="headerlink" title="Promise.then是异步的"></a><code>Promise.then</code>是异步的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(function (resolve)&#123;</div><div class="line">    console.log(&quot;inner promise&quot;); // 1</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div><div class="line">promise.then(function(value)&#123;</div><div class="line">    console.log(value); // 3</div><div class="line">&#125;);</div><div class="line">console.log(&quot;outer promise&quot;); // 2</div><div class="line"></div><div class="line"></div><div class="line">----------</div><div class="line">inner promise // 1</div><div class="line">outer promise // 2</div><div class="line">42            // 3</div></pre></td></tr></table></figure>
<p><a href="https://wohugb.gitbooks.io/promise/content/usage/async.html" target="_blank" rel="external">为啥这样</a></p>
<p>更多的关于 <code>Promise</code> 看下面的这本电子书，就不扯了，啦啦啦。</p>
<p>参考:<br><a href="https://wohugb.gitbooks.io/promise/content/index.html" target="_blank" rel="external">JavaScript Promise迷你书（中文版）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fetch = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// resolve(&#39;success&#39;);&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            reject(&lt;span class=&quot;string&quot;&gt;&#39;error&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;, &lt;span class=&quot;number&quot;&gt;2000&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; testAsync = &lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt;() =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; fetch();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (error) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;.reject(error);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;testAsync().then(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;result&lt;/span&gt;)=&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;这是成功的---&amp;gt;&#39;&lt;/span&gt; + result);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;).catch(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;error&lt;/span&gt;)=&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;这是失败的---&amp;gt;&#39;&lt;/span&gt; + error);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt;函数返回的一个 &lt;code&gt;Promise&lt;/code&gt;， 调用耗时函数前面加 &lt;code&gt;await&lt;/code&gt; 关键字，返回成功的值，可以使用 &lt;code&gt;try..catch&lt;/code&gt; 来进行捕获错误。上面的代码可以模拟一次请求的过程，最基本用法差不多都包括了
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
